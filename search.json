{"documents": [{"external_id":"712e5fb8e95aa39cf5b12ffb170cec61","fields":[{"name":"title","value":"Managing Dependencies","type":"string"},{"name":"url","value":"/addons-and-dependencies/managing-dependencies/","type":"enum"},{"name":"body","value":"As you're developing your Ember app, you'll likely run into common scenarios that aren't addressed by Ember itself,\nsuch as authentication or using SASS for your stylesheets.\nEmber CLI provides a common format called Ember Addons for distributing reusable libraries\nto solve these problems.\nAdditionally, you may want to make use of front-end dependencies like a CSS framework\nor a JavaScript datepicker that aren't specific to Ember apps.\nEmber CLI supports installing these packages through the standard Bower package manager.\nAddons\nEmber Addons are installed using NPM (e.g. npm install --save-dev ember-cli-sass).\nAddons may bring in other dependencies by modifying your project's bower.json file automatically.\n\nYou can find listings of addons on Ember Observer.\nBower\nEmber CLI uses the Bower package manager,\nmaking it easy to keep your front-end dependencies up to date.\nThe Bower configuration file, bower.json, is located at the root of your Ember CLI project,\nand lists the dependencies for your project.\nExecuting bower install will install all of the dependencies listed in bower.json in one step.\n\nEmber CLI watches bower.json for changes.\nThus it reloads your app if you install new dependencies via bower install \u003cdependencies\u003e --save.\nOther assets\nAssets not available as an addon or Bower package should be placed in the vendor folder in your project.\nCompiling Assets\nWhen you're using dependencies that are not included in an addon,\nyou will have to instruct Ember CLI to include your assets in the build.\nThis is done using the asset manifest file ember-cli-build.js.\nYou should only try to import assets located in the bower_components and vendor folders.\nGlobals provided by Javascript assets\nThe globals provided by some assets (like moment in the below example) can be used in your application\nwithout the need to import them.\nProvide the asset path as the first and only argument.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n\n  app.import('bower_components/moment/moment.js');\n\n\n\nYou will need to add \"moment\": true to the predef section in .jshintrc to prevent JSHint errors\nabout using an undefined variable.\nAMD Javascript modules\nProvide the asset path as the first argument, and the list of modules and exports as the second.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  app.import('bower_components/ic-ajax/dist/named-amd/main.js', {\n  exports: {\n    'ic-ajax': [\n      'default',\n      'defineFixture',\n      'lookupFixture',\n      'raw',\n      'request'\n    ]\n  }\n});\n\n\n\nYou can now import them in your app. (e.g. import { raw as icAjaxRaw } from 'ic-ajax';)\nEnvironment Specific Assets\nIf you need to use different assets in different environments, specify an object as the first parameter.\nThat object's key should be the environment name, and the value should be the asset to use in that environment.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n2\n3\n4\n\n  app.import({\n  development: 'bower_components/ember/ember.js',\n  production:  'bower_components/ember/ember.prod.js'\n});\n\n\n\nIf you need to import an asset in only one environment you can wrap app.import in an if statement.\nFor assets needed during testing, you should also use the {type: 'test'} option to make sure they\nare available in test mode.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  if (app.env === 'development') {\n  // Only import when in development mode\n  app.import('vendor/ember-renderspeed/ember-renderspeed.js');\n}\nif (app.env === 'test') {\n  // Only import in test mode and place in test-support.js\n  app.import(app.bowerDirectory + '/sinonjs/sinon.js', { type: 'test' });\n  app.import(app.bowerDirectory + '/sinon-qunit/lib/sinon-qunit.js', { type: 'test' });\n}\n\n\nCSS\nProvide the asset path as the first argument:\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n\n  app.import('bower_components/foundation/css/foundation.css');\n\n\n\nAll style assets added this way will be concatenated and output as /assets/vendor.css.\nOther Assets\nAll other assets like images or fonts can also be added via import().\nBy default, they\nwill be copied to dist/ as they are.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n\n  app.import('bower_components/font-awesome/fonts/fontawesome-webfont.ttf');\n\n\n\nThis example would create the font file in dist/font-awesome/fonts/fontawesome-webfont.ttf.\n\nYou can also optionally tell import() to place the file at a different path.\nThe following example will copy the file to dist/assets/fontawesome-webfont.ttf.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n2\n3\n\n  app.import('bower_components/font-awesome/fonts/fontawesome-webfont.ttf', {\n  destDir: 'assets'\n});\n\n\n\nIf you need to load certain dependencies before others,\nyou can set the prepend property equal to true on the second argument of import().\nThis will prepend the dependency to the vendor file instead of appending it, which is the default behavior.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n2\n3\n4\n\n  app.import('bower_components/es5-shim/es5-shim.js', {\n  type: 'vendor',\n  prepend: true\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e1e33e1164aae59122e344151a7b6a4f","fields":[{"name":"title","value":"Applications and Instances","type":"string"},{"name":"url","value":"/applications/applications-and-instances/","type":"enum"},{"name":"body","value":"Every Ember application is represented by a class that extends Ember.Application.\nThis class is used to declare and configure the many objects that make up your app.\n\nAs your application boots,\nit creates an Ember.ApplicationInstance that is used to manage its stateful aspects.\nThis instance acts as the \"owner\" of objects instantiated for your app.\n\nEssentially, the Application defines your application\nwhile the ApplicationInstance manages its state.\n\nThis separation of concerns not only clarifies the architecture of your app,\nit can also improve its efficiency.\nThis is particularly true when your app needs to be booted repeatedly during testing\nand / or server-rendering (e.g. via FastBoot).\nThe configuration of a single Application can be done once\nand shared among multiple stateful ApplicationInstance instances.\nThese instances can be discarded once they're no longer needed\n(e.g. when a test has run or FastBoot request has finished).\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6dc47d4b01c5fc819e641b21e5148081","fields":[{"name":"title","value":"Dependency Injection","type":"string"},{"name":"url","value":"/applications/dependency-injection/","type":"enum"},{"name":"body","value":"Ember applications utilize the dependency injection\n(\"DI\") design pattern to declare and instantiate classes of objects and dependencies between them.\nApplications and application instances each serve a role in Ember's DI implementation.\n\nAn Ember.Application serves as a \"registry\" for dependency declarations.\nFactories (i.e. classes) are registered with an application,\nas well as rules about \"injecting\" dependencies that are applied when objects are instantiated.\n\nAn Ember.ApplicationInstance serves as the \"owner\" for objects that are instantiated from registered factories.\nApplication instances provide a means to \"look up\" (i.e. instantiate and / or retrieve) objects.\n\n\nNote: Although an Application serves as the primary registry for an app,\neach ApplicationInstance can also serve as a registry.\nInstance-level registrations are useful for providing instance-level customizations,\nsuch as A/B testing of a feature.\n\nFactory Registrations\nA factory can represent any part of your application, like a route, template, or custom class.\nEvery factory is registered with a particular key.\nFor example, the index template is registered with the key template:index,\nand the application route is registered with the key route:application.\n\nRegistration keys have two segments split by a colon (:).\nThe first segment is the framework factory type, and the second is the name of the particular factory.\nHence, the index template has the key template:index.\nEmber has several built-in factory types, such as service, route, template, and component.\n\nYou can create your own factory type by simply registering a factory with the new type.\nFor example, to create a user type,\nyou'd simply register your factory with application.register('user:user-to-register').\n\nFactory registrations must be performed either in application\nor application instance initializers (with the former being much more common).\n\nFor example, an application initializer could register a Logger factory with the key logger:main:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export function initialize(application) {\n  var Logger = Ember.Object.extend({\n    log(m) {\n      console.log(m);\n    }\n  });\n\n  application.register('logger:main', Logger);\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\nRegistering Already Instantiated Objects\nBy default, Ember will attempt to instantiate a registered factory when it is looked up.\nWhen registering an already instantiated object instead of a class,\nuse the instantiate: false option to avoid attempts to re-instantiate it during lookups.\n\nIn the following example, the logger is a plain JavaScript object that should\nbe returned \"as is\" when it's looked up:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export function initialize(application) {\n  var logger = {\n    log(m) {\n      console.log(m);\n    }\n  };\n\n  application.register('logger:main', logger, { instantiate: false });\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\nRegistering Singletons vs. Non-Singletons\nBy default, registrations are treated as \"singletons\".\nThis simply means that an instance will be created when it is first looked up,\nand this same instance will be cached and returned from subsequent lookups.\n\nWhen you want fresh objects to be created for every lookup,\nregister your factories as non-singletons using the singleton: false option.\n\nIn the following example, the Message class is registered as a non-singleton:\n\n  \n    \n      app/initializers/notification.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export function initialize(application) {\n  var Message = Ember.Object.extend({\n    text: ''\n  });\n\n  application.register('notification:message', Message, { singleton: false });\n}\n\nexport default {\n  name: 'notification',\n  initialize: initialize\n};\n\n\nFactory Injections\nOnce a factory is registered, it can be \"injected\" where it is needed.\n\nFactories can be injected into whole \"types\" of factories with type injections. For example:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export function initialize(application) {\n  var Logger = Ember.Object.extend({\n    log(m) {\n      console.log(m);\n    }\n  });\n\n  application.register('logger:main', Logger);\n  application.inject('route', 'logger', 'logger:main');\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\n\nAs a result of this type injection,\nall factories of the type route will be instantiated with the property logger injected.\nThe value of logger will come from the factory named logger:main.\n\nRoutes in this example application can now access the injected logger:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Route.extend({\n  activate() {\n    // The logger property is injected into all routes\n    this.get('logger').log('Entered the index route!');\n  }\n});\n\n\n\nInjections can also be made on a specific factory by using its full key:\n\n  1\n\n  application.inject('route:index', 'logger', 'logger:main');\n\n\n\nIn this case, the logger will only be injected on the index route.\n\nInjections can be made onto any class that requires instantiation.\nThis includes all of Ember's major framework classes, such as components, helpers, routes, and the router.\nAd Hoc Injections\nDependency injections can also be declared directly on Ember classes using Ember.inject.\nCurrently, Ember.inject supports injecting controllers (via Ember.inject.controller)\nand services (via Ember.inject.service).\n\nThe following code injects the shopping-cart service on the cart-contents component as the property cart:\n\n  \n    \n      app/components/cart-contents.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  cart: Ember.inject.service('shopping-cart')\n});\n\n\n\nIf you'd like to inject a service with the same name as the property,\nsimply leave off the service name (the dasherized version of the name will be used):\n\n  \n    \n      app/components/cart-contents.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  shoppingCart: Ember.inject.service()\n});\n\n\nFactory Instance Lookups\nTo fetch an instantiated factory from the running application you can call the\nlookup method on an application instance. This method takes a string\nto identify a factory and returns the appropriate object.\n\n  1\n\n  applicationInstance.lookup('factory-type:factory-name');\n\n\n\nThe application instance is passed to Ember's instance initializer hooks and it\nis added as the \"owner\" of each object that was instantiated by the application\ninstance.\nUsing an Application Instance Within an Instance Initializer\nInstance initializers receive an application instance as an argument, providing\nan opportunity to look up an instance of a registered factory.\n\n  \n    \n      app/instance-initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export function initialize(applicationInstance) {\n  let logger = applicationInstance.lookup('logger:main');\n\n  logger.log('Hello from the instance initializer!');\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\nGetting an Application Instance from a Factory Instance\nEmber.getOwner will retrieve the application instance that \"owns\" an\nobject. This means that framework objects like components, helpers, and routes\ncan use Ember.getOwner to perform lookups through their application\ninstance at runtime.\n\nFor example, this component plays songs with different audio services based\non a song's audioType.\n\n  \n    \n      app/components/play-audio.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  import Ember from 'ember';\nconst {\n  Component,\n  computed,\n  getOwner\n} = Ember;\n\n// Usage:\n//\n//   {{play-audio song=song}}\n//\nexport default Component.extend({\n  audioService: computed('song.audioType', function() {\n    let applicationInstance = getOwner(this);\n    let audioType = this.get('song.audioType');\n    return applicationInstance.lookup(`service:audio-${audioType}`);\n  }),\n\n  click() {\n    let player = this.get('audioService');\n    player.play(this.get('song.file'));\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d42b8021b21156225227a3820a1acfb2","fields":[{"name":"title","value":"Initializers","type":"string"},{"name":"url","value":"/applications/initializers/","type":"enum"},{"name":"body","value":"Initializers provide an opportunity to configure your application as it boots.\n\nThere are two types of initializers: application initializers and application instance initializers.\n\nApplication initializers are run as your application boots,\nand provide the primary means to configure dependency injections in your application.\n\nApplication instance initializers are run as an application instance is loaded.\nThey provide a way to configure the initial state of your application,\nas well as to set up dependency injections that are local to the application instance\n(e.g. A/B testing configurations).\n\nOperations performed in initializers should be kept as lightweight as possible\nto minimize delays in loading your application.\nAlthough advanced techniques exist for allowing asynchrony in application initializers\n(i.e. deferReadiness and advanceReadiness), these techniques should generally be avoided.\nAny asynchronous loading conditions (e.g. user authorization) are almost always\nbetter handled in your application route's hooks,\nwhich allows for DOM interaction while waiting for conditions to resolve.\nApplication Initializers\nApplication initializers can be created with Ember CLI's initializer generator:\n\n  1\n\n  ember generate initializer shopping-cart\n\n\n\nLet's customize the shopping-cart initializer to inject a cart property into all the routes in your application:\n\n  \n    \n      app/initializers/shopping-cart.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export function initialize(application) {\n  application.inject('route', 'cart', 'service:shopping-cart');\n};\n\nexport default {\n  name: 'shopping-cart',\n  initialize: initialize\n};\n\n\nApplication Instance Initializers\nApplication instance initializers can be created with Ember CLI's instance-initializer generator:\n\n  1\n\n  ember generate instance-initializer logger\n\n\n\nLet's add some simple logging to indicate that the instance has booted:\n\n  \n    \n      app/instance-initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export function initialize(applicationInstance) {\n  var logger = applicationInstance.lookup('logger:main');\n  logger.log('Hello from the instance initializer!');\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\nSpecifying Initializer Order\nIf you'd like to control the order in which initializers run, you can use the before and/or after options:\n\n  \n    \n      app/initializers/config-reader.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export function initialize(application) {\n  // ... your code ...\n};\n\nexport default {\n  name: 'configReader',\n  before: 'websocketInit',\n  initialize: initialize\n};\n\n\n\n  \n    \n      app/initializers/websocket-init.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export function initialize(application) {\n  // ... your code ...\n};\n\nexport default {\n  name: 'websocketInit',\n  after: 'configReader',\n  initialize: initialize\n};\n\n\n\nNote that ordering only applies to initializers of the same type (i.e. application or application instance).\nApplication initializers will always run before application instance initializers.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a840458ea333b782c4c091667a396113","fields":[{"name":"title","value":"The Run Loop","type":"string"},{"name":"url","value":"/applications/run-loop/","type":"enum"},{"name":"body","value":"Ember's internals and most of the code you will write in your applications takes place in a run loop.\nThe run loop is used to batch, and order (or reorder) work in a way that is most effective and efficient.\n\nIt does so by scheduling work on specific queues.\nThese queues have a priority, and are processed to completion in priority order.\n\nFor basic Ember app development scenarios, you don't need to understand the run loop or use it directly.\nAll common paths are paved nicely for you and don't require working with the run loop directly.\n\nThe most common case for using the run loop is integrating with a non-Ember API\nthat includes some sort of asynchronous callback.\nFor example:\n\n\nDOM update and event callbacks\nsetTimeout and setInterval callbacks\npostMessage and messageChannel event handlers\nAJAX callbacks\nWebsocket callbacks\n\nWhy is the run loop useful?\nVery often, batching similar work has benefits.\nWeb browsers do something quite similar by batching changes to the DOM.\n\nConsider the following HTML snippet:\n\n  1\n2\n3\n\n  \u003cdiv id=\"foo\"\u003e\u003c/div\u003e\n\u003cdiv id=\"bar\"\u003e\u003c/div\u003e\n\u003cdiv id=\"baz\"\u003e\u003c/div\u003e\n\n\n\nand executing the following code:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  foo.style.height = '500px' // write\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\n\nbar.style.height = '400px' // write\nbar.offsetHeight // read (recalculate style, layout, expensive!)\n\nbaz.style.height = '200px' // write\nbaz.offsetHeight // read (recalculate style, layout, expensive!)\n\n\n\nIn this example, the sequence of code forced the browser to recalculate style, and relayout after each step.\nHowever, if we were able to batch similar jobs together,\nthe browser would have only needed to recalculate the style and layout once.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  foo.style.height = '500px' // write\nbar.style.height = '400px' // write\nbaz.style.height = '200px' // write\n\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\nbar.offsetHeight // read (fast since style and layout is already known)\nbaz.offsetHeight // read (fast since style and layout is already known)\n\n\n\nInterestingly, this pattern holds true for many other types of work.\nEssentially, batching similar work allows for better pipelining, and further optimization.\n\nLet's look at a similar example that is optimized in Ember, starting with a User object:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var User = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  })\n});\n\n\n\nand a template to display its attributes:\n\n  1\n2\n\n  {{firstName}}\n{{fullName}}\n\n\n\nIf we execute the following code without the run loop:\n\n  1\n2\n3\n4\n5\n6\n\n  var user = User.create({ firstName: 'Tom', lastName: 'Huda' });\nuser.set('firstName', 'Yehuda');\n// {{firstName}} and {{fullName}} are updated\n\nuser.set('lastName', 'Katz');\n// {{lastName}} and {{fullName}} are updated\n\n\n\nWe see that the browser will rerender the template twice.\n\nHowever, if we have the run loop in the above code,\nthe browser will only rerender the template once the attributes have all been set.\n\n  1\n2\n3\n4\n5\n\n  var user = User.create({ firstName: 'Tom', lastName: 'Huda' });\nuser.set('firstName', 'Yehuda');\nuser.set('lastName', 'Katz');\nuser.set('firstName', 'Tom');\nuser.set('lastName', 'Huda');\n\n\n\nIn the above example with the run loop, since the user's attributes end up at the same values as before execution,\nthe template will not even rerender!\n\nIt is of course possible to optimize these scenarios on a case-by-case basis,\nbut getting them for free is much nicer.\nUsing the run loop, we can apply these classes of optimizations not only for each scenario, but holistically app-wide.\nHow does the Run Loop work in Ember?\nAs mentioned earlier, we schedule work (in the form of function invocations) on queues,\nand these queues are processed to completion in priority order.\n\nWhat are the queues, and what is their priority order?\n\n  1\n2\n\n  Ember.run.queues\n// =\u003e [\"sync\", \"actions\", \"routerTransitions\", \"render\", \"afterRender\", \"destroy\"]\n\n\n\nBecause the priority is first to last, the \"sync\" queue has higher priority than the \"render\" or \"destroy\" queue.\nWhat happens in these queues?\n\nThe sync queue contains binding synchronization jobs.\nThe actions queue is the general work queue and will typically contain scheduled tasks e.g. promises.\nThe routerTransitions queue contains transition jobs in the router.\nThe render queue contains jobs meant for rendering, these will typically update the DOM.\nThe afterRender queue contains jobs meant to be run after all previously scheduled render tasks are complete.\nThis is often good for 3rd-party DOM manipulation libraries,\nthat should only be run after an entire tree of DOM has been updated.\nThe destroy queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy.\n\nIn what order are jobs executed on the queues?\nThe algorithm works this way:\n\n\nLet the highest priority queue with pending jobs be: CURRENT_QUEUE,\nif there are no queues with pending jobs the run loop is complete\nLet a new temporary queue be defined as WORK_QUEUE\nMove jobs from CURRENT_QUEUE into WORK_QUEUE\nProcess all the jobs sequentially in WORK_QUEUE\nReturn to Step 1\n\nAn example of the internals\nRather than writing the higher level app code that internally invokes the various run loop scheduling functions,\nwe have stripped away the covers, and shown the raw run-loop interactions.\n\nWorking with this API directly is not common in most Ember apps,\nbut understanding this example will help you to understand the run-loops algorithm,\nwhich will make you a better Ember developer.\n\n\nHow do I tell Ember to start a run loop?\nYou should begin a run loop when the callback fires.\n\nThe Ember.run method can be used to create a runloop.\nIn this example, jQuery and Ember.run are used to handle a click event and run some Ember code.\n\nThis example uses the =\u003e function syntax, which is a new ES2015 syntax for callback functions\nthat provides a lexical this.\nIf this syntax is new,\nthink of it as a function that has the same this as the context it is defined in.\n\n  1\n2\n3\n4\n5\n\n  $('a').click(() =\u003e {\n  Ember.run(() =\u003e {  // begin loop\n    // Code that results in jobs being scheduled goes here\n  }); // end loop, jobs are flushed and executed\n});\n\n\nWhat happens if I forget to start a run loop in an async handler?\nAs mentioned above, you should wrap any non-Ember async callbacks in Ember.run.\nIf you don't, Ember will try to approximate a beginning and end for you.\nConsider the following callback:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  $('a').click(() =\u003e {\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', () =\u003e {\n    // Do more things\n  });\n});\n\n\n\nThe runloop API calls that schedule work i.e. run.schedule, run.scheduleOnce,\nrun.once have the property that they will approximate a runloop for you if one does not already exist.\nThese automatically created runloops we call autoruns.\n\nHere is some pseudocode to describe what happens using the example above:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n  $('a').click(() =\u003e {\n  // 1. autoruns do not change the execution of arbitrary code in a callback.\n  //    This code is still run when this callback is executed and will not be\n  //    scheduled on an autorun.\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', () =\u003e {\n    // 2. schedule notices that there is no currently available runloop so it\n    //    creates one. It schedules it to close and flush queues on the next\n    //    turn of the JS event loop.\n    if (! Ember.run.hasOpenRunloop()) {\n      Ember.run.start();\n      nextTick(() =\u003e {\n        Ember.run.end()\n      }, 0);\n    }\n\n    // 3. There is now a runloop available so schedule adds its item to the\n    //    given queue\n    Ember.run.schedule('actions', () =\u003e {\n      // Do more things\n    });\n\n  });\n\n  // 4. This schedule sees the autorun created by schedule above as an available\n  //    runloop and adds its item to the given queue.\n  Ember.run.schedule('afterRender', () =\u003e {\n    // Do yet more things\n  });\n});\n\n\n\nAlthough autoruns are convenient, they are suboptimal.\nThe current JS frame is allowed to end before the run loop is flushed,\nwhich sometimes means the browser will take the opportunity to do other things, like garbage collection.\nGC running in between data changing and DOM rerendering can cause visual lag and should be minimized.\n\nRelying on autoruns is not a rigorous or efficient way to use the runloop.\nWrapping event handlers manually is preferred.\nHow is runloop behaviour different when testing?\nWhen your application is in testing mode then Ember will throw an error if you try to schedule work\nwithout an available runloop.\n\nAutoruns are disabled in testing for several reasons:\n\n\nAutoruns are Embers way of not punishing you in production if you forget to open a runloop\nbefore you schedule callbacks on it.\nWhile this is useful in production, these are still situations that should be revealed in testing\nto help you find and fix them.\nSome of Ember's test helpers are promises that wait for the run loop to empty before resolving.\nIf your application has code that runs outside a runloop,\nthese will resolve too early and give erroneous test failures which are difficult to find.\nDisabling autoruns help you identify these scenarios and helps both your testing and your application!\n\nWhere can I find more information?\nCheck out the Ember.run API documentation,\nas well as the Backburner library that powers the run loop.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"de74394cb5de1e6f7bbcd8e9446fab89","fields":[{"name":"title","value":"Services","type":"string"},{"name":"url","value":"/applications/services/","type":"enum"},{"name":"body","value":"An Ember.Service is a long-lived Ember object that can be made available in different parts of your application.\n\nServices are useful for features that require shared state or persistent connections. Example uses of services might\ninclude:\n\n\nUser/session authentication.\nGeolocation.\nWeb Sockets.\nServer-sent events or notifications.\nServer-backed API calls that may not fit Ember Data.\nThird-party APIs.\nLogging.\n\nDefining Services\nServices can be generated using Ember CLI's service generator.\nFor example, the following command will create the ShoppingCart service:\n\n  1\n\n  ember generate service shopping-cart\n\n\n\nServices must extend the Ember.Service base class:\n\n  \n    \n      app/services/shopping-cart.js\n    \n  \n\n  1\n2\n\n  export default Ember.Service.extend({\n});\n\n\n\nLike any Ember object, a service is initialized and can have properties and methods of its own.\nBelow the shopping cart service manages an items array that represents the items currently in the shopping cart.\n\n  \n    \n      app/services/shopping-cart.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  export default Ember.Service.extend({\n  items: null,\n\n  init() {\n    this._super(...arguments);\n    this.set('items', []);\n  },\n\n  add(item) {\n    this.get('items').pushObject(item);\n  },\n\n  remove(item) {\n    this.get('items').removeObject(item);\n  },\n\n  empty() {\n    this.get('items').setObjects([]);\n  }\n});\n\n\nAccessing Services\nTo access a service,\nyou can inject it in any container-resolved object such as a component or another service using the Ember.inject.service function.\nThere are 2 ways to use this function.\nYou can either invoke it with no arguments, or you can pass it the registered name of the service.\nWhen no arguments are passed the services is loaded based in the name of the variable key.\nYou can load the shopping cart service with no arguments like below.\n\n  \n    \n      app/components/cart-contents.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  //will load the service in file /app/services/shopping-cart.js\n  shoppingCart: Ember.inject.service()\n});\n\n\n\nThe other way to inject a service is to provide the name of the service as the argument.\n\n  \n    \n      app/components/cart-contents.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  //will load the service in file /app/services/shopping-cart.js\n  cart: Ember.inject.service('shopping-cart')\n});\n\n\n\nThis injects the shopping cart service into the component and makes it available as the cart property.\n\nInjected properties are lazy loaded; meaning the service will not be instantiated until the property is explicitly called.\nTherefore you need to access services in your component using the get function otherwise you might get an undefined.\n\nOnce loaded, a service will persist until the application exits.\n\nBelow we add a remove action to the cart-contents component.\nNotice that below we access the cart service with a call tothis.get.\n\n  \n    \n      app/components/cart-contents.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Component.extend({\n  cart: Ember.inject.service('shopping-cart'),\n\n  actions: {\n    remove(item) {\n      this.get('cart').remove(item);\n    }\n  }\n});\n\n\n\nOnce injected into a component, a service can also be used in the template.\nNote cart being used below to get data from the cart.\n\n  \n    \n      app/templates/components/cart-contents.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  \u003cul\u003e\n  {{#each cart.items as |item|}}\n    \u003cli\u003e\n      {{item.name}}\n      \u003cbutton {{action \"remove\" item}}\u003eRemove\u003c/button\u003e\n    \u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0000f322c4b0c17f07f32709be60bb21","fields":[{"name":"title","value":"Using Block Params","type":"string"},{"name":"url","value":"/components/block-params/","type":"enum"},{"name":"body","value":"Components can have properties passed in (Passing Properties to a Component),\nbut they can also return output to be used in a block expression.\nReturn values from a component with yield\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n\n  {{{blog-post post=model}}}\n\n\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n\n  {{yield post.title post.body post.author}}\n\n\n\nHere an entire blog post model is being passed to the component as a single component property.\nIn turn the component is returning values using yield.\nIn this case the yielded values are pulled from the post being passed in\nbut anything that the component has access to can be yielded, such as an internal property or something from a service.\nConsuming yielded values with block params\nThe block expression can then use block params to bind names to any yielded values for use in the block.\nThis allows for template customization when using a component,\nwhere the markup is provided by the consuming template,\nbut any event handling behavior implemented in the component is retained such as click() handlers.\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  {{#blog-post post=model as |title body author|}}\n  \u003ch2\u003e{{title}}\u003c/h2\u003e\n  \u003cp class=\"author\"\u003eby {{author}}\u003c/p\u003e\n  \u003cdiv class=\"post-body\"\u003e{{body}}\u003c/p\u003e\n{{/blog-post}}\n\n\n\nThe names are bound in the order that they are passed to yield in the component template.\nSupporting both block and non-block component usage in one template\nIt is possible to support both block and non-block usage of a component from a single component template\nusing the hasBlock property.\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  {{#if hasBlock}}\n  {{yield post.title}}\n  {{yield post.body}}\n  {{yield post.author}}\n{{else}}\n  \u003ch1\u003e{{post.title}}\u003c/h1\u003e\n  \u003cp class=\"author\"\u003eAuthored by {{post.author}}\u003c/p\u003e\n  \u003cp\u003e{{post.body}}\u003c/p\u003e\n{{/if}}\n\n\n\nThis has the effect of providing a default template when using a component in the non-block form\nbut providing yielded values for use with block params when using a block expression.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"47913aec12ee9dbd0749f8ee0c891428","fields":[{"name":"title","value":"Customizing a Component's Element","type":"string"},{"name":"url","value":"/components/customizing-a-components-element/","type":"enum"},{"name":"body","value":"By default, each component is backed by a \u003cdiv\u003e element. If you were\nto look at a rendered component in your developer tools, you would see\na DOM representation that looked something like:\n\n  1\n2\n3\n\n  \u003cdiv id=\"ember180\" class=\"ember-view\"\u003e\n  \u003ch1\u003eMy Component\u003c/h1\u003e\n\u003c/div\u003e\n\n\n\nYou can customize what type of element Ember generates for your\ncomponent, including its attributes and class names, by creating a\nsubclass of Ember.Component in your JavaScript.\nCustomizing the Element\nTo use a tag other than div, subclass Ember.Component and assign it\na tagName property. This property can be any valid HTML5 tag name as a\nstring.\n\n  \n    \n      app/components/navigation-bar.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  tagName: 'nav'\n});\n\n\n\n  \n    \n      app/templates/components/navigation-bar.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003cul\u003e\n  \u003cli\u003e{{#link-to \"home\"}}Home{{/link-to}}\u003c/li\u003e\n  \u003cli\u003e{{#link-to \"about\"}}About{{/link-to}}\u003c/li\u003e\n\u003c/ul\u003e\n\n\nCustomizing the Element's Class\nYou can specify the class of a component's element at invocation time the same\nway you would for a regular HTML element:\n\n  1\n\n  {{navigation-bar class=\"primary\"}}\n\n\n\nYou can also specify which class names are applied to the component's\nelement by setting its classNames property to an array of strings:\n\n  \n    \n      app/components/navigation-bar.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  classNames: ['primary']\n});\n\n\n\nIf you want class names to be determined by properties of the component,\nyou can use class name bindings. If you bind to a Boolean property, the\nclass name will be added or removed depending on the value:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isUrgent'],\n  isUrgent: true\n});\n\n\n\nThis component would render the following:\n\n  1\n\n  \u003cdiv class=\"ember-view is-urgent\"\u003e\u003c/div\u003e\n\n\n\nIf isUrgent is changed to false, then the is-urgent class name will be removed.\n\nBy default, the name of the Boolean property is dasherized. You can customize the class name\napplied by delimiting it with a colon:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isUrgent:urgent'],\n  isUrgent: true\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view urgent\"\u003e\n\n\n\nBesides the custom class name for the value being true, you can also specify a class name which is used when the value is false:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isEnabled:enabled:disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nYou can also specify a class which should only be added when the property is\nfalse by declaring classNameBindings like this:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isEnabled::disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nIf the isEnabled property is set to true, no class name is added:\n\n  1\n\n  \u003cdiv class=\"ember-view\"\u003e\n\n\n\nIf the bound property's value is a string, that value will be added as a class name without\nmodification:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['priority'],\n  priority: 'highestPriority'\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view highestPriority\"\u003e\n\n\nCustomizing Attributes\nYou can bind attributes to the DOM element that represents a component\nby using attributeBindings:\n\n  \n    \n      app/components/link-item.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  tagName: 'a',\n  attributeBindings: ['href'],\n  href: 'http://emberjs.com'\n});\n\n\n\nYou can also bind these attributes to differently named properties:\n\n  \n    \n      app/components/link-item.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  tagName: 'a',\n  attributeBindings: ['customHref:href'],\n  customHref: 'http://emberjs.com'\n});\n\n\n\nIf the attribute is null, it won't be rendered:\n\n  \n    \n      app/components/link-item.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  tagName: 'span',\n  title: null,\n  attributeBindings: ['title'],\n});\n\n\n\nThis would render this HTML when no title is passed to the component:\n\n  1\n\n  \u003cspan class=\"ember-view\"\u003e\n\n\n\n...and this HTML when a title of \"Ember JS\" is passed to the component:\n\n  1\n\n  \u003cspan class=\"ember-view\" title=\"Ember JS\"\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6faa3aaa66dd8ba5f798d307f0136e3c","fields":[{"name":"title","value":"Defining a Component","type":"string"},{"name":"url","value":"/components/defining-a-component/","type":"enum"},{"name":"body","value":"To define a component, run:\n\n  1\n\n  ember generate component my-component-name\n\n\n\nComponents must have at least one dash in their name. So blog-post is an acceptable\nname, and so is audio-player-controls, but post is not. This prevents clashes with\ncurrent or future HTML element names, aligns Ember components with the W3C Custom\nElements\nspec, and ensures Ember detects the components automatically.\n\nA sample component template could look like this:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003carticle class=\"blog-post\"\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cp\u003e{{yield}}\u003c/p\u003e\n  \u003cp\u003eEdit title: {{input type=\"text\" value=title}}\u003c/p\u003e\n\u003c/article\u003e\n\n\n\nGiven the above template, you can now use the {{blog-post}} component:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  {{#each model as |post|}}\n  {{#blog-post title=post.title}}\n    {{post.body}}\n  {{/blog-post}}\n{{/each}}\n\n\n\nIts model is populated in model hook in the route handler:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findAll('post');\n  }\n});\n\n\n\nEach component, under the hood, is backed by an element. By default\nEmber will use a \u003cdiv\u003e element to contain your component's template.\nTo learn how to change the element Ember uses for your component, see\nCustomizing a Component's\nElement.\nDefining a Component Subclass\nOften times, your components will just encapsulate certain snippets of\nHandlebars templates that you find yourself using over and over. In\nthose cases, you do not need to write any JavaScript at all. Define\nthe Handlebars template as described above and use the component that is\ncreated.\n\nIf you need to customize the behavior of the component you'll\nneed to define a subclass of Ember.Component. For example, you would\nneed a custom subclass if you wanted to change a component's element,\nrespond to actions from the component's template, or manually make\nchanges to the component's element using JavaScript.\n\nEmber knows which subclass powers a component based on its filename. For\nexample, if you have a component called blog-post, you would create a\nfile at app/components/blog-post.js. If your component was called\naudio-player-controls, the file name would be at\napp/components/audio-player-controls.js.\nDynamically rendering a component\nThe {{component}} helper can be used to defer the selection of a component to\nrun time. The {{my-component}} syntax always renders the same component,\nwhile using the {{component}} helper allows choosing a component to render on\nthe fly. This is useful in cases where you want to interact with different\nexternal libraries depending on the data. Using the {{component}} helper would\nallow you to keep different logic well separated.\n\nThe first parameter of the helper is the name of a component to render, as a\nstring. So {{component 'blog-post'}} is the same as using {{blog-post}}.\n\nThe real value of {{component}} comes from being able to dynamically pick\nthe component being rendered. Below is an example of using the helper as a\nmeans of choosing different components for displaying different kinds of posts:\n\n  \n    \n      app/templates/components/foo-component.hbs\n    \n  \n\n  1\n2\n\n  \u003ch3\u003eHello from foo!\u003c/h3\u003e\n\u003cp\u003e{{post.body}}\u003c/p\u003e\n\n\n\n  \n    \n      app/templates/components/bar-component.hbs\n    \n  \n\n  1\n2\n\n  \u003ch3\u003eHello from bar!\u003c/h3\u003e\n\u003cdiv\u003e{{post.author}}\u003c/div\u003e\n\n\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findAll('post');\n  }\n});\n\n\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  {{#each model as |post|}}\n  {{!-- either foo-component or bar-component --}}\n  {{component post.componentName post=post}}\n{{/each}}\n\n\n\nWhen the parameter passed to {{component}} evaluates to null or undefined,\nthe helper renders nothing. When the parameter changes, the currently rendered\ncomponent is destroyed and the new component is created and brought in.\n\nPicking different components to render in response to the data allows you to\nhave different template and behavior for each case. The {{component}} helper\nis a powerful tool for improving code modularity.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ea688f6a5cc0ff994d040e8d75335c8e","fields":[{"name":"title","value":"Handling Events","type":"string"},{"name":"url","value":"/components/handling-events/","type":"enum"},{"name":"body","value":"You can respond to user events on your component like double-clicking, hovering,\nand key presses through event handlers. Simply implement the name of the event\nyou want to respond to as a method on your component.\n\nFor example, imagine we have a template like this:\n\n  1\n2\n3\n\n  {{#double-clickable}}\n  This is a double clickable area!\n{{/double-clickable}}\n\n\n\nLet's implement double-clickable such that when it is\nclicked, an alert is displayed:\n\n  \n    \n      app/components/double-clickable.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  doubleClick() {\n    alert(\"DoubleClickableComponent was clicked!\");\n  }\n});\n\n\n\nBrowser events may bubble up the DOM which potentially target parent component(s)\nin succession. To enable bubbling return true; from the event handler method\nin your component.\n\n  \n    \n      app/components/double-clickable.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Component.extend({\n  doubleClick() {\n    Ember.Logger.info(\"DoubleClickableComponent was clicked!\");\n    return true;\n  }\n});\n\n\n\nSee the list of event names at the end of this page. Any event can be defined\nas an event handler in your component.\nSending Actions\nIn some cases your component needs to define event handlers, perhaps to support\nvarious draggable behaviors. For example, a component may need to send an id\nwhen it receives a drop event:\n\n  1\n\n  {{drop-target action=\"didDrop\"}}\n\n\n\nYou can define the component's event handlers to manage the drop event.\nAnd if you need to, you may also stop events from bubbling, by using\nreturn false;.\n\n  \n    \n      app/components/drop-target.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Component.extend({\n  attributeBindings: ['draggable'],\n  draggable: 'true',\n\n  dragOver() {\n    return false;\n  },\n\n  drop(event) {\n    let id = event.dataTransfer.getData('text/data');\n    this.sendAction('action', id);\n  }\n});\n\n\nEvent Names\nThe event handling examples described above respond to one set of events.\nThe names of the built-in events are listed below. Custom events can be\nregistered by using Ember.Application.customEvents.\n\nTouch events:\n\n\ntouchStart\ntouchMove\ntouchEnd\ntouchCancel\n\n\nKeyboard events\n\n\nkeyDown\nkeyUp\nkeyPress\n\n\nMouse events\n\n\nmouseDown\nmouseUp\ncontextMenu\nclick\ndoubleClick\nmouseMove\nfocusIn\nfocusOut\nmouseEnter\nmouseLeave\n\n\nForm events:\n\n\nsubmit\nchange\nfocusIn\nfocusOut\ninput\n\n\nHTML5 drag and drop events:\n\n\ndragStart\ndrag\ndragEnter\ndragLeave\ndragOver\ndragEnd\ndrop\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8d2797c18261ac73c76de693da7cae13","fields":[{"name":"title","value":"Passing Properties to a Component","type":"string"},{"name":"url","value":"/components/passing-properties-to-a-component/","type":"enum"},{"name":"body","value":"Components are isolated from their surroundings, so any data that the component\nneeds has to be passed in.\n\nFor example, imagine you have a blog-post component that is used to\ndisplay a blog post:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003carticle class=\"blog-post\"\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cp\u003e{{body}}\u003c/p\u003e\n\u003c/article\u003e\n\n\n\nNow imagine we have the following template and route:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findAll('post');\n  }\n});\n\n\n\nIf we tried to use the component like this:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each model as |post|}}\n  {{blog-post}}\n{{/each}}\n\n\n\nThe following HTML would be rendered:\n\n  1\n2\n3\n4\n\n  \u003carticle class=\"blog-post\"\u003e\n  \u003ch1\u003e\u003c/h1\u003e\n  \u003cp\u003e\u003c/p\u003e\n\u003c/article\u003e\n\n\n\nIn order to make a property available to a component, you must pass it\nin like this:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each model as |post|}}\n  {{blog-post title=post.title body=post.body}}\n{{/each}}\n\n\n\nIt is important to note that these properties stay in sync (technically\nknown as being \"bound\"). That is, if the value of componentProperty\nchanges in the component, outerProperty will be updated to reflect that\nchange. The reverse is true as well.\nPositional Params\nIn addition to passing parameters in by name, you can pass them in by position.\nIn other words, you can invoke the above component example like this:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each model as |post|}}\n  {{blog-post post.title post.body}}\n{{/each}}\n\n\n\nTo set the component up to receive parameters this way, you need\nset the positionalParams attribute in your component class.\n\n  \n    \n      app/components/blog-post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  const BlogPostComponent = Ember.Component.extend({});\n\nBlogPostComponent.reopenClass({\n  positionalParams: ['title', 'body']\n});\n\nexport default BlogPostComponent;\n\n\n\nThen you can use the attributes in the component exactly as if they had been\npassed in like {{blog-post title=post.title body=post.body}}.\n\nNotice that the positionalParams property is added to the class as a\nstatic variable via reopenClass. Positional params are always declared on\nthe component class and cannot be changed while an application runs.\n\nAlternatively, you can accept an arbitrary number of parameters by\nsetting positionalParams to a string, e.g. positionalParams: 'params'. This\nwill allow you to access those params as an array like so:\n\n  \n    \n      app/components/blog-post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  const BlogPostComponent = Ember.Component.extend({\n  title: Ember.computed('params.[]', function(){\n    return this.get('params')[0];\n  }),\n  body: Ember.computed('params.[]', function(){\n    return this.get('params')[1];\n  })\n});\n\nBlogPostComponent.reopenClass({\n  positionalParams: 'params'\n});\n\nexport default BlogPostComponent;\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7b16c276de2db07ba873b02bcf234a39","fields":[{"name":"title","value":"The Component Lifecycle","type":"string"},{"name":"url","value":"/components/the-component-lifecycle/","type":"enum"},{"name":"body","value":"Part of what makes components so useful is that they let you take complete control of a section of the DOM.\nThis allows for direct DOM manipulation, listening and responding to browser events, and using 3rd party JavaScript libraries in your Ember app.\n\nAs components are rendered, re-rendered and finally removed, Ember provides lifecycle hooks that allow you to run code at specific times in a component's life.\n\nTo get the most use out of a component, it is important to understand these lifecycle methods.\nOrder of Lifecycle Hooks Called\nListed below are the component lifecycle hooks in order of execution according to render scenario.\nOn Initial Render\n\ninit\ndidReceiveAttrs\nwillRender\ndidInsertElement\ndidRender\n\nOn Re-Render\n\ndidUpdateAttrs\ndidReceiveAttrs\nwillUpdate\nwillRender\ndidUpdate\ndidRender\n\nOn Component Destroy\n\nwillDestroyElement\nwillClearRender\ndidDestroyElement\n\nLifecycle Hook Examples\nBelow are some samples of ways to use lifecycle hooks within your components.\nResetting Presentation State on Attribute Change with didUpdateAttrs\ndidUpdateAttrs runs when the attributes of a component have changed, but not when the component is re-rendered, via component.rerender,\ncomponent.set, or changes in models or services used by the template.\n\nA didUpdateAttrs is called prior to rerender, you can use this hook to execute code when specific attributes are changed.\nThis hook can be an effective alternative to an observer, as it will run prior to a re-render, but after an attribute has changed.\n\nAn example of this scenario in action is a profile editor component.  As you are editing one user, and the user attribute is changed,\nyou can use didUpdateAttrs to clear any error state that was built up from editing the previous user.\n\n/app/templates/components/profile-editor.hbs\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  \u003cul class=\"errors\"\u003e\n  {{#each errors as |error|}}\n    \u003cli\u003e{{error.message}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\u003cfieldset\u003e\n  {{input name=\"user.name\" value=name change=(action \"required\")}}\n  {{input name=\"user.department\" value=department change=(action \"required\")}}\n  {{input email=\"user.email\" value=email change=(action \"required\")}}\n\u003c/fieldset\u003e\n\n\n\n/app/components/profile-editor.js\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  init() {\n    this._super(...arguments);\n    this.errors = [];\n  },\n\n  didUpdateAttrs() {\n    this._super(...arguments);\n    this.set('errors', []);\n  },\n\n  actions: {\n    required(event) {\n      if (!event.target.value) {\n        this.get('errors').pushObject({ message: `${event.target.name} is required`});\n      }\n    }\n  }\n});\n\n\nFormatting Component Attributes with didReceiveAttrs\ndidReceiveAttrs runs after init, and it also runs on subsequent re-renders, which is useful for logic that is the same on all renders.\nIt does not run when the re-rendered has been initiated internally.\n\nSince the didReceiveAttrs hook is called every time a component's attributes are updated whether on render or re-render,\nyou can use the hook to effectively act as an observer, ensuring code is executed every time an attribute changes.\n\nFor example, if you have a component that renders based on a json configuration, but you want to provide your component with the option of taking the config as a string,\nyou can leverage didReceiveAttrs to ensure the incoming config is always parsed.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  didReceiveAttrs() {\n    this._super(...arguments);\n    const profile = this.get('data');\n    if (typeof profile === 'string') {\n      this.set('profile', JSON.parse(profile));\n    } else {\n      this.set('profile', profile);\n    }\n  }\n});\n\n\nIntegrating with Third-Party Libraries with didInsertElement\nSuppose you want to integrate your favorite date picker library into an Ember project.\nTypically, 3rd party JS/jQuery libraries require a DOM element to bind to.\nSo, where is the best place to initialize and attach the library?\n\nAfter a component successfully renders its backing HTML element into the DOM, it will trigger its didInsertElement() hook.\n\nEmber guarantees that, by the time didInsertElement() is called:\n\n\nThe component's element has been both created and inserted into the\nDOM.\nThe component's element is accessible via the component's\n$()\nmethod.\n\n\nA component's $() method allows you to access the component's DOM element by returning a JQuery element.\nFor example, you can set an attribute using jQuery's attr() method:\n\n  1\n2\n3\n4\n\n  didInsertElement() {\n  this._super(...arguments);\n  this.$().attr('contenteditable', true);\n}\n\n\n\n$() will, by default, return a jQuery object for the component's root element, but you can also target child elements within the component's template by passing a selector:\n\n  1\n2\n3\n4\n\n  didInsertElement() {\n  this._super(...arguments);\n  this.$('div p button').addClass('enabled');\n}\n\n\n\nLet's initialize our date picker by overriding the didInsertElement() method.\n\nDate picker libraries usually attach to an \u003cinput\u003e element, so we will use jQuery to find an appropriate input within our component's template.\n\n  1\n2\n3\n4\n\n  didInsertElement() {\n  this._super(...arguments);\n  this.$('input.date').myDatePickerLib();\n}\n\n\n\ndidInsertElement() is also a good place to\nattach event listeners. This is particularly useful for custom events or\nother browser events which do not have a built-in event\nhandler.\n\nFor example, perhaps you have some custom CSS animations trigger when the component\nis rendered and you want to handle some cleanup when it ends:\n\n  1\n2\n3\n4\n5\n6\n\n  didInsertElement() {\n  this._super(...arguments);\n  this.$().on('animationend', () =\u003e {\n    $(this).removeClass('.sliding-anim');\n  });\n}\n\n\n\nThere are a few things to note about the didInsertElement() hook:\n\n\nIt is only triggered once when the component element is first rendered.\nIn cases where you have components nested inside other components, the child component will always receive the didInsertElement() call before its parent does.\nSetting properties on the component in didInsertElement() triggers a re-render, and  for performance reasons,\nis not allowed.\nWhile didInsertElement() is technically an event that can be listened for using on(), it is encouraged to override the default method itself,\nparticularly when order of execution is important.\n\nMaking Updates to the Rendered DOM with didRender\nThe didRender hook is called during both render and re-render after the template has rendered and the DOM updated.\nYou can leverage this hook to perform post-processing on the DOM of a component after its been updated.\n\nIn this example, there is a list component that needs to scroll to a selected item when rendered.\nSince scrolling to a specific spot is based on positions within the DOM, we need to ensure that the list has been rendered before scrolling.\nWe can first render this list, and then set the scroll.\n\nThe component below takes a list of items and displays them on the screen.\nAdditionally, it takes an object representing which item is selected and will select and set the scroll top to that item.\n\n  1\n\n  {{selected-item-list items=items selectedItem=selection}}\n\n\n\nWhen rendered the component will iterate through the given list and apply a class to the one that is selected.\n\n/app/templates/components/selected-item-list.hbs\n\n  1\n2\n3\n\n  {{#each items as |item|}}\n  \u003cdiv class=\"list-item {{if item.isSelected 'selected-item'}}\"\u003e{{item.label}}\u003c/div\u003e\n{{/each}}\n\n\n\nThe scroll happens on didRender, where it will scroll the component's container to the element with the selected class name.\n\n/app/components/selected-item-list.js\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  className: 'item-list',\n\n  didReceiveAttrs() {\n    this._super(...arguments);\n    this.set('items', this.get('items').map((item) =\u003e {\n      if (item.id === this.get('selectedItem.id')) {\n        item.isSelected = true;\n      }\n      return item;\n    }));\n  },\n\n  didRender() {\n    this._super(...arguments);\n    this.$('.item-list').scrollTop(this.$('.selected-item').position.top);\n  }\n});\n\n\nDetaching and Tearing Down Component Elements with willDestroyElement\nWhen a component detects that it is time to remove itself from the DOM, Ember will trigger the willDestroyElement() method,\nallowing for any teardown logic to be performed.\n\nComponent teardown can be triggered by a number of different conditions.\nFor instance, the user may navigate to a different route, or a conditional Handlebars block surrounding your component may change:\n\n  1\n2\n3\n\n  {{#if falseBool}}\n  {{my-component}}\n{{/if}}\n\n\n\nLet's use this hook to cleanup our date picker and event listener from above:\n\n  1\n2\n3\n4\n5\n\n  willDestroyElement() {\n  this._super(...arguments);\n  this.$().off('animationend');\n  this.$('input.date').myDatepickerLib().destroy();\n}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"da48347254745eff0030f6c69abac8a0","fields":[{"name":"title","value":"Triggering Changes with Actions","type":"string"},{"name":"url","value":"/components/triggering-changes-with-actions/","type":"enum"},{"name":"body","value":"You can think of a component as a black box of UI functionality.\nSo far, you've learned how parent components can pass attributes in to a\nchild component, and how that component can use those attributes from\nboth JavaScript and its template.\n\nBut what about the opposite direction? How does data flow back out of\nthe component to the parent? In Ember, components use actions to\ncommunicate events and changes.\n\nLet's look at a simple example of how a component can use an action to\ncommunicate with its parent.\n\nImagine we're building an application where users can have accounts. We\nneed to build the UI for users to delete their account. Because we don't\nwant users to accidentally delete their accounts, we'll build a button\nthat requires the user to confirm in order to trigger some\naction.\n\nOnce we create this \"button with confirmation\"\ncomponent, we want to be able to reuse it all over our application.\nCreating the Component\nLet's call our component button-with-confirmation. We can create it by\ntyping:\n\n  1\n\n  ember generate component button-with-confirmation\n\n\n\nWe'll plan to use the component in a template something like this:\n\n  \n    \n      app/templates/components/user-profile.hbs\n    \n  \n\n  1\n\n  {{button-with-confirmation text=\"Click OK to delete your account.\"}}\n\n\n\nWe'll also want to use the component elsewhere, perhaps like this:\n\n  \n    \n      app/templates/components/send-message.hbs\n    \n  \n\n  1\n\n  {{button-with-confirmation text=\"Click OK to send your message.\"}}\n\n\nDesigning the Action\nWhen implementing an action on a component, you need to break it down into two steps:\n\n\nIn the parent component, decide how you want to react to the action.\nHere, we want to have the action delete the user's account in one place, and\nsend a message in another place.\nIn the component, determine when something has happened, and when to tell the\noutside world. Here, we want to trigger the outside action (deleting the\naccount or sending the message) after the user clicks the button and then\nconfirms.\n\n\nLet's take it step by step.\nImplementing the Action\nIn the parent component, let's first define what we want to happen when the\nuser clicks the button and then confirms. In this case, we'll find the user's\naccount and delete it.\n\nIn Ember, each component can\nhave a property called actions, where you put functions that can be\ninvoked by the user interacting with the component\nitself, or by child components.\n\nLet's look at the parent component's JavaScript file. In this example,\nimagine we have a parent component called user-profile that shows the\nuser's profile to them.\n\nWe'll implement an action on the parent component called\nuserDidDeleteAccount() that, when called, gets a hypothetical login\nservice and calls the service's\ndeleteUser() method.\n\n  \n    \n      app/components/user-profile.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Component.extend({\n  login: Ember.inject.service(),\n\n  actions: {\n    userDidDeleteAccount() {\n      this.get('login').deleteUser();\n    }\n  }\n});\n\n\n\nNow we've implemented our action, but we have not told Ember when we\nwant this action to be triggered, which is the next step.\nDesigning the Child Component\nNext, let's implement the logic to confirm that the user wants to take\nthe action from the component:\n\n  \n    \n      app/components/button-with-confirmation.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  export default Ember.Component.extend({\n\n  actions: {\n    launchConfirmDialog() {\n      this.set('confirmShown', true);\n    },\n\n    submitConfirm() {\n      // trigger action on parent component\n      this.set('confirmShown', false);\n    },\n\n    cancelConfirm() {\n      this.set('confirmShown', false);\n    }\n  }\n});\n\n\n\nThe component template will have a button and a div that shows the confirmation dialog\nbased on the value of confirmShown.\n\n  \n    \n      app/templates/components/button-with-confirmation.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003cbutton {{action \"launchConfirmDialog\"}}\u003e{{text}}\u003c/button\u003e\n{{#if confirmShown}}\n  \u003cdiv class=\"confirm-dialog\"\u003e\n    \u003cbutton class=\"confirm-submit\" {{action \"submitConfirm\"}}\u003eOK\u003c/button\u003e\n    \u003cbutton class=\"confirm-cancel\" {{action \"cancelConfirm\"}}\u003eCancel\u003c/button\u003e\n  \u003c/div\u003e\n{{/if}}\n\n\nPassing the Action to the Component\nNow we need to make it so that the onConfirm() event in the\nbutton-with-confirmation() component triggers the\nuserDidDeleteAccount() action in the user-profile component.\nOne important thing to know about actions is that they're functions\nyou can call, like any other method on your component.\nSo they can be passed from one component to another like this:\n\n  \n    \n      app/components/user-profile.hbs\n    \n  \n\n  1\n\n  {{button-with-confirmation text=\"Click here to delete your account.\" onConfirm=(action \"userDidDeleteAccount\")}}\n\n\n\nThis snippet says \"take the userDidDeleteAccount action from the\nparent and make it available on the child component as\nonConfirm.\"\n\nWe can do a similar thing for our send-message component:\n\n  \n    \n      app/templates/components/send-message.hbs\n    \n  \n\n  1\n\n  {{button-with-confirmation text=\"Click to send your message.\" onConfirm=(action \"sendMessage\")}}\n\n\n\nNow, we can use onConfirm in the child component to invoke the action on the\nparent:\n\n  \n    \n      app/components/button-with-confirmation.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  export default Ember.Component.extend({\n\n  actions: {\n    launchConfirmDialog() {\n      this.set('confirmShown', true);\n    },\n\n    submitConfirm() {\n      //call the onConfirm property to invoke the passed in action\n      this.get('onConfirm')();\n    },\n\n    cancelConfirm() {\n      this.set('confirmShown', false);\n    }\n  }\n});\n\n\n\nthis.get('onConfirm') will return the function passed from the parent as the\nvalue of onConfirm, and the following () will invoke the function.\n\nLike normal attributes, actions can be a property on the component; the\nonly difference is that the property is set to a function that knows how\nto trigger behavior.\n\nThat makes it easy to remember how to add an action to a component. It's\nlike passing an attribute, but you use the action helper to pass\na function instead.\n\nActions in components allow you to\ndecouple an event happening from how it's handled, leading to modular,\nmore reusable components.\nHandling Action Completion\nOften actions perform asynchronous tasks, such as making an ajax request to a server.\nSince actions are functions that can be passed in by a parent component, they are able to return values when called.\nThe most common scenario is for an action to return a promise so that the component can handle the action's completion.\n\nIn our user button-with-confirmation component we want to leave the confirmation modal open until we know that the\noperation has completed successfully.\nThis is accomplished by expecting a promise to be returned from onConfirm.\nUpon resolution of the promise, we set a property used to indicate the visibility of the confirmation modal.\n\n  \n    \n      app/components/button-with-confirmation.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  export default Ember.Component.extend({\n  actions: {\n    launchConfirmDialog() {\n      this.set('confirmShown', true);\n    },\n\n    submitConfirm() {\n      //call onConfirm with the value of the input field as an argument\n      const promise = this.get('onConfirm')();\n      promise.then(() =\u003e {\n        this.set('confirmShown', false);\n      });\n    },\n\n    cancelConfirm() {\n      this.set('confirmShown', false);\n    }\n  }\n});\n\n\nPassing Arguments\nSometimes the parent component invoking an action has some context needed for the action that the child component\ndoesn't.\nFor these cases, actions passed to a component via the action helper may be invoked with arguments.\nFor example, we'll update the send-message action to take a message type in addition to the message itself.\nSince the button-with-confirmation component doesn't know or care about what type of message its collecting, we want\nto provide a message type from send-message when we define the action.\n\n  \n    \n      app/templates/components/send-message.hbs\n    \n  \n\n  1\n\n  {{button-with-confirmation text=\"Click to send your message.\" onConfirm=(action \"sendMessage\" \"info\")}}\n\n\n\nIn this case, the code in button-with-confirmation does not change.\nIt will still invoke onConfirm with no arguments.\nThe action helper will add the arguments provided in the template to the call.\n\nAction arguments curry, meaning that you can provide partial arguments to the action helper and provide the rest of the\narguments when you call the function within the component javascript file.\nFor example, our button-with-confirmation component will now yield the content\nof the confirmation dialog to collect extra information to be sent along with the onConfirm action:\n\n  \n    \n      app/templates/components/button-with-confirmation.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  \u003cbutton {{action \"launchConfirmDialog\"}}\u003e{{text}}\u003c/button\u003e\n{{#if confirmShown}}\n  \u003cdiv class=\"confirm-dialog\"\u003e\n    {{yield confirmValue}}\n    \u003cbutton class=\"confirm-submit\" {{action \"submitConfirm\"}}\u003eOK\u003c/button\u003e\n    \u003cbutton class=\"confirm-cancel\" {{action \"cancelConfirm\"}}\u003eCancel\u003c/button\u003e\n  \u003c/div\u003e\n{{/if}}\n\n\n\nThe send-message component provides an input as block content to the button-with-confirmation component, setting\nconfirmValue.\n\n  \n    \n      app/templates/components/send-message.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  {{#button-with-confirmation\n    text=\"Click to send your message.\"\n    onConfirm=(action \"sendMessage\" \"info\")\n    as |confirmValue|}}\n  {{input value=confirmValue}}\n{{/button-with-confirmation}}\n\n\n\nNow when the submitConfirm action is invoked, we call it with the value provided by our yielded input.\n\n  \n    \n      app/components/button-with-confirmation.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  export default Ember.Component.extend({\n  actions: {\n    launchConfirmDialog() {\n      this.set(\"confirmShown\", true);\n    },\n\n    submitConfirm() {\n      //call onConfirm with the value of the input field as an argument\n      const promise = this.get('onConfirm')(this.get('confirmValue'));\n      promise.then(() =\u003e {\n        this.set('confirmShown', false);\n      });\n    },\n\n    cancelConfirm() {\n      this.set('confirmShown', false);\n    }\n  }\n});\n\n\n\nThis action will call our bound sendMessage function with both the message type we provided earlier, and the template\nand the message value provided in the component JavaScript.\n\n  \n    \n      app/components/send-message.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  actions: {\n    sendMessage(messageType, messageText) {\n      //send message here and return a promise\n    }\n  }\n});\n\n\nInvoking Actions Directly on Component Collaborators\nActions can be invoked on objects other than the component directly from the template.  For example, in our\nsend-message component we might include a service that processes the sendMessage logic.\n\n  \n    \n      app/components/send-message.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  messaging: Ember.inject.service(),\n\n  // component implementation\n});\n\n\n\nWe can tell the action to invoke the sendMessage action directly on the messaging service with the target attribute.\n\n  \n    \n      app/templates/components/send-message.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  {{#button-with-confirmation\n    text=\"Click to send your message.\"\n    onConfirm=(action \"sendMessage\" \"info\" target=messaging)\n    as |confirmValue| }}\n  {{input value=confirmValue}}\n{{/button-with-confirmation}}\n\n\n\nBy supplying the target attribute, the action helper will look to invoke the sendMessage action directly on the messaging\nservice, saving us from writing code on the component that just passes the action along to the service.\n\n  \n    \n      app/services/messaging.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Service.extend({\n  actions: {\n    sendMessage(messageType, text) {\n      //handle message send and return a promise\n    }\n  }\n});\n\n\nDestructuring Objects Passed as Action Arguments\nA component will often not know what information a parent needs to process an action, and will just pass all the\ninformation it has.\nFor example, our user-profile component is going to notify its parent, system-preferences-editor, that a\nuser's account was deleted, and passes along with it the full user profile object.\n\n  \n    \n      app/components/user-profile.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Component.extend({\n  login: Ember.inject.service(),\n\n  actions: {\n    userDidDeleteAccount() {\n      this.get('login').deleteUser();\n      this.get('didDelete')(this.get('login.currentUserObj'));\n    }\n  }\n});\n\n\n\nAll our system-preferences-editor component really needs to process a user deletion is an account ID.\nFor this case, the action helper provides the value attribute to allow a parent component to dig into the passed\nobject to pull out only what it needs.\n\n  \n    \n      app/templates/components/system-preferences-editor.hbs\n    \n  \n\n  1\n\n  {{user-profile didDelete=(action \"userDeleted\" value=\"account.id\")}}\n\n\n\nNow when the system-preferences-editor handles the delete action, it receives only the user's account id string.\n\n  \n    \n      app/components/system-preferences-editor.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  actions: {\n    userDeleted(idStr) {\n      //respond to deletion\n    }\n  }\n});\n\n\nCalling Actions Up Multiple Component Layers\nWhen your components go multiple template layers deep, its common to need to handle an action several layers up the tree.\nUsing the action helper, it is possible to make actions defined in parent components available at the bottom layers of\nyour component tree without adding JavaScript code to the components in between.\n\nFor example, we want to take account deletion out of the user-profile component and handle deletion in its parent.\nIn our template in user-profile.hbs, we can change our action to call deleteCurrentUser,\nwhich will be defined on system-preferences-editor.\n\n  \n    \n      app/templates/components/user-profile.hbs\n    \n  \n\n  1\n2\n\n  {{button-with-confirmation onConfirm=(action deleteCurrentUser)\n  text=\"Click OK to delete your account.\"}}\n\n\n\nNote that deleteCurrentUser is not in quotes as was the case previously\nwhen the action was local to user-profile.  When you pass an actual function reference (without quotes) to the action\nhelper, it will call the function from the component's local context.\n\nAlternately, when you pass a string to the action helper, Ember will attempt to call that function from the\ncomponent's local actions object.\n\nHere our system-preferences-editor template passes its deleteUser action into the user-profile\ncomponent's local deleteCurrentUser property.\n\n  \n    \n      app/templates/components/system-preferences-editor.hbs\n    \n  \n\n  1\n\n  {{user-profile deleteCurrentUser=(action 'deleteUser' login.currentUser.id)}}\n\n\n\nNow when you confirm deletion, the action goes straight to the system-preferences-editor to handle.\n\n  \n    \n      app/components/system-preferences-editor.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  login: Ember.inject.service(),\n  actions: {\n    deleteUser(idStr) {\n      return this.get('login').deleteUserAccount(idStr);\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e9763ebaa18b58c8fafed5531d19eb14","fields":[{"name":"title","value":"Wrapping Content in a Component","type":"string"},{"name":"url","value":"/components/wrapping-content-in-a-component/","type":"enum"},{"name":"body","value":"Sometimes, you may want to define a component that wraps content\nprovided by other templates.\n\nFor example, imagine we are building a blog-post component that we can\nuse in our application to display a blog post:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv class=\"body\"\u003e{{body}}\u003c/div\u003e\n\n\n\nNow, we can use the {{blog-post}} component and pass it properties\nin another template:\n\n  1\n\n  {{blog-post title=title body=body}}\n\n\n\n(See Passing Properties to a\nComponent for\nmore.)\n\nIn this case, the content we wanted to display came from the model. But\nwhat if we want the developer using our component to be able to provide custom\nHTML content?\n\nIn addition to the simple form you've learned so far, components also\nsupport being used in block form. In block form, components can be\npassed a Handlebars template that is rendered inside the component's\ntemplate wherever the {{yield}} expression appears.\n\nTo use the block form, add a # character to the\nbeginning of the component name, then make sure to add a closing tag.\n(See the Handlebars documentation on block expressions for more.)\n\nIn that case, we can use the {{blog-post}} component in block form\nand tell Ember where the block content should be rendered using the\n{{yield}} helper. To update the example above, we'll first change the component's\ntemplate:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv class=\"body\"\u003e{{yield}}\u003c/div\u003e\n\n\n\nYou can see that we've replaced {{body}} with {{yield}}. This tells\nEmber that this content will be provided when the component is used.\n\nNext, we'll update the template using the component to use the block\nform:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  {{#blog-post title=title}}\n  \u003cp class=\"author\"\u003eby {{author}}\u003c/p\u003e\n  {{body}}\n{{/blog-post}}\n\n\n\nIt's important to note that the template scope inside the component\nblock is the same as outside. If a property is available in the template\noutside the component, it is also available inside the component block.\nSharing Component Data with its Wrapped Content\nThere is also a way to share data within your blog post component with the content it is wrapping.\nIn our blog post component we want provide a way for the user to configure what type of style they want to write their post in.\nWe will give them the option to specify either markdown or html.\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  {{#blog-post editingStyle=\"markdown\"}}\n  \u003cp class=\"author\"\u003eby {{author}}\u003c/p\u003e\n  {{body}}\n{{/blog-post}}\n\n\n\nSupporting different editing styles will require different body components to provide special validation and highlighting.\nTo load a different body component based on editing style, you can yield the component using the component helper and hash helper.\n\n  \n    \n      app/templates/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch2\u003e{{title}}\u003c/h2\u003e\n\u003cdiv class=\"body\"\u003e{{yield (hash body=(component editStyle))}}\u003c/div\u003e\n\n\n\nOnce yielded the data can be accessed within wrapped content by referencing the as variable.\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  {{#blog-post editStyle=\"markdown\" as |post|}}\n  \u003cp class=\"author\"\u003eby {{author}}\u003c/p\u003e\n  {{post.body}}\n{{/blog-post}}\n\n\n\nFinally we want to share the model of the data a user fills out for the post within our blog-post and body components.\nTo share the postData object with the new body component, you can add arguments to the component helper.\n\n  \n    \n      app/templates/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch2\u003e{{title}}\u003c/h2\u003e\n\u003cdiv class=\"body\"\u003e{{yield (hash body=(component editStyle postData=postData))}}\u003c/div\u003e\n\n\n\nSince the component isn't instantiated until the component block content is rendered, we can add additional arguments within the block.\nIn this case we'll add a text style option which will dictate the style of body text we want in our post.\nWhen {{post.body}} is instantiated, it will have both the edit style and the postData given by its wrapping component.\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  {{#blog-post editStyle=\"markdown\" as |post|}}\n  \u003cp class=\"author\"\u003eby {{author}}\u003c/p\u003e\n  {{post.body editStyle=\"compact\"}}\n{{/blog-post}}\n\n\n\nSharing components this way is commonly referred to as \"Contextual Components\",\nbecause the component is shared only with the context of the parent component's block area.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"db767f9b7794259fc51adf628e889728","fields":[{"name":"title","value":"Configuring Ember CLI","type":"string"},{"name":"url","value":"/configuring-ember/configuring-ember-cli/","type":"enum"},{"name":"body","value":"In addition to configuring your app itself, you can also configure Ember CLI.\nThese configurations can be made by adding them to the .ember-cli file in your application's root. Many can also be made by passing them as arguments to the command line program.\n\nFor example, a common desire is to change the port that Ember CLI serves the app from. It's possible to pass the port number from the command line with ember server --port 8080. To make this configuration permanent, edit your .ember-cli file like so:\n\n  1\n2\n3\n\n  {\n  \"port\": 8080\n}\n\n\n\nFor a full list of command line options, run ember help.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"5cb0b70fe7060908328e2e6a94be38dd","fields":[{"name":"title","value":"Configuring Your App","type":"string"},{"name":"url","value":"/configuring-ember/configuring-your-app/","type":"enum"},{"name":"body","value":"Ember CLI ships with support for managing your application's environment. Ember CLI will setup a default environment config file at config/environment. Here, you can define an ENV object for each environment, which are currently limited to three: development, test, and production.\n\nThe ENV object contains three important keys:\n\n\nEmberENV can be used to define Ember feature flags (see the Feature Flags guide).\nAPP can be used to pass flags/options to your application instance.\nenvironment contains the name of the current environment (development,production or test).\n\n\nYou can access these environment variables in your application code by importing from your-application-name/config/environment.\n\nFor example:\n\n  1\n2\n3\n4\n5\n\n  import ENV from 'your-application-name/config/environment';\n\nif (ENV.environment === 'development') {\n  // ...\n}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0ab82a1cf8a75d333dc8fe48ccdda4be","fields":[{"name":"title","value":"Debugging","type":"string"},{"name":"url","value":"/configuring-ember/debugging/","type":"enum"},{"name":"body","value":"Ember provides several configuration options that can help you debug problems\nwith your application.\nRoutingLog router transitions\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Application.extend({\n  // Basic logging, e.g. \"Transitioned into 'post'\"\n  LOG_TRANSITIONS: true,\n\n  // Extremely detailed logging, highlighting every internal\n  // step made while transitioning into a route, including\n  // `beforeModel`, `model`, and `afterModel` hooks, and\n  // information about redirects and aborted transitions\n  LOG_TRANSITIONS_INTERNAL: true\n});\n\n\nViews / TemplatesLog view lookups\n  \n    \n      config/environment.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_VIEW_LOOKUPS = true;\n\n\nView all registered templates\n  1\n\n  Ember.keys(Ember.TEMPLATES)\n\n\nControllersLog generated controller\n  \n    \n      config/environment.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_ACTIVE_GENERATION = true;\n\n\nObservers / BindingSee all observers for an object, key\n  1\n\n  Ember.observersFor(comments, keyName);\n\n\nLog object bindings\n  \n    \n      config/environments.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_BINDINGS = true\n\n\nMiscellaneousTurn on resolver resolution logging\nThis option logs all the lookups that are done to the console. Custom objects\nyou've created yourself have a tick, and Ember generated ones don't.\n\nIt's useful for understanding which objects Ember is finding when it does a lookup\nand which it is generating automatically for you.\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Application.extend({\n  LOG_RESOLVER: true\n});\n\n\nDealing with deprecations\n  1\n2\n\n  Ember.ENV.RAISE_ON_DEPRECATION = true\nEmber.ENV.LOG_STACKTRACE_ON_DEPRECATION = true\n\n\nImplement an Ember.onerror hook to log all errors in production\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Ember.onerror = function(error) {\n  Ember.$.ajax('/error-notification', {\n    type: 'POST',\n    data: {\n      stack: error.stack,\n      otherInformation: 'exception message'\n    }\n  });\n}\n\n\nImport the console\nIf you are using imports with Ember, be sure to import the console:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Ember = {\n  imports: {\n    Handlebars: Handlebars,\n    jQuery: $,\n    console: window.console\n  }\n};\n\n\nErrors within an RSVP.Promise\nThere are times when dealing with promises that it seems like any errors\nare being 'swallowed', and not properly raised. This makes it extremely\ndifficult to track down where a given issue is coming from. Thankfully,\nRSVP has a solution for this problem built in.\n\nYou can provide an onerror function that will be called with the error\ndetails if any errors occur within your promise. This function can be anything,\nbut a common practice is to call console.assert to dump the error to the\nconsole.\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  Ember.RSVP.on('error', function(error) {\n  Ember.Logger.assert(false, error);\n});\n\n\nErrors within Ember.run.later (Backburner.js)\nBackburner has support for stitching the stacktraces together so that you can\ntrack down where an erroring Ember.run.later is being initiated from. Unfortunately,\nthis is quite slow and is not appropriate for production or even normal development.\n\nTo enable this mode you can set:\n\n  1\n\n  Ember.run.backburner.DEBUG = true;\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"62986c9e6cbee2077f1bd848372a19dc","fields":[{"name":"title","value":"Disabling Prototype Extensions","type":"string"},{"name":"url","value":"/configuring-ember/disabling-prototype-extensions/","type":"enum"},{"name":"body","value":"By default, Ember.js will extend the prototypes of native JavaScript\nobjects in the following ways:\n\n\nArray is extended to implement the Ember.Enumerable,\nEmber.MutableEnumerable, Ember.MutableArray and Ember.Array\ninterfaces. This polyfills ECMAScript 5 array methods in browsers that\ndo not implement them, adds convenience methods and properties to\nbuilt-in arrays, and makes array mutations observable.\nString is extended to add convenience methods, such as\ncamelize() and w(). You can find a list of these methods with the\nEmber.String documentation.\nFunction is extended with methods to annotate functions as\ncomputed properties, via the property() method, and as observers,\nvia the observes() or observesBefore() methods. Use of these methods\nis now discouraged and not covered in recent versions of the Guides.\n\n\nThis is the extent to which Ember.js enhances native prototypes. We have\ncarefully weighed the tradeoffs involved with changing these prototypes,\nand recommend that most Ember.js developers use them. These extensions\nsignificantly reduce the amount of boilerplate code that must be typed.\n\nHowever, we understand that there are cases where your Ember.js\napplication may be embedded in an environment beyond your control. The\nmost common scenarios are when authoring third-party JavaScript that is\nembedded directly in other pages, or when transitioning an application\npiecemeal to a more modern Ember.js architecture.\n\nIn those cases, where you can't or don't want to modify native\nprototypes, Ember.js allows you to completely disable the extensions\ndescribed above.\n\nTo do so, simply set the EmberENV.EXTEND_PROTOTYPES flag to false:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  ENV = {\n  EmberENV: {\n    EXTEND_PROTOTYPES: false\n  }\n}\n\n\n\nYou can configure which classes to include prototype extensions\nfor in your application's configuration like so:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  ENV = {\n  EmberENV: {\n    EXTEND_PROTOTYPES: {\n      String: false,\n      Array: true\n    }\n  }\n}\n\n\nLife Without Prototype Extension\nIn order for your application to behave correctly, you will need to\nmanually extend or create the objects that the native objects were\ncreating before.\nArrays\nNative arrays will no longer implement the functionality needed to\nobserve them. If you disable prototype extension and attempt to use\nnative arrays with things like a template's {{#each}} helper, Ember.js\nwill have no way to detect changes to the array and the template will\nnot update as the underlying array changes.\n\nAdditionally, if you try to set the model of an\nEmber.ArrayController to a plain native array, it will raise an\nexception since it no longer implements the Ember.Array interface.\n\nYou can manually coerce a native array into an array that implements the\nrequired interfaces using the convenience method Ember.A:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var islands = ['Oahu', 'Kauai'];\nislands.contains('Oahu');\n//=\u003e TypeError: Object Oahu,Kauai has no method 'contains'\n\n// Convert `islands` to an array that implements the\n// Ember enumerable and array interfaces\nEmber.A(islands);\n\nislands.contains('Oahu');\n//=\u003e true\n\n\nStrings\nStrings will no longer have the convenience methods described in the\nEmber.String API reference.. Instead,\nyou can use the similarly-named methods of the Ember.String object and\npass the string to use as the first parameter:\n\n  1\n2\n3\n4\n5\n\n  \"my_cool_class\".camelize();\n//=\u003e TypeError: Object my_cool_class has no method 'camelize'\n\nEmber.String.camelize(\"my_cool_class\");\n//=\u003e \"myCoolClass\"\n\n\nFunctions\nThe Object Model section of the Guides describes\nhow to write computed properties, observers, and bindings without\nprototype extensions. Below you can learn about how to convert existing\ncode to the format now encouraged.\n\nTo annotate computed properties, use the Ember.computed() method to\nwrap the function:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // This won't work:\nfullName: function() {\n  return `${this.get('firstName')} ${this.get('lastName')}`;\n}.property('firstName', 'lastName')\n\n\n// Instead, do this:\nfullName: Ember.computed('firstName', 'lastName', function() {\n  return `${this.get('firstName')} ${this.get('lastName')}`;\n})\n\n\n\nObservers are annotated using Ember.observer():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // This won't work:\nfullNameDidChange: function() {\n  console.log('Full name changed');\n}.observes('fullName')\n\n\n// Instead, do this:\nfullNameDidChange: Ember.observer('fullName', function() {\n  console.log('Full name changed');\n})\n\n\n\nEvented functions are annotated using Ember.on():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  // This won't work:\ndoStuffWhenInserted: function() {\n  /* awesome sauce */\n}.on('didInsertElement');\n\n// Instead, do this:\ndoStuffWhenInserted: Ember.on('didInsertElement', function() {\n  /* awesome sauce */\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"479923146262192b72f2b6cd4e92d83b","fields":[{"name":"title","value":"Embedding Applications","type":"string"},{"name":"url","value":"/configuring-ember/embedding-applications/","type":"enum"},{"name":"body","value":"In most cases, your application's entire UI will be created by templates\nthat are managed by the router.\n\nBut what if you have an Ember.js app that you need to embed into an\nexisting page, or run alongside other JavaScript frameworks, or serve from the\nsame domain as another app?\nChanging the Root Element\nBy default, your application will render the application template\nand attach it to the document's body element.\n\nYou can tell the application to append the application template to a\ndifferent element by specifying its rootElement property:\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Application.extend({\n  rootElement: '#app'\n});\n\n\n\nThis property can be specified as either an element or a\njQuery-compatible selector\nstring.\nDisabling URL Management\nYou can prevent Ember from making changes to the URL by changing the\nrouter's location to\nnone:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n\n  var ENV = {\n  locationType: 'none'\n};\n\n\nSpecifying a Root URL\nIf your Ember application is one of multiple web applications served from the same domain, it may be necessary to indicate to the router what the root URL for your Ember application is. By default, Ember will assume it is served from the root of your domain.\n\nFor example, if you wanted to serve your blogging application from http://emberjs.com/blog/, it would be necessary to specify a root URL of /blog/.\n\nThis can be achieved by setting the rootURL on the router:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Ember.Router.extend({\n  rootURL: '/blog/'\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"32ec1a30c836c88e234758571f01a21e","fields":[{"name":"title","value":"Feature Flags","type":"string"},{"name":"url","value":"/configuring-ember/feature-flags/","type":"enum"},{"name":"body","value":"New features are added to Ember.js within conditional statements.\n\nCode behind these flags can be conditionally enabled\n(or completely removed) based on your project's configuration. This\nallows newly developed features to be selectively released when the\nEmber.js community considers them ready for production use.\nFeature Life-Cycle\nA newly-flagged feature is only available in canary builds and can be enabled\nat runtime through your project's configuration file.\n\nAt the start of a beta cycle the Ember core team evaluates each new feature.\nFeatures deemed stable are made available in the next beta and enabled by default.\n\nBeta features that receive negative feedback from the community are disabled in the next beta point\nrelease, and are not included in the next stable release. They may still be included\nin the next beta cycle if the issues/concerns are resolved.\n\nOnce the beta cycle has completed, the next stable release will include any features that\nwere enabled during the beta cycle. At this point the feature flags will be removed from\nthe canary and future beta branches, and the feature becomes part of the framework.\nFlagging Details\nThe flag status in the generated build is controlled by the features.json\nfile in the root of the Ember.js project. This file lists all new features and their current status.\n\nA feature can have one of a three flags:\n\n\ntrue - The feature is present and enabled: the code behind the flag is always enabled in\nthe generated build.\nnull - The feature is present but disabled in the build output. It must be enabled at\nruntime.\nfalse - The feature is entirely disabled: the code behind the flag is not present in\nthe generated build.\n\n\nThe process of removing the feature flags from the resulting build output is\nhandled by defeatureify.\nFeature Listing (FEATURES.md)\nWhen a developer adds a new feature to the canary channel (i.e. the master branch on github), they\nalso add an entry to FEATURES.md\nexplaining what the feature does, and linking to their originating pull request.\nThis list is kept current, and reflects what is available in each channel\n(release, beta, and canary).\nEnabling At Runtime\nWhen using the Ember.js canary or beta builds you can enable a \"present but disabled\"\nfeature by setting its flag value to true before your application boots:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  var ENV = {\n  EmberENV: {\n    FEATURES: {\n      'link-to': true\n    }\n  }\n};\n\n\n\nFor the truly ambitious developer, setting ENV.EmberENV.ENABLE_ALL_FEATURES to true will enable all\nexperimental features.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6cffbdcb397691f05d92da8c25cc8745","fields":[{"name":"title","value":"Handling Deprecations","type":"string"},{"name":"url","value":"/configuring-ember/handling-deprecations/","type":"enum"},{"name":"body","value":"A valuable attribute of the Ember framework is its use of Semantic Versioning to aid projects in keeping up with\nchanges to the framework.  Before any functionality or API is removed it first goes through a deprecation period where the functionality is\nstill supported, but usage of it generates a warning logged to the browser console.  These warnings can pile up between major releases to a point where the amount of\ndeprecation warnings that scroll through the console becomes overwhelming.\n\n\n\nFortunately, Ember provides a way for projects to deal with deprecations in an organized and efficient manner.\nFiltering Deprecations\nWhen your project has a lot of deprecations, you can start by filtering out deprecations that do not have to be addressed right away.  You\ncan use the deprecation handlers API to check for what\nrelease a deprecated feature will be removed.  An example handler is shown below that filters out all deprecations that are not going away\nin release 2.0.0.\n\n  \n    \n      app/initializers/main.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  if (Ember.Debug \u0026\u0026 typeof Ember.Debug.registerDeprecationHandler === 'function') {\n    Ember.Debug.registerDeprecationHandler((message, options, next) =\u003e {\n        if (options \u0026\u0026 options.until \u0026\u0026 options.until !== '2.0.0') {\n            return;\n        }\n        next(message, options);\n    });\n}\n\n\n\nThe deprecation handler API was released in Ember 2.1.  If you would like to leverage this API in a prior release of Ember you can install\nthe ember-debug-handlers-polyfill addon into your project.\nDeprecation Workflow\nOnce you've removed deprecations that you may not need to immediately address, you may still be left with many deprecations.  Also, your remaining\ndeprecations may only occur in very specific scenarios that are not obvious.  How then should you go about finding and fixing these?  This\nis where the ember-cli-deprecation-workflow addon can be extremely helpful.\n\nOnce installed, the addon works in 3 steps:\n1. Gather deprecations into one source\nThe ember-cli-deprecation-workflow addon provides a command that will collect deprecations from your console and generate JavaScript code listing\nits findings.\n\nTo collect deprecations, first run your in-browser test suite by starting your development server and navigating to http://localhost:4200/tests.  If your test suite isn't fully covering your app's functionality, you may also\nmanually exercise functionality within your app where needed.  Once you've exercised the app to your satisfaction, run the following command within\nyour browser console: deprecationWorkflow.flushDeprecations().  This will print to the console JavaScript code, which you should then copy to a\nnew file in your project called /config/deprecation-workflow.js\n\n\n\nHere's an example of a deprecation-workflow file after generated from the console:\n\n  \n    \n      /config/deprecation-workflow.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  window.deprecationWorkflow = window.deprecationWorkflow || {};\nwindow.deprecationWorkflow.config = {\n  workflow: [\n    { handler: \"silence\", matchMessage: \"Ember.Handlebars.registerHelper is deprecated, please refactor to Ember.Helper.helper.\" },\n    { handler: \"silence\", matchMessage: \"`lookup` was called on a Registry. The `initializer` API no longer receives a container, and you should use an `instanceInitializer` to look up objects from the container.\" },\n    { handler: \"silence\", matchMessage: \"Using `Ember.HTMLBars.makeBoundHelper` is deprecated. Please refactor to using `Ember.Helper` or `Ember.Helper.helper`.\" },\n    { handler: \"silence\", matchMessage: \"Accessing 'template' in \u003cweb-directory@component:x-select::ember1381\u003e is deprecated. To determine if a block was specified to \u003cweb-directory@component:x-select::ember1381\u003e please use '{{#if hasBlock}}' in the components layout.\" },\n    { handler: \"silence\", matchMessage: \"Accessing 'template' in \u003cweb-directory@component:x-select::ember1402\u003e is deprecated. To determine if a block was specified to \u003cweb-directory@component:x-select::ember1402\u003e please use '{{#if hasBlock}}' in the components layout.\" },\n    { handler: \"silence\", matchMessage: \"Accessing 'template' in \u003cweb-directory@component:x-select::ember1407\u003e is deprecated. To determine if a block was specified to \u003cweb-directory@component:x-select::ember1407\u003e please use '{{#if hasBlock}}' in the components layout.\" }\n  ]\n};\n\n\n\nYou might notice that you have a lot of duplicated messages in your workflow file, like the 3 messages in the above example that start with\nAccessing 'template' in....  This is because some of the deprecation messages provide context to the specific deprecation, making them\ndifferent than the same deprecation in other parts of the app.  If you want to consolidate the\nduplication, you can use a simple regular expression with a wildcard (.*) for the part of the message that varies per instance.\n\nBelow is the same deprecation-workflow file as above, now with a regular expression on line 7 to remove some redundant messages. Note that the double quotes around matchMessage have also been replaced with forward slashes.\n\n  \n    \n      /config/deprecation-workflow.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  window.deprecationWorkflow = window.deprecationWorkflow || {};\nwindow.deprecationWorkflow.config = {\n  workflow: [\n    { handler: \"silence\", matchMessage: \"Ember.Handlebars.registerHelper is deprecated, please refactor to Ember.Helper.helper.\" },\n    { handler: \"silence\", matchMessage: \"`lookup` was called on a Registry. The `initializer` API no longer receives a container, and you should use an `instanceInitializer` to look up objects from the container.\" },\n    { handler: \"silence\", matchMessage: \"Using `Ember.HTMLBars.makeBoundHelper` is deprecated. Please refactor to using `Ember.Helper` or `Ember.Helper.helper`.\" },\n    { handler: \"silence\", matchMessage: /Accessing 'template' in .* is deprecated. To determine if a block was specified to .* please use '{{#if hasBlock}}' in the components layout./ }\n  ]\n};\n\n\n\nRerun your test suite as you make updates to your workflow file and you should validate that your deprecations are gone. Once that is completed,\nyou can proceed with enhancing your application without the sea of deprecation warnings clouding your log.\n2. \"Turn on\" a deprecation\nOnce you have built your deprecation-workflow.js file and your deprecations are silenced, you can begin to work on deprecations one by one\nat your own leisure.  To find deprecations, you can change the handler value of that message to either throw or log.  Throw will\nthrow an actual exception when the deprecation is encountered, so that tests that use the deprecated feature will fail.  Choosing to log will\nsimply log a warning to the console as before.  These settings give you some flexibility on how you want to go about fixing the\ndeprecations.\n\nThe code below is the deprecation-workflow file with the first deprecation set to throw an exception on occurrence.  The image demonstrates what\nthat deprecation looks like when you run your tests.\n\n  \n    \n      /config/deprecation-workflow.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  window.deprecationWorkflow = window.deprecationWorkflow || {};\nwindow.deprecationWorkflow.config = {\n  workflow: [\n    { handler: \"throw\", matchMessage: \"Ember.Handlebars.registerHelper is deprecated, please refactor to Ember.Helper.helper.\" },\n    { handler: \"silence\", matchMessage: \"`lookup` was called on a Registry. The `initializer` API no longer receives a container, and you should use an `instanceInitializer` to look up objects from the container.\" },\n    { handler: \"silence\", matchMessage: \"Using `Ember.HTMLBars.makeBoundHelper` is deprecated. Please refactor to using `Ember.Helper` or `Ember.Helper.helper`.\" },\n    { handler: \"silence\", matchMessage: /Accessing 'template' in .* is deprecated. To determine if a block was specified to .* please use '{{#if hasBlock}}' in the components layout./ }\n  ]\n};\n\n\n\n\n3. Fix and Repeat\nAfter fixing a deprecation and getting your scenarios working again, you might want to leave the deprecation message in the workflow file with the\nthrow handler enabled.  This will ensure you haven't missed anything, and ensure no new deprecated calls of that type are introduced to your project.\nNext, it's just a matter of going down the list, updating the handler, and fixing each remaining deprecation.\n\nIn the end, your deprecations can be fully turned on as \"throw\" and you should be able to use your application without error.  At this point, you can\ngo ahead and update your Ember version!  When you upgrade, be sure you remove the deprecations you've fixed from the deprecation workflow file,\nso that you can start the process over for the next release.\nSilencing Deprecation Warnings During Compile\nAs you upgrade between releases, you might also notice that your terminal log begins to stream template-related deprecation warnings during the compile process, making\nit difficult to review your compilation logs.\n\n\n\nIf you are using the deprecation workflow process above, you will likely prefer to gather these warnings during runtime execution instead.  The way to hide these\nwarnings during compile is to install the ember-cli-template-lint addon.  It suppresses\ntemplate deprecation warnings during compile in favor of showing them in the browser console during test suite execution or application usage.\nDeprecation Handling in Ember Inspector\nEmber Inspector also provides deprecation handling capability.  It can work complimentary to ember-cli-deprecation-workflow.  As you unsilence deprecations to\nfix them, the inspector can allow you to more quickly find where in your code a deprecation occurs when you run into it at runtime, reducing the amount of\nstack trace browsing you have to do.  For more information on using deprecation handling in Ember Inspector, see its guides section.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ca2af5aa71dc7d2dc0629dcb1d5641cd","fields":[{"name":"title","value":"Specifying the URL Type","type":"string"},{"name":"url","value":"/configuring-ember/specifying-url-type/","type":"enum"},{"name":"body","value":"The Ember router has four options to manage your application's URL:  history,\nwhich uses the HTML5 History API; hash, which uses anchor-based URLs; auto,\nwhich uses history if supported by the user's browser, and falls back to\nhash otherwise; and none, which doesn't update the URL. By default, Ember\nCLI configures the router to use auto. You can change this option in\nconfig/environment.js under ENV.locationType.\nhistory\nWhen using history, Ember uses the browser's\nhistory API to produce URLs with a structure like\n/posts/new.\n\nGiven the following router, entering /posts/new will take you to the posts.new\nroute.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('new');\n  });\n});\n\n\n\nKeep in mind that your server must serve the Ember app from all the URLs defined in your\nRouter.map function. In other words, if your user directly navigates to\n/posts/new, your server must be configured to serve your Ember app in\nresponse.\nhash\nThe hash option uses the URL's anchor to load the starting state of your\napplication and will keep it in sync as you move around. At present, this relies\non a hashchange event existing in the browser.\n\nIn the router example above, entering /#/posts/new will take you to the posts.new\nroute.\nnone\nFinally, if you don't want the browser's URL to interact with your application\nat all, you can disable the location API entirely by setting ENV.locationType\nto none. This is useful for\ntesting, or when you don't want Ember to muck with the URL (for example when you embed your\napplication in a larger page).\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3cddcc7a01c23b72f74ea3eceaaada93","fields":[{"name":"title","value":"Adding New Features","type":"string"},{"name":"url","value":"/contributing/adding-new-features/","type":"enum"},{"name":"body","value":"In general, new feature development should be done on master.\n\nBugfixes should not introduce new APIs or break existing APIs, and do\nnot need feature flags.\n\nFeatures can introduce new APIs, and need feature flags. They should not\nbe applied to the release or beta branches, since SemVer requires\nbumping the minor version to introduce new features.\n\nSecurity fixes should not introduce new APIs, but may, if strictly\nnecessary, break existing APIs. Such breakages should be as limited as\npossible.\nBug FixesUrgent Bug Fixes\nUrgent bugfixes are bugfixes that need to be applied to the existing\nrelease branch. If possible, they should be made on master and prefixed\nwith [BUGFIX release].\nBeta Bug Fixes\nBeta bugfixes are bugfixes that need to be applied to the beta branch.\nIf possible, they should be made on master and tagged with [BUGFIX\nbeta].\nSecurity Fixes\nSecurity fixes need to be applied to the beta branch, the current\nrelease branch, and the previous tag. If possible, they should be made\non master and tagged with [SECURITY].\nFeatures\nFeatures must always be wrapped in a feature flag. Tests for the feature\nmust also be wrapped in a feature flag.\n\nBecause the build-tools will process feature-flags, flags must use\nprecisely this format. We are choosing conditionals rather than a block\nform because functions change the surrounding scope and may introduce\nproblems with early return.\n\n  1\n2\n3\n\n  if (Ember.FEATURES.isEnabled(\"feature\")) {\n  // implementation\n}\n\n\n\nTests will always run with all features on, so make sure that any tests\nfor the feature are passing against the current state of the feature.\nCommits\nCommits related to a specific feature should include  a prefix like\n[FEATURE htmlbars]. This will allow us to quickly identify all commits\nfor a specific feature in the future. Features will never be applied to\nbeta or release branches. Once a beta or release branch has been cut, it\ncontains all of the new features it will ever have.\n\nIf a feature has made it into beta or release, and you make a commit to\nmaster that fixes a bug in the feature, treat it like a bugfix as\ndescribed above.\nFeature Naming Conventions\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n\n  Ember.FEATURES['\u003cpackageName\u003e-\u003cfeature\u003e'] // if package specific\nEmber.FEATURES['container-factory-injections']\nEmber.FEATURES['htmlbars']\n\n\nBuilds\nThe Canary build, which is based off master, will include all features,\nguarded by the conditionals in the original source. This means that\nusers of the canary build can enable whatever features they want by\nenabling them before creating their Ember.Application.\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  module.exports = function(environment) {\n  var ENV = {\n    EmberENV: {\n      FEATURES: {\n        htmlbars: true\n      }\n    },\n  }\n}\n\n\nfeatures.json\nThe root of the repository will contain a features.json file, which will\ncontain a list of features that should be enabled for beta or release\nbuilds.\n\nThis file is populated when branching, and may not gain additional\nfeatures after the original branch. It may remove features.\n\n  1\n2\n3\n\n  {\n  \"htmlbars\": true\n}\n\n\n\nThe build process will remove any features not included in the list, and\nremove the conditionals for features in the list.\nTravis Testing\nFor a new PR:\n\n\nTravis will test against master with all feature flags on.\nIf a commit is tagged with [BUGFIX beta], Travis will also\ncherry-pick the commit into beta, and run the tests on that\nbranch. If the commit doesn't apply cleanly or the tests fail, the\ntests will fail.\nIf a commit is tagged with [BUGFIX release], Travis will also cherry-pick\nthe commit into release, and run the test on that branch. If the commit\ndoesn't apply cleanly or the tests fail, the tests will fail.\n\n\nFor a new commit to master:\n\n\nTravis will run the tests as described above.\nIf the build passes, Travis will cherry-pick the commits into the\nappropriate branches.\n\n\nThe idea is that new commits should be submitted as PRs to ensure they\napply cleanly, and once the merge button is pressed, Travis will apply\nthem to the right branches.\nGo/No-Go Process\nEvery six weeks, the core team goes through the following process.\nBeta Branch\nAll remaining features on the beta branch are vetted for readiness. If\nany feature isn't ready, it is removed from features.json.\n\nOnce this is done, the beta branch is tagged and merged into release.\nMaster Branch\nAll features on the master branch are vetted for readiness. In order for\na feature to be considered \"ready\" at this stage, it must be ready as-is\nwith no blockers. Features are a no-go even if they are close and\nadditional work on the beta branch would make it ready.\n\nBecause this process happens every six weeks, there will be another\nopportunity for a feature to make it soon enough.\n\nOnce this is done, the master branch is merged into beta. A\nfeatures.json file is added with the features that are ready.\nBeta Releases\nEvery week, we repeat the Go/No-Go process for the features that remain\non the beta branch. Any feature that has become unready is removed from\nthe features.json.\n\nOnce this is done, a Beta release is tagged and pushed.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"26d81f9d1949f3951aa7d9505e7280dd","fields":[{"name":"title","value":"Repositories","type":"string"},{"name":"url","value":"/contributing/repositories/","type":"enum"},{"name":"body","value":"Ember is made up of several libraries. If you wish to add a feature or fix a bug please file a pull request against the appropriate repository. Be sure to check the libraries listed below before making changes in the Ember repository.\nMain Repositories\nEmber.js - The main repository for Ember.\n\n\nhttps://github.com/emberjs/ember.js\n\n\nEmber Data - A data persistence library for Ember.\n\n\nhttps://github.com/emberjs/data\n\n\nEmber Website - Source for http://emberjs.com\n\n\nhttps://github.com/emberjs/website\n\n\nEmber Guides - Source for http://guides.emberjs.com which you are currently reading.\n\n\nhttps://github.com/emberjs/guides\n\nLibraries Used By Ember\nThese libraries are part of the Ember asset output, but development of them takes place in a separate repository.\nBackburner\n\nbackburner.js - Implements the Ember run loop.\nhttps://github.com/ebryn/backburner.js\n\nDAG Map\n\ndag-map - A directed acyclic graph data structure for javascript\nhttps://github.com/krisselden/dag-map\n\nGlimmer 2\n\nglimmer - Implements the really fast rendering engine now included in Ember\nhttps://github.com/tildeio/glimmer\n\nHTMLBars\n\nhtmlbars - The syntax for templating most often used with Ember\nhttps://github.com/tildeio/htmlbars\n\nmorph-range\n\nmorph-range - Used by Ember for manipulating the text nodes known as morphs which are created for HTMLBars to keep track of text that could change.\nhttps://github.com/krisselden/morph-range\n\nRoute Recognizer\n\nroute-recognizer - A lightweight JavaScript library that matches paths against registered routes.\nhttps://github.com/tildeio/route-recognizer\n\nrouter.js\n\nrouter.js - A lightweight JavaScript library that builds on route-recognizer and rsvp to provide an API for handling routes.\nhttps://github.com/tildeio/router.js\n\nRSVP\n\nrsvp.js - Implementation of the of Promises/A+ spec used by Ember.\nhttps://github.com/tildeio/rsvp.js\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f72002399f11df302a9dac49684ae8dc","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/controllers/","type":"enum"},{"name":"body","value":"Controllers\nControllers behave like a specialized type of Component that is rendered by\nthe router when entering a Route.\n\nThe controller receives a single property from the Route – model – which is\nthe return value of the Route's model() method.\n\nTo define a Controller, run:\n\n  1\n\n  ember generate controller my-component-name\n\n\n\nThe value of my-component-name must match the name of the Route that renders\nit. So a Route named blog-post would have a matching Controller named\nblog-post.\n\nYou only need to generate a Controller if you want to customize its\nproperties or provide any actions. If you have no customizations, Ember will\nprovide a Controller instance for you at run time.\n\nLet's explore these concepts using an example of a route displaying a blog\npost. Presume a BlogPost model that is presented in a blog-post template.\n\nThe BlogPost model would have properties like:\n\n\ntitle\nintro\nbody\nauthor\n\n\nYour template would bind to these properties in the blog-post\ntemplate:\n\n  \n    \n      app/templates/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  \u003ch1\u003e{{model.title}}\u003c/h1\u003e\n\u003ch2\u003eby {{model.author}}\u003c/h2\u003e\n\n\u003cdiv class=\"intro\"\u003e\n  {{model.intro}}\n\u003c/div\u003e\n\u003chr\u003e\n\u003cdiv class=\"body\"\u003e\n  {{model.body}}\n\u003c/div\u003e\n\n\n\nIn this simple example, we don't have any display-specific properties\nor actions just yet. For now, our controller's model property acts as a\npass-through (or \"proxy\") for the model properties. (Remember that\na controller gets the model it represents from its route handler.)\n\nLet's say we wanted to add a feature that would allow the user to\ntoggle the display of the body section. To implement this, we would\nfirst modify our template to show the body only if the value of a\nnew isExpanded property is true.\n\n  \n    \n      app/templates/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  \u003ch1\u003e{{model.title}}\u003c/h1\u003e\n\u003ch2\u003eby {{model.author}}\u003c/h2\u003e\n\n\u003cdiv class='intro'\u003e\n  {{model.intro}}\n\u003c/div\u003e\n\u003chr\u003e\n\n{{#if isExpanded}}\n  \u003cbutton {{action \"toggleBody\"}}\u003eHide Body\u003c/button\u003e\n  \u003cdiv class=\"body\"\u003e\n    {{model.body}}\n  \u003c/div\u003e\n{{else}}\n  \u003cbutton {{action \"toggleBody\"}}\u003eShow Body\u003c/button\u003e\n{{/if}}\n\n\n\nYou can then define what the action does within the actions hook\nof the controller, as you would with a component:\n\n  \n    \n      app/controllers/blog-post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Controller.extend({\n  actions: {\n    toggleBody() {\n      this.toggleProperty('isExpanded');\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a54077923b8a93308baa1922a604275","fields":[{"name":"title","value":"Inspecting Objects via the Container","type":"string"},{"name":"url","value":"/ember-inspector/container/","type":"enum"},{"name":"body","value":"Every Ember application has a container that maintains object instances for you. You can\ninspect these instances using the Container tab. This is useful for objects\nthat don't fall under a dedicated menu, such as services.\n\n\n\nClick on the Container tab, and you will see a list of instances the container is holding. Click on a type to see the list of all instances of that type maintained by the container.\nInspecting Instances\nClick on a row to inspect a given instance using the Object Inspector.\n\n\nFilter and Reload\nYou can reload the container tab by clicking on the reload icon. To search for instances, type a query in the search box.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e43dd675078ff4ac486b57fa13d5c944","fields":[{"name":"title","value":"Data Tab","type":"string"},{"name":"url","value":"/ember-inspector/data/","type":"enum"},{"name":"body","value":"You can inspect your models by clicking on the Data tab. Check out Building a Data Custom Adapter below if you maintain your own persistence library. \n\nWhen you open the Data tab, you will see a list of model types defined\nin your application, along with the number of loaded records.\nThe Inspector displays the loaded records when you click on a model type.\n\n\nInspecting Records\nEach row in the list corresponds to one record. The first four model attributes are shown in the list view. Clicking on the record will open the Object Inspector for that record, and display all attributes.\n\n\nRecord States and Filtering\nThe Data tab is kept in sync with the data loaded in your application.\nAny record additions, deletions, or changes are reflected immediately. If you have unsaved\nrecords, they will be displayed in green by clicking on the New pill.\n\n\n\nClick on the Modified pill to display unsaved record modifications.\n\n\n\nYou can also filter records by entering a query in the search box.\nBuilding a Data Custom Adapter\nYou can use your own data persistence library with the Inspector. Build a data adapter, and you can inspect your models\nusing the Data tab. Use Ember Data's data adapter as an example for how to build your data adapter.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f1bedd99c57f624399a149361ed1ea21","fields":[{"name":"title","value":"Tackling Deprecations","type":"string"},{"name":"url","value":"/ember-inspector/deprecations/","type":"enum"},{"name":"body","value":"As part of making your app upgrades as smooth as possible, the Inspector gathers your deprecations, groups them, and displays them in a\nway that helps you fix them.\n\nTo view the list of deprecations in an app, click on the Deprecations menu.\n\n\n\nYou can see the total number of deprecations next to the Deprecations menu.\nYou can also see the number of occurrences for each deprecation.\nEmber CLI Deprecation Sources\nIf you are using Ember CLI and have source maps enabled, you can see a\nlist of sources for each deprecation. If you are using Chrome or Firefox,\nclicking on the source opens the sources panel and takes you to\nthe code that caused the deprecation message to be displayed.\n\n\n\n\n\nYou can send the deprecation message's stack trace to the\nconsole by clicking on Trace in the console.\nTransition Plans\nClick on the \"Transition Plan\" link for information on how to remove the deprecation warning, and you'll be taken to a helpful deprecation guide on the Ember website.\n\n\nFiltering and Clearing\nYou can filter the deprecations by typing a query in the search box.\nYou can also clear the current deprecations by clicking on the clear icon\nat the top.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4d3cec3ae6d2506e5e756dc6182d88bb","fields":[{"name":"title","value":"Library Info","type":"string"},{"name":"url","value":"/ember-inspector/info/","type":"enum"},{"name":"body","value":"To see a list of libraries used in your application, click on the Info menu. This view displays the libraries used, along with their version.\n\n\nRegistering a Library\nIf you would like to add your own application or library to the list, you can register it using:\n\n  1\n\n  Ember.libraries.register(libraryName, libraryVersion);\n\n\nEmber Cli\nIf you're using the ember-cli-app-version addon, your application's name and version will be added to the list automatically.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6ffdaf430e1066949e727f7e18a926c0","fields":[{"name":"title","value":"Installing the Inspector","type":"string"},{"name":"url","value":"/ember-inspector/installation/","type":"enum"},{"name":"body","value":"The Ember Inspector is a browser add-on designed to help you understand and debug your Ember applications.\n\nYou can install the Inspector on Google Chrome, Firefox, other\nbrowsers (via a bookmarklet), and on mobile devices by following the steps below.\nGoogle Chrome\nYou can install the Inspector on Google Chrome as a new Developer\nTool. To begin, visit the Extension page on the Chrome Web Store.\n\nClick on \"Add To Chrome\":\n\n\n\nOnce installed, go to an Ember application, open the Developer Tools,\nand click on the Ember tab at the far right.\n\n\nFile:// protocol\nTo use the Inspector with the file:// protocol, visit chrome://extensions in Chrome and check the \"Allow access to file URLs\" checkbox:\n\n\nEnable Tomster\nYou can configure a Tomster icon to show up in Chrome's URL bar whenever you are visiting a site that uses Ember.\n\nVisit chrome://extensions, then click on Options.\n\n\n\nMake sure the \"Display the Tomster\" checkbox is checked.\n\n\nFirefox\nVisit the Add-on page on the Mozilla Add-ons\nsite.\n\nClick on \"Add to Firefox\".\n\n\n\nOnce installed, go to an Ember application, open the Developer Tools,\nand click on the Ember tab.\n\n\nEnable Tomster\nTo enable the Tomster icon to show up in the URL bar whenever you are\nvisiting a site that uses Ember visit about:addons.\n\nClick on Extensions -\u003e Preferences.\n\n\n\nThen make sure the \"Display the Tomster icon when a site runs Ember.js\" checkbox is checked.\n\n\nVia Bookmarklet\nIf you are using a browser other than Chrome or Firefox, you can use the\nbookmarklet option to use the Inspector.\n\nAdd the following bookmark:\n\nBookmark Me\n\nTo open the Inspector, click on the new bookmark. Safari blocks popups by default, so you'll need to enable popups before using the bookmarklet.\nMobile Devices\nIf you want to run the Inspector on a mobile device,\nyou can use the Ember CLI Remote Inspector addon.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9893b6fad8e586504102380a81fea52b","fields":[{"name":"title","value":"Object Inspector","type":"string"},{"name":"url","value":"/ember-inspector/object-inspector/","type":"enum"},{"name":"body","value":"The Inspector includes a panel that allows you to view and interact with your Ember objects. \nTo open it, click on any Ember object. You can then view the object's properties.\nViewing Objects\nHere's what you see when you click on an object:\n\n\n\nThe Inspector displays the parent objects and mixins that are composed into the chosen object, including the inherited properties.\n\nEach property value in this view is bound to your application, so if the value of a \nproperty updates in your app, it will be reflected in the Inspector.\n\nIf a property name is preceded by a calculator icon, that means it is a computed property. If the value of a computed property hasn't yet been computed, you can\nclick on the calculator to compute it.\nExposing Objects to the ConsoleSending from the Inspector to the Console\nYou can expose objects to the console by clicking on the $E button within the Inspector.\nThis will set the global $E variable to the chosen object.\n\n\n\nYou can also expose properties to the console. When you hover over an object's properties, a $E button will appear\nnext to every property. Click on it to expose the property's value to the\nconsole.\n\n\nSending from the Console to the Inspector\nYou can send Ember objects and arrays to the Inspector by using\nEmberInspector.inspect within the console.\n\n  1\n2\n\n  var object = Ember.Object.create();\nEmberInspector.inspect(object);\n\n\n\nMake sure the Inspector is active when you call this method.\nEditing Properties\nYou can edit String, Number, and Boolean properties in the Inspector.\nYour changes will be reflected immediately in your app. Click on a property's value to start editing it.\n\n\n\nEdit the property and press the ENTER key to commit the change, or ESC to cancel.\nNavigating the Inspector\nIn addition to inspecting the properties above, you can inspect properties that hold Ember objects or arrays.\nClick on the property's value to inspect it.\n\n\n\nYou can continue drill into the Inspector as long as properties contain either an\nEmber object or an array.\nIn the image below, we clicked on the model property first, then clicked\non the store property.\n\n\n\nYou can see the path to the current object at the top of the\nInspector. You can go back to the previous object by clicking on the\nleft-facing arrow at the top left.\nCustom Property Grouping\nSome properties are not only grouped by inheritance, but also\nby framework level semantics. For example, if you inspect an Ember Data\nmodel, you can see Attributes, Belongs To, Has Many, and Flags\ngroups.\n\n\n\nLibrary authors can customize how any object will display in the Inspector. \nBy defining a _debugInfo method, an object can tell the Inspector how it should be rendered.\nFor an example on how to customize an object's properties, see Ember Data's\ncustomization.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"586a911ed3096cd96da506f68a4f75ac","fields":[{"name":"title","value":"Debugging Promises","type":"string"},{"name":"url","value":"/ember-inspector/promises/","type":"enum"},{"name":"body","value":"The Inspector provides a way to look at all Promises created\nin your application. Click on the Promises menu to start inspecting them.\n\n\n\nYou can see a hierarchical list of Promises with labels describing each\nPromise, its state, its settled value, and the time it took to\nsettle.\nPromise States and Filtering\nPromises have different colors based on their state.\n\n\n\n\n\n\n\nYou can filter by clicking on the following pills: Rejected, Pending, Fulfilled.\n\n\n\nYou can also search for Promises by typing a query in the search box.\n\nTo clear the currently logged Promises, click on the clear icon on the\ntop left of the tab.\nInspecting Settled Values\nIf the fulfillment value of a Promise is an Ember object or an array, you can click\non that object to open it in the Object Inspector.\n\n\n\nIf the rejection value is an Error object, you can send its stack trace to\nthe console.\n\n\n\nYou can also click on the $E button to send the value to the console.\nTracing\nThe Inspector provides a way to view a Promise's stack trace.\nTracing Promises is disabled by default for performance reasons. To\nenable tracing, check the Trace promise checkbox. You may want to\nreload to trace existing Promises.\n\n\n\nTo trace a Promise, click on the Trace button next to the label,\nwhich will send the Promise stack trace to the console.\n\n\nLabeling Promises\nPromises generated by Ember are all labeled by default.\nYou can also label your own RSVP Promises to find them in the Inspector's Promises tab.\nAll RSVP methods can take a label as the final argument.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \nvar label = 'Find Posts'\n\nnew RSVP.Promise(method, label);\n\nRSVP.Promise.resolve(value, label);\n\nRSVP.Promise.reject(reason, label);\n\nRSVP.Promise.all(array, label);\n\nRSVP.Promise.hash(hash, label);\n\npromise.then(success, failure, label);\n\npromise.catch(callback, label);\n\npromise.finally(callback, label);\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ed658525bc79f3040009b9bb48c2b542","fields":[{"name":"title","value":"Rendering Performance","type":"string"},{"name":"url","value":"/ember-inspector/render-performance/","type":"enum"},{"name":"body","value":"You can use the Inspector to measure your app's render times. Click on Render Performance to start inspecting render times.\n\n\nAccuracy\nUsing the Inspector adds a delay to your rendering, so the durations you see\nare not an accurate representation of the speed of your production apps. Use these\ntimes to compare durations and debug rendering bottlenecks, but not as\na way to accurately measure rendering times.\nToolbar\nClick on the \"clear\" icon to remove existing render logs.\n\nTo measure components and templates that are rendered on initial application boot,\nclick on the \"Reload\" button at the top. This button ensures that the Inspector starts\nmeasuring render times when your app boots.\n\nTo filter the logs, type a query in the search box.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"055448419ab0ef77beac250a0a5d84ee","fields":[{"name":"title","value":"Inspecting Routes","type":"string"},{"name":"url","value":"/ember-inspector/routes/","type":"enum"},{"name":"body","value":"The Routes tab displays a list of your application's routes.\n\nFor the following code:\n\n  1\n2\n3\n\n  this.route('posts', function() {\n  this.route('new');\n});\n\n\n\nThe Inspector displays these routes:\n\n\n\nAs you can see, the Inspector shows the routes you defined as well as the routes\nautomatically generated by Ember.\nViewing the Current Route\nThe Inspector highlights the currently active routes. However, if your app has grown too large for this to be useful, you can use the Current Route Only\ncheckbox to hide all routes except the currently active ones.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b95f5ae41d7e6c6611080f203e11268c","fields":[{"name":"title","value":"Troubleshooting","type":"string"},{"name":"url","value":"/ember-inspector/troubleshooting/","type":"enum"},{"name":"body","value":"Below are some common issues you may encounter when using the Inspector, along with the\nnecessary steps to solve them. If your issue is not listed below, please submit an\nissue to the Inspector's GitHub repo.\nEmber Application Not Detected\nIf the Inspector cannot detect an Ember application, you will see\nthe following message:\n\n\n\nSome of the reasons this may happen:\n\n\nThis is not an Ember application\nYou are using an old Ember version ( \u003c 1.0 ).\nYou are using a protocol other than http or https. For file:// protocol,\nfollow these steps.\nThe Ember application is inside a sandboxed iframe with no url (if you\nare using JS Bin, follow these steps.\n\nUsing the Inspector with JS Bin\nDue to the way JS Bin uses iframes, the Inspector doesn't work with edit\nmode. To use the Inspector with JS Bin, switch to the \"live preview\" mode by clicking on\nthe arrow circled below.\n\n\nApplication is not Detected Without Reload\nIf you always have to reload your application after you open the Inspector, that may mean\nthe application's booted state is corrupt. This happens if you call advanceReadiness or\ndeferReadiness after the application has already booted.\nData Adapter Not Detected\nWhen you click on the Data tab, and see this message:\n\n\n\nIt means that the data persistence library you're using does not support the Inspector.\nIf you are the library's author, see this section on how to add Inspector support to your library.\nPromises Not Detected\nYou click on the Promises tab, and see this message:\n\n\n\nThis happens if you are using a version of Ember \u003c 1.3.\nMissing Promises\nIf the Promises tab is working, but there are Promises you can't find,\nit's probably because these Promises were created before the\nInspector was activated. To detect Promises the moment the app boots, click on the Reload button below:\n\n\nInspector Version Old on Firefox\nFirefox addons need to go through a review process with each update, so the Inspector is usually one version behind.\n\nUnfortunately we don't have control over the Firefox review process, so if you need\nthe latest Inspector version, download and install it manually from\nGitHub.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a9ffd50c1c93761a22ac9b6feb6362a5","fields":[{"name":"title","value":"The View Tree","type":"string"},{"name":"url","value":"/ember-inspector/view-tree/","type":"enum"},{"name":"body","value":"You can use the View Tree to inspect your application's current state.\nThe View Tree shows you the currently rendered templates, models, controllers, and components, in a tree format. Click on the View Tree menu on the left to see these.\n\n\n\nUse the tips described in Object Inspector to inspect models and controllers. See below for templates and components.\nInspecting Templates\nTo see how a template was rendered by Ember, click on the template in the View Tree. If \nyou're using Chrome or Firefox, you'll be sent to the Elements panel with that DOM element selected.\n\n\n\n\nComponents and Inline Views\nThe View Tree ignores components and inline views by default. To load these into the View Tree check the Components and All Views checkboxes.\n\n\n\nYou can then inspect components using the Object Inspector.\nHighlighting TemplatesHovering over the View Tree\nWhen you hover over the items in the View Tree, the related templates will be\nhighlighted in your app. For every highlighted template, you can see the\ntemplate name, and its associated objects.\n\n\nHovering over the app\nIf you want to highlight a template or component directly within your app, click on the magnifying glass in the Inspector, then hover over the app.\nAs your our mouse passes over it, the related template or component will be\nhighlighted.\n\n\n\nIf you click on a highlighted template or component, the Inspector will select it. You can then\nclick on the backing objects to send them to the object inspector.\n\n\n\nClick on the X button to deselect a template.\nDuration\nThe Duration column displays the render time for a given template, including the template's children.\n\n\n\nBy measuring the render time, the Inspector adds a slight delay to the rendering process. As such, the duration is not an exact representation of expected rendering time for a production application. Thus, the rendering duration is more useful to compare times than as an absolute measure of performance.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2921955846de516e46f41f11de521501","fields":[{"name":"title","value":"Core Concepts","type":"string"},{"name":"url","value":"/getting-started/core-concepts/","type":"enum"},{"name":"body","value":"Before you start writing any Ember code, it's a good idea to get an overview of how an\nEmber application works.\n\n\nRouter and Route Handlers\nImagine we are writing a web app for a site that lets users list their properties to rent. At any given time, we should be able to answer questions about the current state like What rental are they looking at? and Are they editing it? In Ember, the answer to these questions is determined by the URL.\nThe URL can be set in a few ways:\n\n\nThe user loads the app for the first time.\nThe user changes the URL manually, such as by clicking the back button or by editing the address bar.\nThe user clicks a link within the app.\nSome other event in the app causes the URL to change.\n\n\nNo matter how the URL gets set, the first thing that happens is that the Ember router maps the URL to a route handler.\n\nThe route handler then typically does two things:\n\n\nIt renders a template.\nIt loads a model that is then available to the template.\n\nTemplates\nEmber uses templates to organize the layout of HTML in an application.\n\nMost templates in an Ember codebase are instantly familiar, and look like any\nfragment of HTML. For example:\n\n  1\n\n  \u003cdiv\u003eHi, this is a valid Ember template!\u003c/div\u003e\n\n\n\nEmber templates use the syntax of Handlebars\ntemplates. Anything that is valid Handlebars syntax is valid Ember syntax.\n\nTemplates can also display properties provided to them from their context, which is either a component or a route (technically, a controller presents the model from the route to the template, but this is rarely used in modern Ember apps and will be deprecated soon). For example:\n\n  1\n\n  \u003cdiv\u003eHi {{name}}, this is a valid Ember template!\u003c/div\u003e\n\n\n\nHere, {{name}} is a property provided by the template's context.\n\nBesides properties, double curly braces ({{}}) may also contain\nhelpers and components, which we'll discuss later.\nModels\nModels represent persistent state.\n\nFor example, a property rentals application would want to save the details of a rental when a user publishes it, and so a rental would have a model defining its details, perhaps called the rental model.\n\nA model typically persists information to a web server, although models can be configured to save to anywhere else, such as the browser's Local Storage.\nComponents\nWhile templates describe how a user interface looks, components control how the user interface behaves.\n\nComponents consist of two parts: a template written in Handlebars, and a source file written in JavaScript that defines the component's behavior. For example, our property rental application might have a component for displaying all the rentals called all-rentals, and another component for displaying an individual rental called rental-tile. The rental-tile component might define a behavior that lets the user hide and show the image property of the rental.\n\nLet's see these core concepts in action by building a property rental application in the next lesson.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"59427847e14331e01de43a097e3ee4cb","fields":[{"name":"title","value":"Installing Ember","type":"string"},{"name":"url","value":"/getting-started/","type":"enum"},{"name":"body","value":"Getting started with Ember is easy. Ember projects are created and managed\nthrough our command line build tool Ember CLI.\nThis tool provides:\n\n\nModern application asset management (including concatenation, minifying, and versioning).\nGenerators to help create components, routes, and more.\nA conventional project layout, making existing Ember applications easy to approach.\nSupport for ES2015/ES6 JavaScript via the Babel project. This includes support for JavaScript modules, which are used throughout this guide.\nA complete QUnit test harness.\nThe ability to consume a growing ecosystem of Ember Addons.\n\nDependenciesNode.js and npm\nEmber CLI is built with JavaScript, and expects the Node.js\nruntime. It also requires dependencies fetched via npm. npm is packaged with Node.js, so if your computer has Node.js\ninstalled you are ready to go.\n\nEmber requires Node.js 0.12 or higher and npm 2.7 or higher.\nIf you're not sure whether you have Node.js or the right version, run this on your\ncommand line:\n\n  1\n2\n\n  node --version\nnpm --version\n\n\n\nIf you get a \"command not found\" error or an outdated version for Node:\n\n\nWindows or Mac users can download and run this Node.js installer.\nMac users often prefer to install Node using Homebrew. After\ninstalling Homebrew, run brew install node to install Node.js.\nLinux users can use this guide for Node.js installation on Linux.\n\n\nIf you get an outdated version of npm, run npm install -g npm.\nGit\nEmber requires Git to manage many of its dependencies. Git comes with Mac OS\nX and most Linux distributions. Windows users can\ndownload and run this Git installer.\nWatchman (optional)\nOn Mac and Linux, you can improve file watching performance by installing Watchman.\nPhantomJS (optional)\nYou can run your tests from the command line with PhantomJS, without the\nneed for a browser to be open. Consult the PhantomJS download instructions.\nInstallation\nInstall Ember using npm:\n\n  1\n\n  npm install -g ember-cli@2.4\n\n\n\nTo verify that your installation was successful, run:\n\n  1\n\n  ember -v\n\n\n\nIf a version number is shown, you're ready to go.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"dbc742022afd5a3599eb76b833673473","fields":[{"name":"title","value":"Quick Start","type":"string"},{"name":"url","value":"/getting-started/quick-start/","type":"enum"},{"name":"body","value":"This guide will teach you how to build a simple app using Ember from\nscratch.\n\nWe'll cover these steps:\n\n\nInstalling Ember.\nCreating a new application.\nDefining a route.\nWriting a UI component.\nBuilding your app to be deployed to production.\n\nInstall Ember\nYou can install Ember with a single command using npm, the Node.js package\nmanager. Type this into your terminal:\n\n  1\n\n  npm install -g ember-cli@2.4\n\n\n\nDon't have npm? Learn how to install Node.js and npm here.\nCreate a New Application\nOnce you've installed Ember CLI via npm, you will have access to a new\nember command in your terminal. You can use the ember new command to\ncreate a new application.\n\n  1\n\n  ember new ember-quickstart\n\n\n\nThis one command will create a new directory called ember-quickstart\nand set up a new Ember application inside of it.  Out of the box, your\napplication will include:\n\n\nA development server.\nTemplate compilation.\nJavaScript and CSS minification.\nES2015 features via Babel.\n\n\nBy providing everything you need to build production-ready web\napplications in an integrated package, Ember makes starting new projects\na breeze.\n\nLet's make sure everything is working properly. cd into the application\ndirectory ember-quickstart and start the development server by typing:\n\n  1\n2\n\n  cd ember-quickstart\nember serve\n\n\n\nAfter a few seconds, you should see output that looks like this:\n\n  1\n2\n\n  Livereload server on http://localhost:49152\nServing on http://localhost:4200/\n\n\n\n(To stop the server at any time, type Ctrl-C in your terminal.)\n\nOpen http://localhost:4200/ in your browser of\nchoice. You should see a page that says \"Welcome to Ember\" and not much\nelse. Congratulations! You just created and booted your first Ember app.\n\nSwitch to your editor and open app/templates/application.hbs. This is\ncalled the application template and it is always on screen while the\nuser has your application loaded.\n\nIn your editor, change the text inside the \u003ch2\u003e from Welcome to\nEmber to PeopleTracker and save the file. Notice that Ember detects\nthe change you just made and automatically reloads the page for you in\nthe background. You should see that \"Welcome to Ember\" has been\nreplaced by \"PeopleTracker\".\nDefine a Route\nLet's build an application that shows a list of scientists. To do that,\nthe first step is to create a route. For now, you can think of routes as\nbeing the different pages that make up your application.\n\nEmber comes with generators that automate the boilerplate code for\ncommon tasks. To generate a route, type this in your terminal:\n\n  1\n\n  ember generate route scientists\n\n\n\nYou'll see output like this:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  installing route\n  create app/routes/scientists.js\n  create app/templates/scientists.hbs\nupdating router\n  add route scientists\ninstalling route-test\n  create tests/unit/routes/scientists-test.js\n\n\n\nThat's Ember telling you that it has created:\n\n\nA template to be displayed when the user visits /scientists.\nA Route object that fetches the model used by that template.\nAn entry in the application's router (located in app/router.js).\nA unit test for this route.\n\n\nOpen the newly-created template in app/templates/scientists.hbs and add\nthe following HTML:\n\n  \n    \n      app/templates/scientists.hbs\n    \n  \n\n  1\n\n  \u003ch2\u003eList of Scientists\u003c/h2\u003e\n\n\n\nIn your browser, open\nhttp://localhost:4200/scientists. You should\nsee the \u003ch2\u003e you put in the scientists.hbs template, right below the\n\u003ch2\u003e from our application.hbs template.\n\nNow that we've got the scientists template rendering, let's give it some\ndata to render. We do that by specifying a model for that route, and\nwe can specify a model by editing app/routes/scientists.js.\n\nWe'll take the code created for us by the generator and add a model()\nmethod to the Route:\n\n\n  \n    \n      app/routes/scientists.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n  import Ember from 'ember';\n\nexport default Ember.Route.extend({\n  model() {\n    return ['Marie Curie', 'Mae Jemison', 'Albert Hofmann'];\n  }\n});\n\n\n(This code example uses the latest features in JavaScript, some of which\nyou may not be familiar with. Learn more with this overview of the\nnewest JavaScript features.)\n\nIn a route's model() method, you return whatever data you want to make\navailable to the template. If you need to fetch data asynchronously, the\nmodel() method supports any library that uses JavaScript\nPromises.\n\nNow let's tell Ember how to turn that array of strings into HTML. Open\nthe scientists template and add some Handlebars code to loop through the\narray and print it:\n\n\n  \n    \n      app/templates/scientists.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n  \u003ch2\u003eList of Scientists\u003c/h2\u003e\n\n\u003cul\u003e\n  {{#each model as |scientist|}}\n    \u003cli\u003e{{scientist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\nHere, we use the each helper to loop over each item in the array we\nprovided from the model() hook and print it inside an \u003cli\u003e element.\nCreate a UI Component\nAs your application grows and you notice you are sharing UI elements\nbetween multiple pages (or using them multiple times on the same page),\nEmber makes it easy to refactor your templates into reusable components.\n\nLet's create a people-list component that we can use\nin multiple places to show a list of people.\n\nAs usual, there's a generator that makes this easy for us. Make a new\ncomponent by typing:\n\n  1\n\n  ember generate component people-list\n\n\n\nCopy and paste the scientists template into the people-list\ncomponent's template and edit it to look as follows:\n\n  \n    \n      app/templates/components/people-list.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003ch2\u003e{{title}}\u003c/h2\u003e\n\n\u003cul\u003e\n  {{#each people as |person|}}\n    \u003cli\u003e{{person}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nNote that we've changed the title from a hard-coded string (\"List of\nScientists\") to a dynamic property ({{title}}). We've also renamed\nscientist to the more-generic person, decreasing the coupling of our\ncomponent to where it's used.\n\nSave this template and switch back to the scientists template. Replace all\nour old code with our new componentized version. Components look like\nHTML tags but instead of using angle brackets (\u003ctag\u003e) they use double\ncurly braces ({{component}}). We're going to tell our component:\n\n\nWhat title to use, via the title attribute.\nWhat array of people to use, via the people attribute. We'll\nprovide this route's model as the list of people.\n\n\n\n  \n    \n      app/templates/scientists.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n  \u003ch2\u003eList of Scientists\u003c/h2\u003e\n\n\u003cul\u003e\n  {{#each model as |scientist|}}\n    \u003cli\u003e{{scientist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n{{people-list title=\"List of Scientists\" people=model}}\n\n\nGo back to your browser and you should see that the UI looks identical.\nThe only difference is that now we've componentized our list into a\nversion that's more reusable and more maintainable.\n\nYou can see this in action if you create a new route that shows a\ndifferent list of people. As an exercise for the reader, you may try to\ncreate a programmers route that shows a list of famous programmers. By\nre-using the people-list component, you can do it in almost no code at\nall.\nBuilding For Production\nNow that we've written our application and verified that it works in\ndevelopment, it's time to get it ready to deploy to our users. To do so,\nrun the following command:\n\n  1\n\n  ember build --env production\n\n\n\nThe build command packages up all of the assets that make up your\napplication—JavaScript, templates, CSS, web fonts, images, and\nmore.\n\nIn this case, we told Ember to build for the production environment via\nthe --env flag. This creates an optimized bundle that's ready to\nupload to your web host. Once the build finishes, you'll find all of the\nconcatenated and minified assets in your application's dist/\ndirectory.\n\nThe Ember community values collaboration and building common tools that\neveryone relies on. If you're interested in deploying your app to\nproduction in a fast and reliable way, check out the Ember CLI\nDeploy addon.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8eb53bf12dce0cce3b5439fc66fdc73c","fields":[{"name":"title","value":"Web Development","type":"string"},{"name":"url","value":"/glossary/web-development/","type":"enum"},{"name":"body","value":"Joining a web development community can be a challenge within itself, especially when all the resources you visit assume you're familiar with other technologies that you're not familiar with.\n\nOur goal is to help you avoid that mess and come up to speed as fast as possible; you can consider us your internet friend.\nCDN\nContent Delivery Network\n\nThis is typically a paid service you can use to get great performance for your app. Many CDNs act as caching proxies to your origin server; some require you to upload your assets to them. They give you a URL for each resource in your app. This URL will resolve differently for folks depending on where they're browsing.\n\nBehind the scenes, the CDN will distribute your content geographically with the goal of end-users being able to fetch your content with the lowest latency possible. For example, if a user is in India, they'd likely get content served from India faster than from the United States.\nCoffeeScript, TypeScript\nThese are both languages that compile to JavaScript. You're able to write your code using the syntax they offer and when ready you compile your TypeScript or CoffeeScript into JavaScript.\n\nCoffeeScript vs TypeScript\nEvergreen browsers\nBrowsers that update themselves (without user intervention).\n\nEvergreen Browsers\nES3, ES5, ES5.1, ES6 (aka ES2015), etc\nES stands for ECMAScript, which is the specification that JavaScript is based on. The number that follows is the version of the specification.\n\nMost browsers support at least ES5, and some even have ES6 (also known as ES2015) support. You can check each browser's support (including yours) here:\n\n\nES5 support\nES6 support\n\n\nECMAScript\nLESS, Sass\nBoth LESS and Sass are types of CSS preprocessor markup intended to give you much more control over your CSS. During the build process, the LESS or Sass resources compile down to vanilla CSS (which can be executed in a browser).\n\nSass/Less Comparison\nLinter, linting, jslint, jshint\nA validation tool which checks for common issues in your JavaScript. You'd usually use this in your build process to enforce quality in your codebase. A great example of something to check for: making sure you've always got your semicolons.\n\nAn example of some of the options you can configure\nPolyfill\nThis is a concept that typically means providing JavaScript which tests for features that are missing (prototypes not defined, etc) and \"fills\" them by providing an implementation.\nPromise\nAsynchronous calls typically return a promise (or deferred). This is an object which has a state: it can be given handlers for when it's fulfilled or rejected.\n\nEmber makes use of these in places like the model hook for a route. Until the promise resolves, Ember is able to put the route into a \"loading\" state.\n\n\nAn open standard for sound, interoperable JavaScript promises\nemberjs.com - A word on promises\n\nSSR\nServer Side Rendering\n\nInside FastBoot: The Road to Server-Side Rendering\nTranspile\nWhen related to JavaScript, this can be part of your build process which \"transpiles\" (converts) your ES6 syntax JavaScript to JavaScript that is supported by current browsers.\n\nBesides ES6, you'll see a lot of content about compiling/transpiling CoffeeScript, a short-hand language which can \"compile\" to JavaScript.\n\n\nEmber CLI specifically uses Babel via the ember-cli-babel plugin.\n\nShadow DOM\nNot to be confused with Virtual DOM. Shadow DOM is still a work in progress, but basically a proposed way to have an \"isolated\" DOM encapsulated within your app's DOM.\n\nCreating a re-usable \"widget\" or control might be a good use-case for this. Browsers implement some of their controls using their own version of a shadow DOM.\n\n\nW3C Working Draft\nWhat the Heck is Shadow DOM?\n\nVirtual DOM\nNot to be confused with Shadow DOM. The concept of a virtual DOM means abstracting your code (or in our case, Ember) away from using the browser's DOM in favor of a \"virtual\" DOM that can easily be accessed for read/writes or even serialized.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6666cd76f96956469e7be39d750cc7d9","fields":[{"name":"title","value":"Ember.js Guides","type":"string"},{"name":"url","value":"/","type":"enum"},{"name":"body","value":"Welcome to the Ember.js Guides! This documentation will take you from\ntotal beginner to Ember expert.\nOrganization\nOn the left side of each page in the Guides is a table of contents,\norganized into sections that can be expanded to show the topics\nthey cover. Both the sections and the topics within each section are\nordered from the most basic concepts to the more advanced.\n\nThe Guides are intended to contain practical explanations of how to\nbuild Ember apps, focusing on the most widely-used features of Ember.js.\nFor comprehensive documentation of every Ember feature and API, see the\nEmber.js API documentation.\n\nThe Guides begin with an explanation of how to get started with Ember, followed\nby a tutorial on how to build your first Ember app. If you're brand new to\nEmber, we recommend you start off by following along with these first two\nsections of the Guides.\nAssumptions\nWhile we try to make the Guides as beginner-friendly as we can, we must\nestablish a baseline so that the guides can keep focused on Ember.js\nfunctionality. We will try to link to appropriate documentation whenever\na concept is introduced.\n\nTo make the most out of the guides, you should have a working knowledge of:\n\n\nHTML, CSS, JavaScript - the building blocks of web pages. You can find documentation of each of these technologies at the Mozilla Developer Network.\nPromises - the native way to deal with asynchrony in your JavaScript code. See the relevant Mozilla Developer Network section.\nES2015 modules - you will better understand Ember CLI's project structure and import paths if you are comfortable with ES6 JavaScript Modules.\nES2015 syntax - Ember CLI comes with Babel.js by default so you can\ntake advantage of newer language features such as arrow functions, template\nstrings, destructuring, and more. You can check the\nBabel.js documentation or read Understanding ECMAScript 6\nonline.\n\nReporting a problem\nTypos, missing words, code samples with errors are all considered\ndocumentation bugs. If you spot one of them, or want to otherwise improve\nthe existing guides, we are happy to help you help us!\n\nSome of the more common ways to report a problem with the guides are:\n\n\nUsing the pencil icon on the top-right of each guide page\nOpening an issue/pull request to the GitHub repository\n\n\nClicking the pencil icon will bring you to GitHub's editor for that\nguide so you can edit right away, using the Markdown markup language.\nThis is the fastest way to correct a typo, a missing word, or an error in\na code sample.\n\nIf you wish to make a more significant contribution be sure to check our\nissue tracker to see if your issue is already being\naddressed. If you don't find an active issue, open a new one.\n\nIf you have any styling questions, or about the contributing process you\ncan check out our contributing guide. If your\nquestion persists, reach us at #-learning on the Slack\ngroup.\n\nGood luck!\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"dcff186751ba7af99e321b5fe8d3f4dc","fields":[{"name":"title","value":"Creating, Updating and Deleting","type":"string"},{"name":"url","value":"/models/creating-updating-and-deleting-records/","type":"enum"},{"name":"body","value":"Creating Records\nYou can create records by calling the\ncreateRecord()\nmethod on the store.\n\n  1\n2\n3\n4\n\n  store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\n\n\nThe store object is available in controllers and routes using this.store.\nUpdating Records\nMaking changes to Ember Data records is as simple as setting the attribute you\nwant to change:\n\n  1\n2\n3\n4\n\n  this.store.findRecord('person', 1).then(function(tyrion) {\n  // ...after the record has loaded\n  tyrion.set('firstName', \"Yollo\");\n});\n\n\n\nAll of the Ember.js conveniences are available for\nmodifying attributes. For example, you can use Ember.Object's\nincrementProperty helper:\n\n  1\n\n  person.incrementProperty('age'); // Happy birthday!\n\n\nPersisting Records\nRecords in Ember Data are persisted on a per-instance basis.\nCall save()\non any instance of Model and it will make a network request.\n\nEmber Data takes care of tracking the state of each record for\nyou. This allows Ember Data to treat newly created records differently\nfrom existing records when saving.\n\nBy default, Ember Data will POST newly created records to their type url.\n\n  1\n2\n3\n4\n5\n6\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\npost.save(); // =\u003e POST to '/posts'\n\n\n\nRecords that already exist on the backend are updated using the HTTP PATCH verb.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  store.findRecord('post', 1).then(function(post) {\n  post.get('title'); // =\u003e \"Rails is Omakase\"\n\n  post.set('title', 'A new post');\n\n  post.save(); // =\u003e PATCH to '/posts/1'\n});\n\n\n\nYou can tell if a record has outstanding changes that have not yet been\nsaved by checking its\nhasDirtyAttributes\nproperty. You can also see what parts of\nthe record were changed and what the original value was using the\nchangedAttributes()\nmethod. changedAttributes returns an object, whose keys are the changed\nproperties and values are an array of values [oldValue, newValue].\n\n  1\n2\n3\n4\n5\n\n  person.get('isAdmin');            //=\u003e false\nperson.get('hasDirtyAttributes'); //=\u003e false\nperson.set('isAdmin', true);\nperson.get('hasDirtyAttributes'); //=\u003e true\nperson.changedAttributes();       //=\u003e { isAdmin: [false, true] }\n\n\n\nAt this point, you can either persist your changes via save() or you can roll\nback your changes. Calling\nrollbackAttributes()\nfor a saved record reverts all the changedAttributes to their original value.\nIf the record isNew it will be removed from the store.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  person.get('hasDirtyAttributes'); //=\u003e true\nperson.changedAttributes();       //=\u003e { isAdmin: [false, true] }\n\nperson.rollbackAttributes();\n\nperson.get('hasDirtyAttributes'); //=\u003e false\nperson.get('isAdmin');            //=\u003e false\nperson.changedAttributes();       //=\u003e {}\n\n\nHandling Validation Errors\nIf the backend server returns validation errors after trying to save, they will\nbe available on the errors property of your model. Here's how you might display\nthe errors from saving a blog post in your template:\n\n  1\n2\n3\n4\n5\n6\n\n  {{#each post.errors.title as |error|}}\n  \u003cdiv class=\"error\"\u003e{{error.message}}\u003c/div\u003e\n{{/each}}\n{{#each post.errors.body as |error|}}\n  \u003cdiv class=\"error\"\u003e{{error.message}}\u003c/div\u003e\n{{/each}}\n\n\nPromises\nsave() returns\na promise, which makes easy to asynchronously handle success and failure \nscenarios.  Here's a common pattern:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nvar self = this;\n\nfunction transitionToPost(post) {\n  self.transitionToRoute('posts.show', post);\n}\n\nfunction failure(reason) {\n  // handle the error\n}\n\npost.save().then(transitionToPost).catch(failure);\n\n// =\u003e POST to '/posts'\n// =\u003e transitioning to posts.show route\n\n\nDeleting Records\nDeleting records is as straightforward as creating records. Call deleteRecord()\non any instance of Model. This flags the record as isDeleted. The \ndeletion can then be persisted using save().  Alternatively, you can use \nthe destroyRecord method to delete and persist at the same time.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  store.findRecord('post', 1).then(function(post) {\n  post.deleteRecord();\n  post.get('isDeleted'); // =\u003e true\n  post.save(); // =\u003e DELETE to /posts/1\n});\n\n// OR\nstore.findRecord('post', 2).then(function(post) {\n  post.destroyRecord(); // =\u003e DELETE to /posts/2\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c789ddb5644abcf443cde5398de5f989","fields":[{"name":"title","value":"Customizing Adapters","type":"string"},{"name":"url","value":"/models/customizing-adapters/","type":"enum"},{"name":"body","value":"In Ember Data, the Adapter determines how data is persisted to a\nbackend data store, such as the URL format and headers for a REST API.\n(The format of the data itself is determined by the\nserializer.)\nEmber Data's default Adapter has some built-in\nassumptions of how a REST API should look. If\nyour backend conventions differ from these assumptions Ember Data\nmakes it easy to change its functionality by swapping out or extending\nthe default Adapter.\n\nSome reasons for customizing an Adapter include using\nunderscores_case in your urls, using a medium other than REST to\ncommunicate with your backend API or even using a\nlocal storage backend.\n\nExtending Adapters is a natural process in Ember Data. Ember takes the\nposition that you should extend an adapter to add different\nfunctionality. This results in code that is\nmore testable, easier to understand and reduces bloat for people who\nmay want to subclass your adapter.\n\nIf your backend has some consistent rules you can define an\nadapter:application. The adapter:application will get priority over\nthe default Adapter, however it will still be superseded by model\nspecific Adapters.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import JSONAPIAdapter from 'ember-data/adapters/json-api';\n\nexport default JSONAPIAdapter.extend({\n  // Application specific overrides go here\n});\n\n\n\nIf you have one model that has exceptional rules for communicating\nwith its backend than the others you can create a Model specific\nAdapter by running the command ember generate adapter adapter-name.\nFor example, running ember generate adapter post will create the\nfollowing file:\n\n  \n    \n      app/adapters/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import JSONAPIAdapter from 'ember-data/adapters/json-api';\n\nexport default JSONAPIAdapter.extend({\n  namespace: 'api/v1'\n});\n\n\n\nBy default Ember Data comes with several built-in adapters. Feel free\nto use these adapters as a starting point for creating your own custom\nadapter.\n\n\nAdapter is the basic adapter\nwith no functionality. It is generally a good starting point if you\nwant to create an adapter that is radically different from the other\nEmber adapters.\nJSONAPIAdapter\nThe JSONAPIAdapter is the default adapter and follows JSON API\nconventions to communicate with an HTTP server by transmitting JSON\nvia XHR.\nRESTAdapter\nThe RESTAdapter allows your store to communicate with an HTTP server\nby transmitting JSON via XHR. Before Ember Data 2.0 this adapter was the default.\n\nCustomizing the JSONAPIAdapter\nThe\nJSONAPIAdapter\nhas a handful of hooks that are commonly used to extend it to work\nwith non-standard backends.\nURL Conventions\nThe JSONAPIAdapter is smart enough to determine the URLs it\ncommunicates with based on the name of the model. For example, if you\nask for a Post by ID:\n\n  1\n2\n\n  store.findRecord('post', 1).then(function(post) {\n});\n\n\n\nThe JSON API adapter will automatically send a GET request to /posts/1.\n\nThe actions you can take on a record map onto the following URLs in the\nJSON API adapter:\n\n\n  \n    ActionHTTP VerbURL\n  \n  \n    FindGET/posts/123\n    Find AllGET/posts\n    UpdatePATCH/posts/123\n    CreatePOST/posts\n    DeleteDELETE/posts/123\n  \n\nPluralization Customization\nTo facilitate pluralizing model names when generating route urls Ember\nData comes bundled with\nEmber Inflector, a\nActiveSupport::Inflector compatible library for inflecting words\nbetween plural and singular forms. Irregular or uncountable\npluralizations can be specified via Ember.Inflector.inflector.\nA common way to do this is:\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n\n  // sets up Ember.Inflector\nimport './models/custom-inflector-rules';\n\n\n\n  \n    \n      app/models/custom-inflector-rules.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import Inflector from 'ember-inflector';\n\nconst inflector = Inflector.inflector;\n\ninflector.irregular('formula', 'formulae');\ninflector.uncountable('advice');\n\n// Meet Ember Inspector's expectation of an export\nexport default {};\n\n\n\nThis will tell the JSON API adapter that requests for formula\nshould go to /formulae/1 instead of /formulas/1, and that\nrequests for advice should go to /advice/1 instead of /advices/1.\nEndpoint Path Customization\nThe namespace property can be used to prefix requests with a\nspecific url namespace.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import JSONAPIAdapter from 'ember-data/adapters/json-api';\n\nexport default JSONAPIAdapter.extend({\n  namespace: 'api/1'\n});\n\n\n\nRequests for person would now target http://emberjs.com/api/1/people/1.\nHost Customization\nBy default the adapter will target the current domain. If you would\nlike to specify a new domain you can do so by setting the host\nproperty on the adapter.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import JSONAPIAdapter from 'ember-data/adapters/json-api';\n\nexport default JSONAPIAdapter.extend({\n  host: 'https://api.example.com'\n});\n\n\n\nRequests for person would now target https://api.example.com/people/1.\nPath Customization\nBy default the JSONAPIAdapter will attempt to pluralize and dasherize\nthe model name to generate the path name. If this convention does not\nconform to your backend you can override the pathForType method.\n\nFor example, if you did not want to pluralize model names and needed\nunderscore_case instead of camelCase you could override the\npathForType method like this:\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import JSONAPIAdapter from 'ember-data/adapters/json-api';\n\nexport default JSONAPIAdapter.extend({\n  pathForType: function(type) {\n    return Ember.String.underscore(type);\n  }\n});\n\n\n\nRequests for person would now target /person/1.\nRequests for user-profile would now target /user_profile/1.\nHeaders customization\nSome APIs require HTTP headers, e.g. to provide an API key. Arbitrary\nheaders can be set as key/value pairs on the JSONAPIAdapter's headers\nobject and Ember Data will send them along with each ajax request.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  import JSONAPIAdapter from 'ember-data/adapters/json-api';\n\nexport default JSONAPIAdapter.extend({\n  headers: {\n    'API_KEY': 'secret key',\n    'ANOTHER_HEADER': 'Some header value'\n  }\n});\n\n\n\nheaders can also be used as a computed property to support dynamic\nheaders. In the example below, the headers are generated with a computed\nproperty dependent on the session service.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import JSONAPIAdapter from 'ember-data/adapters/json-api';\n\nexport default JSONAPIAdapter.extend({\n  session: Ember.inject.service('session'),\n  headers: Ember.computed('session.authToken', function() {\n    return {\n      'API_KEY': this.get('session.authToken'),\n      'ANOTHER_HEADER': 'Some header value'\n    };\n  })\n});\n\n\n\nIn some cases, your dynamic headers may require data from some\nobject outside of Ember's observer system (for example\ndocument.cookie). You can use the\nvolatile\nfunction to set the property into a non-cached mode causing the headers to\nbe recomputed with every request.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  import JSONAPIAdapter from 'ember-data/adapters/json-api';\n\nexport default JSONAPIAdapter.extend({\n  headers: Ember.computed(function() {\n    return {\n      'API_KEY': Ember.get(document.cookie.match(/apiKey\\=([^;]*)/), '1'),\n      'ANOTHER_HEADER': 'Some header value'\n    };\n  }).volatile()\n});\n\n\nAuthoring Adapters\nThe defaultSerializer property can be used to specify the serializer\nthat will be used by this adapter. This is only used when a model\nspecific serializer or serializer:application are not defined.\n\nIn an application, it is often easier to specify an\nserializer:application. However, if you are the author of a\ncommunity adapter it is important to remember to set this property to\nensure Ember does the right thing in the case a user of your adapter\ndoes not specify an serializer:application.\n\n  \n    \n      app/adapters/my-custom-adapter.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import JSONAPIAdapter from 'ember-data/adapters/json-api';\n\nexport default JSONAPIAdapter.extend({\n  defaultSerializer: '-default'\n});\n\n\nCommunity Adapters\nIf none of the built-in Ember Data Adapters work for your backend,\nbe sure to check out some of the community maintained Ember Data\nAdapters. Some good places to look for Ember Data Adapters include:\n\n\nEmber Observer\nGitHub\nBower\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8ccdb38204bead9bd7201fad99ebdf90","fields":[{"name":"title","value":"Customizing Serializers","type":"string"},{"name":"url","value":"/models/customizing-serializers/","type":"enum"},{"name":"body","value":"In Ember Data, serializers format the data sent to and received from\nthe backend store. By default, Ember Data serializes data using the\nJSON API format. If your backend uses a different\nformat, Ember Data allows you to customize the serializer or use a\ndifferent serializer entirely.\n\nEmber Data ships with 3 Serializers. The\nJSONAPISerializer\nis the default serializer and works with JSON API backends. The\nJSONSerializer\nis a simple serializer for working with single json object or arrays of records. The\nRESTSerializer\nis a more complex serializer that supports sideloading and was the default\nserializer before 2.0.\nJSONAPISerializer Conventions\nWhen requesting a record, the JSONAPISerializer expects your server\nto return a JSON representation of the record that conforms to the\nfollowing conventions.\nJSON API Document\nThe JSONAPI serializer expects the backend to return a JSON API\nDocument that follows the JSON API specification and the conventions\nof the examples found on http://jsonapi.org/format. This means all\ntype names should be pluralized and attribute and relationship names\nshould be dash-cased. For example, if you request a record from\n/people/123, the response should look like this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  {\n  \"data\": {\n    \"type\": \"people\",\n    \"id\": \"123\",\n    \"attributes\": {\n      \"first-name\": \"Jeff\",\n      \"last-name\": \"Atwood\"\n    }\n  }\n}\n\n\n\nA response that contains multiple records may have an array in its\ndata property.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  {\n  \"data\": [{\n    \"type\": \"people\",\n    \"id\": \"123\",\n    \"attributes\": {\n      \"first-name\": \"Jeff\",\n      \"last-name\": \"Atwood\"\n    }\n  }, {\n    \"type\": \"people\",\n    \"id\": \"124\",\n    \"attributes\": {\n      \"first-name\": \"Yehuda\",\n      \"last-name\": \"Katz\"\n    }\n  }]\n}\n\n\nSideloaded Data\nData that is not a part of the primary request but includes linked\nrelationships should be placed in an array under the included\nkey. For example, if you request /articles/1 and the backend also\nreturned any comments associated with that person the response\nshould look like this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n  {\n  \"data\": {\n    \"type\": \"articles\",\n    \"id\": \"1\",\n    \"attributes\": {\n      \"title\": \"JSON API paints my bikeshed!\"\n    },\n    \"links\": {\n      \"self\": \"http://example.com/articles/1\"\n    },\n    \"relationships\": {\n      \"comments\": {\n        \"data\": [\n          { \"type\": \"comments\", \"id\": \"5\" },\n          { \"type\": \"comments\", \"id\": \"12\" }\n        ]\n      }\n    }\n  },\n  \"included\": [{\n    \"type\": \"comments\",\n    \"id\": \"5\",\n    \"attributes\": {\n      \"body\": \"First!\"\n    },\n    \"links\": {\n      \"self\": \"http://example.com/comments/5\"\n    }\n  }, {\n    \"type\": \"comments\",\n    \"id\": \"12\",\n    \"attributes\": {\n      \"body\": \"I like XML better\"\n    },\n    \"links\": {\n      \"self\": \"http://example.com/comments/12\"\n    }\n  }]\n}\n\n\nCustomizing Serializers\nEmber Data uses the JSONAPISerializer by default, but you can\noverride this default by defining a custom serializer. There are two\nways to define a custom serializer. First, you can define a custom\nserializer for you entire application by defining an \"application\"\nserializer.\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n\n  import JSONSerializer from 'ember-data/serializers/json';\n\nexport default JSONSerializer.extend({});\n\n\n\nYou can also define serializer for a specific model. For example if\nyou had a post model you could also define a post serializer:\n\n  \n    \n      app/serializers/post.js\n    \n  \n\n  1\n2\n3\n\n  import JSONSerializer from 'ember-data/serializers/json';\n\nexport default JSONSerializer.extend({});\n\n\n\nTo change the format of the data that is sent to the backend store, you can use\nthe serialize()\nhook. Let's say that we have this JSON API response from Ember Data:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {\n  \"data\": {\n    \"attributes\": {\n      \"id\": \"1\",\n      \"name\": \"My Product\",\n      \"amount\": 100,\n      \"currency\": \"SEK\"\n    },\n    \"type\": \"product\"\n  }\n}\n\n\n\nBut our server expects data in this format:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  {\n  \"data\": {\n    \"attributes\": {\n      \"id\": \"1\",\n      \"name\": \"My Product\",\n      \"cost\": {\n        \"amount\": 100,\n        \"currency\": \"SEK\"\n      }\n    },\n    \"type\": \"product\"\n  }\n}\n\n\n\nHere's how you can change the data:\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  import JSONSerializer from 'ember-data/serializers/json';\n\nexport default JSONSerializer.extend({\n  serialize(snapshot, options) {\n    var json = this._super(...arguments);\n\n    json.data.attributes.cost = {\n      amount: json.data.attributes.amount,\n      currency: json.data.attributes.currency\n    };\n\n    delete json.data.attributes.amount;\n    delete json.data.attributes.currency;\n\n    return json;\n  },\n});\n\n\n\nSimilarly, if your backend store provides data in a format other than JSON API,\nyou can use the\nnormalizeResponse()\nhook. Using the same example as above, if the server provides data that looks\nlike:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  {\n  \"data\": {\n    \"attributes\": {\n      \"id\": \"1\",\n      \"name\": \"My Product\",\n      \"cost\": {\n        \"amount\": 100,\n        \"currency\": \"SEK\"\n      }\n    },\n    \"type\": \"product\"\n  }\n}\n\n\n\nAnd so we need to change it to look like:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {\n  \"data\": {\n    \"attributes\": {\n      \"id\": \"1\",\n      \"name\": \"My Product\",\n      \"amount\": 100,\n      \"currency\": \"SEK\"\n    },\n    \"type\": \"product\"\n  }\n}\n\n\n\nHere's how we could do it:\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  import JSONSerializer from 'ember-data/serializers/json';\n\nexport default JSONSerializer.extend({\n  normalizeResponse(store, primaryModelClass, payload, id, requestType) {\n    payload.data.attributes.amount = payload.data.attributes.cost.amount;\n    payload.data.attributes.currency = payload.data.attributes.cost.currency;\n\n    delete payload.data.attributes.cost;\n\n    return this._super(...arguments);\n  },\n});\n\n\n\nTo normalize only a single model, you can use the\nnormalize()\nhook similarly.\n\nFor more hooks to customize the serializer with, see the Ember Data serializer\nAPI documentation.\nIDs\nIn order to keep track of unique records in the store Ember Data\nexpects every record to have an id property in the payload. Ids\nshould be unique for every unique record of a specific type. If your\nbackend used a different key other then id you can use the\nserializer's primaryKey property to correctly transform the id\nproperty to id when serializing and deserializing data.\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import JSONSerializer from 'ember-data/serializers/json';\n\nexport default JSONSerializer.extend({\n  primaryKey: '_id'\n});\n\n\nAttribute Names\nIn Ember Data the convention is to camelize attribute names on a\nmodel. For example:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  firstName: attr('string'),\n  lastName:  attr('string'),\n  isPersonOfTheYear: attr('boolean')\n});\n\n\n\nHowever, the JSONAPISerializer expects attributes to be dasherized\nin the document payload returned by your server:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {\n  \"data\": {\n    \"id\": \"44\",\n    \"type\": \"people\",\n    \"attributes\": {\n      \"first-name\": \"Barack\",\n      \"last-name\": \"Obama\",\n      \"is-person-of-the-year\": true\n    }\n  }\n}\n\n\n\nIf the attributes returned by your server use a different convention\nyou can use the serializer's\nkeyForAttribute()\nmethod to convert an attribute name in your model to a key in your JSON\npayload. For example, if your backend returned attributes that are\nunder_scored instead of dash-cased you could override the keyForAttribute\nmethod like this.\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import JSONSerializer from 'ember-data/serializers/json';\n\nexport default JSONAPISerializer.extend({\n  keyForAttribute: function(attr) {\n    return Ember.String.underscore(attr);\n  }\n});\n\n\n\nIrregular keys can be mapped with a custom serializer. The attrs\nobject can be used to declare a simple mapping between property names\non Model records and payload keys in the serialized JSON object\nrepresenting the record. An object with the property key can also be\nused to designate the attribute's key on the response payload.\n\nIf the JSON for person has a key of lastNameOfPerson, and the\ndesired attribute name is simply lastName, then create a custom\nSerializer for the model and override the attrs property.\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  lastName: attr('string')\n});\n\n\n\n  \n    \n      app/serializers/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import JSONSerializer from 'ember-data/serializers/json';\n\nexport default JSONAPISerializer.extend({\n  attrs: {\n    lastName: 'lastNameOfPerson'\n  }\n});\n\n\nRelationships\nReferences to other records should be done by ID. For example, if you\nhave a model with a hasMany relationship:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { hasMany } from 'ember-data/relationships';\n\nexport default Model.extend({\n  comments: hasMany('comment', { async: true })\n});\n\n\n\nThe JSON should encode the relationship as an array of IDs and types:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  {\n  \"data\": {\n    \"type\": \"posts\",\n    \"id\": \"1\",\n    \"relationships\": {\n      \"comments\": {\n        \"data\": [\n          { \"type\": \"comments\", \"id\": \"5\" },\n          { \"type\": \"comments\", \"id\": \"12\" }\n        ]\n      }\n    }\n  }\n}\n\n\n\nComments for a post can be loaded by post.get('comments'). The\nJSON API adapter will send 3 GET requests to /comments/1/,\n/comments/2/ and /comments/3/.\n\nAny belongsTo relationships in the JSON representation should be the\ndasherized version of the property's name. For example, if you have\na model:\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { belongsTo } from 'ember-data/relationships'\n\nexport default Model.extend({\n  originalPost: belongsTo('post')\n});\n\n\n\nThe JSON should encode the relationship as an ID to another record:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {\n  \"data\": {\n    \"type\": \"comment\",\n    \"id\": \"1\",\n    \"relationships\": {\n      \"original-post\": {\n        \"data\": { \"type\": \"post\", \"id\": \"5\" },\n      }\n    }\n  }\n}\n\n\n\nIf needed these naming conventions can be overwritten by implementing\nthe\nkeyForRelationship()\nmethod.\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import JSONAPISerializer from 'ember-data/serializers/json-api';\n\nexport default JSONAPISerializer.extend({\n  keyForRelationship: function(key, relationship) {\n    return key + 'Ids';\n  }\n});\n\n\nCreating Custom Transformations\nIn some circumstances, the built in attribute types of string,\nnumber, boolean, and date may be inadequate. For example, a\nserver may return a non-standard date format.\n\nEmber Data can have new JSON transforms\nregistered for use as attributes:\n\n  \n    \n      app/transforms/coordinate-point.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  import Transform from 'ember-data/transform';\n\nexport default Transform.extend({\n  serialize: function(value) {\n    return [value.get('x'), value.get('y')];\n  },\n  deserialize: function(value) {\n    return Ember.Object.create({ x: value[0], y: value[1] });\n  }\n});\n\n\n\n  \n    \n      app/models/cursor.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  position: attr('coordinate-point')\n});\n\n\n\nWhen coordinatePoint is received from the API, it is\nexpected to be an array:\n\n  1\n2\n3\n4\n5\n\n  {\n  cursor: {\n    position: [4,9]\n  }\n}\n\n\n\nBut once loaded on a model instance, it will behave as an object:\n\n  1\n2\n3\n\n  var cursor = store.findRecord('cursor', 1);\ncursor.get('position.x'); //=\u003e 4\ncursor.get('position.y'); //=\u003e 9\n\n\n\nIf position is modified and saved, it will pass through the\nserialize function in the transform and again be presented as\nan array in JSON.\nJSONSerializer\nNot all APIs follow the conventions that the JSONAPISerializer uses\nwith a data namespace and sideloaded relationship records. Some\nlegacy APIs may return a simple JSON payload that is just the requested\nresource or an array of serialized records. The JSONSerializer is a\nserializer that ships with Ember Data that can be used along side the\nRESTAdapter to serialize these simpler APIs.\n\nTo use it in your application you will need to define an\nserializer:application that extends the JSONSerializer.\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import JSONSerializer from 'ember-data/serializers/json';\n\nexport default JSONSerializer.extend({\n  // ...\n});\n\n\n\nFor requests that are only expected to return 1 record\n(e.g. store.findRecord('post', 1)) the JSONSerializer expects the response\nto be a JSON object that looks similar to this:\n\n  1\n2\n3\n4\n5\n6\n\n  {\n    \"id\": \"1\",\n    \"title\": \"Rails is omakase\",\n    \"tag\": \"rails\",\n    \"comments\": [\"1\", \"2\"]\n}\n\n\n\nFor requests that are only expected to return 0 or more records\n(e.g. store.findAll('post') or store.query('post', { filter: { status: 'draft' } }))\nthe JSONSerializer expects the response to be a JSON array that\nlooks similar to this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  [{\n  \"id\": \"1\",\n  \"title\": \"Rails is omakase\",\n  \"tag\": \"rails\",\n  \"comments\": [\"1\", \"2\"]\n}, {\n  \"id\": \"2\",\n  \"title\": \"I'm Running to Reform the W3C's Tag\",\n  \"tag\": \"w3c\",\n  \"comments\": [\"3\"]\n}]\n\n\n\nThe JSONAPISerializer is built on top of the JSONSerializer so they share\nmany of the same hooks for customizing the behavior of the\nserialization process. Be sure to check out the\nAPI docs\nfor a full list of methods and properties.\nEmbeddedRecordMixin\nAlthough Ember Data encourages you to sideload your relationships,\nsometimes when working with legacy APIs you may discover you need to\ndeal with JSON that contains relationships embedded inside other\nrecords. The EmbeddedRecordsMixin is meant to help with this problem.\n\nTo set up embedded records, include the mixin when extending a\nserializer then define and configure embedded relationships.\n\nFor example if your post model contained an embedded author record\nthat looks similar to this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {\n    \"id\": \"1\",\n    \"title\": \"Rails is omakase\",\n    \"tag\": \"rails\",\n    \"authors\": [\n        {\n            \"id\": \"2\",\n            \"name\": \"Steve\"\n        }\n    ]\n}\n\n\n\nYou would define your relationship like this:\n\n  \n    \n      app/serializers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import JSONSerializer from 'ember-data/serializers/json';\nimport EmbeddedRecordsMixin from 'ember-data/serializers/embedded-records-mixin';\n\nexport default JSONSerializer.extend(EmbeddedRecordsMixin, {\n  attrs: {\n    authors: {\n      serialize: 'records',\n      deserialize: 'records'\n    }\n  }\n});\n\n\n\nIf you find yourself needing to both serialize and deserialize the\nembedded relationship you can use the shorthand option of { embedded:\n'always' }. The following example and the one above are equivalent.\n\n  \n    \n      app/serializers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  import JSONSerializer from 'ember-data/serializers/json';\nimport EmbeddedRecordsMixin from 'ember-data/serializers/embedded-records-mixin';\n\nexport default JSONSerializer.extend(EmbeddedRecordsMixin, {\n  attrs: {\n    authors: { embedded: 'always' }\n  }\n});\n\n\n\nThe serialize and deserialize keys support 3 options.\n- records is used to signal that the entire record is expected\n- ids is used to signal that only the id of the record is expected\n- false is used to signal that the record is not expected\n\nFor example you may find that you want to read an embedded record when\nextracting a JSON payload but only include the relationship's id when\nserializing the record. This is possible by using the serialize:\n'ids' option. You can also opt out of serializing a relationship by\nsetting serialize: false.\n\n  \n    \n      app/serializers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  import JSONSerializer from 'ember-data/serializers/json';\nimport EmbeddedRecordsMixin from 'ember-data/serializers/embedded-records-mixin';\n\nexport default JSONSerializer.extend(EmbeddedRecordsMixin, {\n  attrs: {\n    author: {\n      serialize: false,\n      deserialize: 'records'\n    },\n    comments: {\n      deserialize: 'records',\n      serialize: 'ids'\n    }\n  }\n});\n\n\nEmbeddedRecordsMixin Defaults\nIf you do not overwrite attrs for a specific relationship, the\nEmbeddedRecordsMixin will behave in the following way:\n\nBelongsTo: { serialize: 'id', deserialize: 'id' }\nHasMany:   { serialize: false, deserialize: 'ids' }\n\nThere is an option of not embedding JSON in the serialized payload by\nusing serialize: 'ids'. If you do not want the relationship sent at\nall, you can use serialize: false.\nAuthoring Serializers\nIf you would like to create a custom serializer its recommend that you\nstart with the JSONAPISerializer or JSONSerializer and extend one of\nthose to match your needs. However, if your payload is extremely\ndifferent from one of these serializers you can create your own by\nextending the Serializer base class. There are 3 methods that\nmust be implemented on a serializer.\n\n\nnormalizeResponse\nserialize\nnormalize\n\n\nIts also important to know about the normalized JSON form that Ember\nData expects as an argument to store.push().\n\nstore.push accepts a JSON API document. However, unlike the\nJSONAPISerializer, store.push does not do any transformation of the\nrecord's type name or attributes. It is important to make sure that\nthe type name matches the name of the file where it is defined\nexactly. Also attribute and relationship names in the JSON API\ndocument should match the name and casing of the attribute and\nrelationship properties on the Model.\n\nFor Example: given this post model.\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\nimport { hasMany } from 'ember-data/relationships';\n\nexport default Model.extend({\n  title: attr('string'),\n  tag: attr('string'),\n  comments: hasMany('comment', { async: false }),\n  relatedPosts: hasMany('post')\n});\n\n\n\nstore.push would accept an object that looked like this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  {\n  data: {\n    id: \"1\",\n    type: 'post',\n    attributes: {\n      title: \"Rails is omakase\",\n      tag: \"rails\",\n    },\n    relationships: {\n      comments: {\n        data: [{ id: \"1\", type: 'comment' },\n               { id: \"2\", type: 'comment' }],\n      },\n      relatedPosts: {\n        data: {\n          related: \"/api/v1/posts/1/related-posts/\"\n        }\n      }\n    }\n}\n\n\n\nEvery serialized record must follow this format for it to be correctly\nconverted into an Ember Data record.\n\nProperties that are defined on the model but are omitted in the\nnormalized JSON API document object will not be updated. Properties\nthat are included in the normalized JSON API document object but not\ndefined on the Model will be ignored.\nCommunity Serializers\nIf none of the built-in Ember Data Serializers work for your backend,\nbe sure to check out some of the community maintained Ember Data\nAdapters and Serializers. A good place to search for them is Ember Observer.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"03e86bc5333f6f64b9e95b540f952f9d","fields":[{"name":"title","value":"Defining Models","type":"string"},{"name":"url","value":"/models/defining-models/","type":"enum"},{"name":"body","value":"A model is a class that defines the properties and behavior of the\ndata that you present to the user. Anything that the user expects to see\nif they leave your app and come back later (or if they refresh the page)\nshould be represented by a model.\n\nWhen you want a new model for your application you need to create a new file\nunder the models folder and extend from Model. This is more conveniently\ndone by using one of Ember CLI's generator commands. For instance, let's create\na person model:\n\n  1\n\n  ember generate model person\n\n\n\nThis will generate the following file:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n\n  import Model from 'ember-data/model';\n\nexport default Model.extend({\n});\n\n\n\nAfter you have defined a model class, you can start finding\nand working with records of that type.\nDefining Attributes\nThe person model we generated earlier didn't have any attributes. Let's\nadd first and last name, as well as the birthday, using attr:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  firstName: attr(),\n  lastName: attr(),\n  birthday: attr()\n});\n\n\n\nAttributes are used when turning the JSON payload returned from your\nserver into a record, and when serializing a record to save back to the\nserver after it has been modified.\n\nYou can use attributes like any other property, including as part of a\ncomputed property. Frequently, you will want to define computed\nproperties that combine or transform primitive attributes.\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  firstName: attr(),\n  lastName: attr(),\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  })\n});\n\n\n\nFor more about adding computed properties to your classes, see Computed\nProperties.\nTransforms\nYou may find the type of an attribute returned by the server does not\nmatch the type you would like to use in your JavaScript code. Ember\nData allows you to define simple serialization and deserialization\nmethods for attribute types called transforms. You can specify that\nyou would like a transform to run for an attribute by providing the\ntransform name as the first argument to the attr method. Ember Data\nsupports attribute types of string, number, boolean, and date,\nwhich coerce the value to the JavaScript type that matches its name.\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  name: attr('string'),\n  age: attr('number'),\n  admin: attr('boolean'),\n  birthday: attr('date')\n});\n\n\n\nThe date transform will transform an\nISO 8601 string to a JavaScript\ndate object.\n\nThe boolean transform can handle values other than true or\nfalse. The strings \"true\" or \"t\" in any casing, \"1\", and the number\n1 will all coerce to true, and false otherwise.\n\nTransforms are not required. If you do not specify a transform name\nEmber Data will do no additional processing of the value.\nCustom Transforms\nYou can also create custom transforms with Ember CLI's transform generator:\n\n  1\n\n  ember generate transform dollars\n\n\n\nHere is a simple transform that converts values between cents and US dollars.\n\n  \n    \n      app/transforms/dollars.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import Transform from 'ember-data/transform';\n\nexport default Transform.extend({\n  deserialize: function(serialized) {\n    return serialized / 100; // returns dollars\n  },\n\n  serialize: function(deserialized) {\n    return deserialized * 100; // returns cents\n  }\n});\n\n\n\nA transform has two functions: serialize and deserialize. Deserialization\nconverts a value to a format that the client expects. Serialization does the\nreverse and converts a value to the format expected by the persistence layer.\n\nYou would use the custom dollars transform like this:\n\n  \n    \n      app/models/product.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  spent: attr('dollars')\n});\n\n\nOptions\nattr can also take a hash of options as a second parameter. At the moment\nthe only option available is defaultValue, which can use a value or a function\nto set the default value of the attribute if one is not supplied.\n\nIn the following example we define that verified has a default value of\nfalse and createdAt defaults to the current date at the time of the model's\ncreation:\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  username: attr('string'),\n  email: attr('string'),\n  verified: attr('boolean', { defaultValue: false }),\n  createdAt: attr('date', {\n    defaultValue() { return new Date(); }\n  })\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"54352571d5fd6e786972f119be9dcf80","fields":[{"name":"title","value":"Finding Records","type":"string"},{"name":"url","value":"/models/finding-records/","type":"enum"},{"name":"body","value":"The Ember Data store provides an interface for retrieving records of a single\ntype.\nRetrieving a Single Record\nUse store.findRecord()\nto retrieve a record by its type and ID. This will return a promise that\nfulfills with the requested record:\n\n  1\n\n  var post = this.store.findRecord('post', 1); // =\u003e GET /posts/1\n\n\n\nUse store.peekRecord()\nto retrieve a record by its type and ID, without making a network request.\nThis will return the record only if it is already present in the store:\n\n  1\n\n  var post = this.store.peekRecord('post', 1); // =\u003e no network request\n\n\nRetrieving Multiple Records\nUse store.findAll()\nto retrieve all of the records for a given type:\n\n  1\n\n  var posts = this.store.findAll('post'); // =\u003e GET /posts\n\n\n\nUse store.peekAll()\nto retrieve all of the records for a given type that are already loaded into \nthe store, without making a network request:\n\n  1\n\n  var posts = this.store.peekAll('post'); // =\u003e no network request\n\n\n\nstore.findAll() returns a PromiseArray that fulfills to a\nRecordArray and store.peekAll directly returns a RecordArray.\n\nIt's important to note that RecordArray is not a JavaScript array.  It is\nan object that implements Ember.Enumerable. This is important because,\nfor example, if you want to retrieve records by index, the [] notation will\nnot work--you'll have to use objectAt(index) instead.\nQuerying for Multiple Records\nEmber Data provides the ability to query for records that meet certain criteria. Calling\nstore.query()\nwill make a GET request with the passed object serialized as query params. This method returns\na PromiseArray in the same way as find.\n\nFor example, we could search for all person models who have the name of\nPeter:\n\n  1\n2\n3\n4\n\n  // GET to /persons?filter[name]=Peter\nthis.store.query('person', { filter: { name: 'Peter' } }).then(function(peters) {\n  // Do something with `peters`\n});\n\n\nQuerying for A Single Record\nIf you know your query will return only one result Ember Data provides\na convenience method that will return a promise that resolves with a\nsingle record. Calling\nstore.queryRecord()\nwill make a GET request with the passed object serialized as query params.\n\nFor example, if we know that an email uniquely identifies a person, we could search for a person model that has an email address of\ntomster@example.com:\n\n  1\n2\n3\n4\n\n  // GET to /persons?filter[email]=tomster@example.com\nthis.store.queryRecord('person', { filter: { email: 'tomster@example.com' } }).then(function(tomster) {\n  // do something with `tomster`\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"aaa673b0a07a7fad8549b3be79862344","fields":[{"name":"title","value":"Handling Metadata","type":"string"},{"name":"url","value":"/models/handling-metadata/","type":"enum"},{"name":"body","value":"Along with the records returned from your store, you'll likely need to handle some kind of metadata. Metadata is data that goes along with a specific model or type instead of a record.\n\nPagination is a common example of using metadata. Imagine a blog with far more posts than you can display at once. You might query it like so:\n\n  1\n2\n3\n4\n\n  let result = this.store.query('post', {\n  limit: 10,\n  offset: 0\n});\n\n\n\nTo get different pages of data, you'd simply change your offset in increments of 10. So far, so good. But how do you know how many pages of data you have? Your server would need to return the total number of records as a piece of metadata.\n\nEach serializer will expect the metadata to be returned differently. For example, Ember Data's JSON deserializer looks for a meta key:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  {\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Progressive Enhancement is Dead\",\n    \"comments\": [\"1\", \"2\"],\n    \"links\": {\n      \"user\": \"/people/tomdale\"\n    },\n    // ...\n  },\n\n  \"meta\": {\n    \"total\": 100\n  }\n}\n\n\n\nRegardless of the serializer used, this metadata is extracted from the response. You can then read it with .get('meta').\n\nThis can be done on the result of a store.query() call:\n\n  1\n2\n3\n\n  store.query('post').then((result) =\u003e {\n  let meta = result.get('meta');\n})\n\n\n\nOn a belongsTo relationship:\n\n  1\n2\n3\n4\n5\n\n  let post = store.peekRecord('post', 1);\n\npost.get('author').then((author) =\u003e {\n  let meta = author.get('meta');\n});\n\n\n\nOr on a hasMany relationship:\n\n  1\n2\n3\n4\n5\n\n  let post = store.peekRecord('post', 1);\n\npost.get('comments').then((comments) =\u003e {\n  let meta = comments.get('meta');\n});\n\n\n\nAfter reading it, meta.total can be used to calculate how many pages of posts you'll have.\n\nTo customize metadata extraction, check out the documentation for your serializer.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f6824ed2e6c9f37fc0a6d7f987afee17","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/models/","type":"enum"},{"name":"body","value":"Models are objects that represent the underlying data that your\napplication presents to the user. Different apps will have very\ndifferent models, depending on what problems they're trying to solve.\n\nFor example, a photo sharing application might have a Photo\nmodel to represent a particular photo, and a PhotoAlbum that\nrepresents a group of photos. In contrast, an online shopping app would\nprobably have different models, like ShoppingCart, Invoice, or\nLineItem.\n\nModels tend to be persistent. That means the user does not expect\nmodel data to be lost when they close their browser window. To make sure\nno data is lost, if the user makes changes to a model, you need to store\nthe model data somewhere that it will not be lost.\n\nTypically, most models are loaded from and saved to a server that uses a\ndatabase to store data. Usually you will send JSON representations of\nmodels back and forth to an HTTP server that you have written. However,\nEmber makes it easy to use other durable storage, such as saving to the\nuser's hard disk with IndexedDB, or hosted storage solutions that let you\navoid writing and hosting your own servers.\n\nOnce you've loaded your models from storage, components know how to\ntranslate model data into a UI that your user can interact with.  For\nmore information about how components get model data, see the\nSpecifying a Route's Model\nguide.\n\nEmber Data, included by default when you create a new application, is a\nlibrary that integrates tightly with Ember to make it easy to retrieve\nmodels from your server as JSON, save updates back to the server, and\ncreate new models in the browser.\n\nThanks to its use of the adapter pattern, Ember Data can be configured\nto work with many different kinds of backends. There is an entire\necosystem of adapters that allow your Ember app to talk to different\ntypes of servers without you writing any networking code.\n\nIf you need to integrate your Ember.js app with a server that does not\nhave an adapter available (for example, you hand-rolled an API server\nthat does not adhere to any JSON specification), Ember Data is designed\nto be configurable to work with whatever data your server returns.\n\nEmber Data is also designed to work with streaming servers, like those\npowered by WebSockets. You can open a socket to your server and push\nchanges into Ember Data whenever they occur, giving your app a real-time\nuser interface that is always up-to-date.\n\nAt first, using Ember Data may feel different than the way you're used\nto writing JavaScript applications. Many developers are familiar with\nusing AJAX to fetch raw JSON data from an endpoint, which may appear\neasy at first. Over time, however, complexity leaks out into your\napplication code, making it hard to maintain.\n\nWith Ember Data, managing models as your application grows becomes both\nsimple and easy.\n\nOnce you have an understanding of Ember Data, you will have a much\nbetter way to manage the complexity of data loading in your application.\nThis will allow your code to evolve without becoming a mess.\nThe Store and a Single Source of Truth\nOne common way of building web applications is to tightly couple user\ninterface elements to data fetching. For example, imagine you are\nwriting the admin section of a blogging app, which has a feature that\nlists the drafts for the currently logged in user.\n\nYou might be tempted to make the component responsible for fetching that\ndata and storing it:\n\n  \n    \n      app/components/list-of-drafts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  willRender() {\n    $.getJSON('/drafts').then(data =\u003e {\n      this.set('drafts', data);\n    });\n  }\n});\n\n\n\nYou could then show the list of drafts in your component's template like\nthis:\n\n  \n    \n      app/templates/components/list-of-drafts.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each drafts key=\"id\" as |draft|}}\n    \u003cli\u003e{{draft.title}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nThis works great for the list-of-drafts component. However, your app\nis likely made up of many different components. On another page you\nmay want a component to display the number of drafts. You may be\ntempted to copy and paste your existing willRender code into the new\ncomponent.\n\n  \n    \n      app/components/drafts-button.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  willRender() {\n    $.getJSON('/drafts').then(data =\u003e {\n      this.set('drafts', data);\n    });\n  }\n});\n\n\n\n  \n    \n      app/templates/components/drafts-button.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#link-to 'drafts' tagName=\"button\"}}\nDrafts ({{drafts.length}})\n{{/link-to}}\n\n\n\nUnfortunately, the app will now make two separate requests for the\nsame information. Not only is the redundant data fetching costly in\nterms of wasted bandwidth and affecting the perceived speed of your\napp, it's easy for the two values to get out-of-sync. You yourself\nhave probably used a web application where the list of items gets out\nof sync with the counter in a toolbar, leading to a frustrating and\ninconsistent experience.\n\nThere is also a tight coupling between your application's UI and the\nnetwork code. If the url or the format of the JSON payload changes, it\nis likely to break all of your UI components in ways that are hard to\ntrack down.\n\nThe SOLID principles of good design tell us that objects should have a\nsingle responsibility. The responsibility of a component should be\npresenting model data to the user, not fetching the model.\n\nGood Ember apps take a different approach. Ember Data gives you a single\nstore that is the central repository of models in your application.\nComponents and routes can ask the store for models, and the store is\nresponsible for knowing how to fetch them.\n\nIt also means that the store can detect that two different components\nare asking for the same model, allowing your app to only fetch the data\nfrom the server once. You can think of the store as a read-through cache\nfor your app's models. Both your components and routes have access to\nthis shared store; when they need to display or modify a model, they\nfirst ask the store for it.\nConvention Over Configuration with JSON API\nYou can significantly reduce the amount of code you need to write and\nmaintain by relying on Ember's conventions. Since these conventions\nwill be shared among developers on your team, following them leads\nto code that is easier to maintain and understand.\n\nRather than create an arbitrary set of conventions, Ember Data is\ndesigned to work out of the box with JSON API. JSON API is a\nformal specification for building conventional, robust, and performant\nAPIs that allow clients and servers to communicate model data.\n\nJSON API standardizes how JavaScript applications talk to servers, so\nyou decrease the coupling between your frontend and backend, and have\nmore freedom to change pieces of your stack.\n\nAs an analogy, JSON API is to JavaScript apps and API servers what SQL is\nto server-side frameworks and databases. Popular frameworks like Ruby on\nRails, Laravel, Django, Spring and more work out of the box with many\ndifferent databases, like MySQL, PostgreSQL, SQL Server, and more.\n\nFrameworks (or apps built on those frameworks) don't need to write\nlots of custom code to add support for a new database; as long as that\ndatabase supports SQL, adding support for it is relatively easy.\n\nSo too with JSON API. By using JSON API to interop between your Ember\napp and your server, you can entirely change your backend stack without\nbreaking your frontend. And as you add apps for other platforms, such as\niOS and Android, you will be able to leverage JSON API libraries for\nthose platforms to easily consume the same API your Ember app uses.\nModels\nIn Ember Data, each model is represented by a subclass of Model that\ndefines the attributes, relationships, and behavior of the data that you\npresent to the user.\n\nModels define the type of data that will be provided by your server. For\nexample, a Person model might have a firstName attribute that is a\nstring, and a birthday attribute that is a date:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  firstName: attr('string'),\n  birthday:  attr('date')\n});\n\n\n\nA model also describes its relationships with other objects. For\nexample, an order may have many line-items, and a\nline-item may belong to a particular order.\n\n  \n    \n      app/models/order.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { hasMany } from 'ember-data/relationships';\n\nexport default Model.extend({\n  lineItems: hasMany('line-item')\n});\n\n\n\n  \n    \n      app/models/line-item.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { belongsTo } from 'ember-data/relationships';\n\nexport default Model.extend({\n  order: belongsTo('order')\n});\n\n\n\nModels don't have any data themselves, they define the attributes,\nrelationships and behavior of specific instances, which are called\nrecords.\nRecords\nA record is an instance of a model that contains data loaded from a\nserver. Your application can also create new records and save them back\nto the server.\n\nA record is uniquely identified by its model type and ID.\n\nFor example, if you were writing a contact management app, you might\nhave a Person model. An individual record in your app might\nhave a type of person and an ID of 1 or steve-buscemi.\n\n  1\n\n  this.store.findRecord('person', 1); // =\u003e { id: 1, name: 'steve-buscemi' }\n\n\n\nAn ID is usually assigned to a record by the server when you save it for\nthe first time, but you can also generate IDs client-side.\nAdapter\nAn adapter is an object that translates requests from Ember (such as\n\"find the user with an ID of 123\") into requests to a server.\n\nFor example, if your application asks for a Person with an ID of\n123, how should Ember load it? Over HTTP or a WebSocket?  If\nit's HTTP, is the URL /person/1 or /resources/people/1?\n\nThe adapter is responsible for answering all of these questions.\nWhenever your app asks the store for a record that it doesn't have\ncached, it will ask the adapter for it. If you change a record and save\nit, the store will hand the record to the adapter to send the\nappropriate data to your server and confirm that the save was\nsuccessful.\n\nAdapters let you completely change how your API is implemented without\nimpacting your Ember application code.\nCaching\nThe store will automatically cache records for you. If a record had already\nbeen loaded, asking for it a second time will always return the same\nobject instance. This minimizes the number of round-trips to the\nserver, and allows your application to render its UI to the user as fast as\npossible.\n\nFor example, the first time your application asks the store for a\nperson record with an ID of 1, it will fetch that information from\nyour server.\n\nHowever, the next time your app asks for a person with ID 1, the\nstore will notice that it had already retrieved and cached that\ninformation from the server. Instead of sending another request for the\nsame information, it will give your application the same record it had\nprovided it the first time.  This feature—always returning the same\nrecord object, no matter how many times you look it up—is sometimes\ncalled an identity map.\n\nUsing an identity map is important because it ensures that changes you\nmake in one part of your UI are propagated to other parts of the UI. It\nalso means that you don't have to manually keep records in sync—you can\nask for a record by ID and not have to worry about whether other parts\nof your application have already asked for and loaded it.\n\nOne downside to returning a cached record is you may find the state of\nthe data has changed since it was first loaded into the store's\nidentity map. In order to prevent this stale data from being a problem\nfor long, Ember Data will automatically make a request in the\nbackground each time a cached record is returned from the store. When\nthe new data comes in, the record is updated, and if there have been\nchanges to the record since the initial render, the template is\nre-rendered with the new information.\nArchitecture Overview\nThe first time your application asks the store for a record, the store\nsees that it doesn't have a local copy and requests it from your\nadapter. Your adapter will go and retrieve the record from your\npersistence layer; typically, this will be a JSON representation of the\nrecord served from an HTTP server.\n\n\n\nAs illustrated in the diagram above, the adapter cannot always return the\nrequested record immediately. In this case, the adapter must make an\nasynchronous request to the server, and only when that request finishes\nloading can the record be created with its backing data.\n\nBecause of this asynchronicity, the store immediately returns a\npromise from the find() method. Similarly, any requests that the\nstore makes to the adapter also return promises.\n\nOnce the request to the server returns with a JSON payload for the\nrequested record, the adapter resolves the promise it returned to the\nstore with the JSON.\n\nThe store then takes that JSON, initializes the record with the\nJSON data, and resolves the promise returned to your application\nwith the newly-loaded record.\n\n\n\nLet's look at what happens if you request a record that the store\nalready has in its cache.\n\n\n\nIn this case, because the store already knew about the record, it\nreturns a promise that it resolves with the record immediately. It does\nnot need to ask the adapter (and, therefore, the server) for a copy\nsince it already has it saved locally.\n\n\n\nModels, records, adapters and the store are the core concepts you\nshould understand to get the most out of Ember Data. The following\nsections go into more depth about each of these concepts, and how to\nuse them together.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0638f122b19f3ca7e20eca12d526a2e6","fields":[{"name":"title","value":"Pushing Records into the Store","type":"string"},{"name":"url","value":"/models/pushing-records-into-the-store/","type":"enum"},{"name":"body","value":"One way to think about the store is as a cache of all of the records\nthat have been loaded by your application. If a route or a controller in\nyour app asks for a record, the store can return it immediately if it is\nin the cache. Otherwise, the store must ask the adapter to load it,\nwhich usually means a trip over the network to retrieve it from the\nserver.\n\nInstead of waiting for the app to request a record, however, you can\npush records into the store's cache ahead of time.\n\nThis is useful if you have a good sense of what records the user\nwill need next. When they click on a link, instead of waiting for a\nnetwork request to finish, Ember.js can render the new template\nimmediately. It feels instantaneous.\n\nAnother use case for pushing in records is if your application has a\nstreaming connection to a backend. If a record is created or modified,\nyou want to update the UI immediately.\nPushing Records\nTo push a record into the store, call the store's push() method.\n\nFor example, imagine we want to preload some data into the store when\nthe application boots for the first time.\n\nWe can use the route:application to do so. The route:application is\nthe top-most route in the route hierarchy, and its model hook gets\ncalled once when the app starts up.\n\n  \n    \n      app/models/album.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  title: attr(),\n  artist: attr(),\n  songCount: attr()\n});\n\n\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n  export default Ember.Route.extend({\n  model() {\n    this.store.push({\n      data: [{\n        id: 1,\n        type: 'album',\n        attributes: {\n          title: 'Fewer Moving Parts',\n          artist: 'David Bazan',\n          songCount: 10\n        },\n        relationships: {}\n      }, {\n        id: 2,\n        type: 'album',\n        attributes: {\n          title: 'Calgary b/w I Can\\'t Make You Love Me/Nick Of Time',\n          artist: 'Bon Iver',\n          songCount: 2\n        },\n        relationships: {}\n      }]\n    });\n  }\n});\n\n\n\nThe store's push() method is a low level API which accepts a JSON\nAPI document with a few important differences from the JSON API\ndocument that the JSONAPISerializer accepts. The type name in the JSON\nAPI document must match the type name of the model exactly (In the\nexample above the type is album because the model is defined in\napp/models/album.js). Attributes and relationship names must match\nthe casing of the properties defined on the Model class.\n\nIf you would like the data to be normalized by the model's default\nserializer before pushing it into the store, you can use the\nstore.pushPayload() method.\n\n  \n    \n      app/serializers/album.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  import RestSerializer from 'ember-data/serializers/rest';\n\nexport default RestSerializer.extend({\n  normalize(typeHash, hash) {\n    hash['songCount'] = hash['song_count']\n    delete hash['song_count']\n    return this._super(typeHash, hash);\n  }\n\n})\n\n\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  export default Ember.Route.extend({\n  model() {\n    this.store.pushPayload({\n      albums: [\n        {\n          id: 1,\n          title: 'Fever Moving Parts',\n          artist: 'David Bazan',\n          song_count: 10\n        },\n        {\n          id: 2,\n          title: 'Calgary b/w I Can\\'t Make You Love Me/Nick Of Time',\n          artist: 'Bon Iver',\n          song_count: 2\n        }\n      ]\n    });\n  }\n});\n\n\n\nThe push() method is also important when working with complex\nendpoints. You may find your application has an endpoint that performs\nsome business logic then creates several records. This likely does not\nmap cleanly to Ember Data's existing save() API which is structured\naround persisting a single record. Instead you should make your own\ncustom AJAX request and push the resulting model data into the store\nso it can be accessed by other parts of your application.\n\n  \n    \n      app/routes/confirm-payment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Route.extend({\n  actions: {\n    confirm: function(data) {\n      $.ajax({\n        data: data,\n        method: 'POST',\n        url: 'process-payment'\n      }).then((digitalInventory) =\u003e {\n        this.store.pushPayload(digitalInventory);\n        this.transitionTo('thank-you');\n      });\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"82a089886cafe37c95c4e3e558bd0d33","fields":[{"name":"title","value":"Relationships","type":"string"},{"name":"url","value":"/models/relationships/","type":"enum"},{"name":"body","value":"Ember Data includes several built-in relationship types to help you\ndefine how your models relate to each other.\nOne-to-One\nTo declare a one-to-one relationship between two models, use\nbelongsTo:\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { belongsTo } from 'ember-data/relationships';\n\nexport default Model.extend({\n  profile: belongsTo('profile')\n});\n\n\n\n  \n    \n      app/models/profile.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { belongsTo } from 'ember-data/relationships';\n\nexport default Model.extend({\n  user: belongsTo('user')\n});\n\n\nOne-to-Many\nTo declare a one-to-many relationship between two models, use\nbelongsTo in combination with hasMany, like this:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { hasMany } from 'ember-data/relationships';\n\nexport default Model.extend({\n  comments: hasMany('comment')\n});\n\n\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { belongsTo } from 'ember-data/relationships';\n\nexport default Model.extend({\n  post: belongsTo('post')\n});\n\n\nMany-to-Many\nTo declare a many-to-many relationship between two models, use\nhasMany:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { hasMany } from 'ember-data/relationships';\n\nexport default Model.extend({\n  tags: hasMany('tag')\n});\n\n\n\n  \n    \n      app/models/tag.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { hasMany } from 'ember-data/relationships';\n\nexport default Model.extend({\n  posts: hasMany('post')\n});\n\n\nExplicit Inverses\nEmber Data will do its best to discover which relationships map to one\nanother. In the one-to-many code above, for example, Ember Data can figure out that\nchanging the comments relationship should update the post\nrelationship on the inverse because post is the only relationship to\nthat model.\n\nHowever, sometimes you may have multiple belongsTo/hasManys for\nthe same type. You can specify which property on the related model is\nthe inverse using belongsTo or hasMany's inverse\noption. Relationships without an inverse can be indicated as such by\nincluding { inverse: null }.\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import Model from 'ember-data/model';\nimport { belongsTo } from 'ember-data/relationships';\n\nexport default Model.extend({\n  onePost: belongsTo('post', { inverse: null }),\n  twoPost: belongsTo('post'),\n  redPost: belongsTo('post'),\n  bluePost: belongsTo('post')\n});\n\n\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  import Model from 'ember-data/model';\nimport { hasMany } from 'ember-data/relationships';\n\nexport default Model.extend({\n  comments: hasMany('comment', {\n    inverse: 'redPost'\n  })\n});\n\n\nReflexive Relations\nWhen you want to define a reflexive relation (a model that has a relationship to\nitself), you must explicitly define the inverse relationship. If there\nis no inverse relationship then you can set the inverse to null.\n\nHere's an example of a one-to-many reflexive relationship:\n\n  \n    \n      app/models/folder.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import Model from 'ember-data/model';\nimport { belongsTo, hasMany } from 'ember-data/relationships';\n\nexport default Model.extend({\n  children: hasMany('folder', { inverse: 'parent' }),\n  parent: belongsTo('folder', { inverse: 'children' })\n});\n\n\n\nHere's an example of a one-to-one reflexive relationship:\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\nimport { belongsTo } from 'ember-data/relationships';\n\nexport default Model.extend({\n  name: attr('string'),\n  bestFriend: belongsTo('user', { inverse: 'bestFriend' }),\n});\n\n\n\nYou can also define a reflexive relationship that doesn't have an inverse:\n\n  \n    \n      app/models/folder.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { belongsTo } from 'ember-data/relationships';\n\nexport default Model.extend({\n  parent: belongsTo('folder', { inverse: null })\n});\n\n\nReadonly Nested Data\nSome models may have properties that are deeply nested objects of\nreadonly data. The naïve solution would be to define models for each\nnested object and use hasMany and belongsTo to recreate the nested\nrelationship. However, since readonly data will never need to be\nupdated and saved this often results in the creation of a great deal\nof code for very little benefit. An alternate approach is to define\nthese relationships using an attribute with no transform\n(attr()). This makes it easy to access readonly values in\ncomputed properties and templates without the overhead of defining\nextraneous models.\nCreating Records\nLet's assume that we have a post and a comment model, which are related to each other as follows:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { hasMany } from 'ember-data/relationships';\n\nexport default Model.extend({\n  comments: hasMany('comment')\n});\n\n\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { belongsTo } from 'ember-data/relationships';\n\nexport default Model.extend({\n  post: belongsTo('post')\n});\n\n\n\nWhen a user comments on a post, we need to create a relationship between the two records. We can simply set the belongsTo relationship in our new comment:\n\n  1\n2\n3\n4\n5\n\n  let post = this.store.peekRecord('post', 1);\nlet comment = this.store.createRecord('comment', {\n  post: post\n});\ncomment.save();\n\n\n\nThis will create a new comment record and save it to the server. Ember Data will also update the post to include our newly created comment in its comments relationship.\n\nWe could have also linked the two records together by updating the post's hasMany relationship:\n\n  1\n2\n3\n4\n5\n\n  let post = this.store.peekRecord('post', 1);\nlet comment = this.store.createRecord('comment', {\n});\npost.get('comments').pushObject(comment);\ncomment.save();\n\n\n\nIn this case the new comment's belongsTo relationship will be set to the parent post.\n\nAlthough createRecord is fairly straightforward, the only thing to watch out for\nis that you cannot assign a promise as a relationship, currently.\n\nFor example, if you want to set the author property of a post, this would not work\nif the user with id isn't already loaded into the store:\n\n  1\n2\n3\n4\n5\n\n  this.store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum',\n  author: this.store.findRecord('user', 1)\n});\n\n\n\nHowever, you can easily set the relationship after the promise has fulfilled:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  let post = this.store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nthis.store.findRecord('user', 1).then(function(user) {\n  post.set('author', user);\n});\n\n\nUpdating Existing Records\nSometimes we want to set relationships on already existing records. We can simply set a belongsTo relationship:\n\n  1\n2\n3\n4\n\n  let post = this.store.peekRecord('post', 1);\nlet comment = this.store.peekRecord('comment', 1);\ncomment.set('post', post);\ncomment.save();\n\n\n\nAlternatively, we could update the hasMany relationship by pushing a record into the relationship:\n\n  1\n2\n3\n4\n\n  let post = this.store.peekRecord('post', 1);\nlet comment = this.store.peekRecord('comment', 1);\npost.get('comments').pushObject(comment);\npost.save();\n\n\nRemoving Relationships\nTo remove a belongsTo relationship, we can set it to null, which will also remove it from the hasMany side:\n\n  1\n2\n3\n\n  let comment = this.store.peekRecord('comment', 1);\ncomment.set('post', null);\ncomment.save();\n\n\n\nIt is also possible to remove a record from a hasMany relationship:\n\n  1\n2\n3\n4\n\n  let post = this.store.peekRecord('post', 1);\nlet comment = this.store.peekRecord('comment', 1);\npost.get('comments').removeObject(comment);\npost.save();\n\n\n\nAs in the earlier examples, the comment's belongsTo relationship will also be cleared by Ember Data.\nRelationships as Promises\nWhile working with relationships it is important to remember that they return promises.\n\nFor example, if we were to work on a post's asynchronous comments, we would have to wait until the promise has fulfilled:\n\n  1\n2\n3\n4\n5\n\n  let post = this.store.peekRecord('post', 1);\n\npost.get('comments').then((comments) =\u003e {\n  // now we can work with the comments\n});\n\n\n\nThe same applies to belongsTo relationships:\n\n  1\n2\n3\n4\n5\n\n  let comment = this.store.peekRecord('comment', 1);\n\ncomment.get('post').then((post) =\u003e {\n  // the post is available here\n});\n\n\n\nHandlebars templates will automatically be updated to reflect a resolved promise. We can display a list of comments in a post like so:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each post.comments as |comment|}}\n    \u003cli\u003e{{comment.id}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nEmber Data will query the server for the appropriate records and re-render the template once the data is received.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7bdaf101518cf52ad2c7b8a7eb71a128","fields":[{"name":"title","value":"Bindings","type":"string"},{"name":"url","value":"/object-model/bindings/","type":"enum"},{"name":"body","value":"Unlike most other frameworks that include some sort of binding implementation,\nbindings in Ember.js can be used with any object. That said, bindings are most\noften used within the Ember framework itself, and for most problems Ember app\ndevelopers face, computed properties are the appropriate solution.\n\nThe easiest way to create a two-way binding is to use a computed.alias(),\nthat specifies the path to another object.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  wife = Ember.Object.create({\n  householdIncome: 80000\n});\n\nHusband = Ember.Object.extend({\n  householdIncome: Ember.computed.alias('wife.householdIncome')\n});\n\nhusband = Husband.create({\n  wife: wife\n});\n\nhusband.get('householdIncome'); // 80000\n\n// Someone gets raise.\nwife.set('householdIncome', 90000);\nhusband.get('householdIncome'); // 90000\n\n\n\nNote that bindings don't update immediately. Ember waits until all of your\napplication code has finished running before synchronizing changes, so you can\nchange a bound property as many times as you'd like without worrying about the\noverhead of syncing bindings when values are transient.\nOne-Way Bindings\nA one-way binding only propagates changes in one direction, using\ncomputed.oneWay(). Often, one-way bindings are a performance \noptimization and you can safely use a two-way binding (which are de facto one-way bindings if you only ever change one side).\nSometimes one-way bindings are useful to achieve specific behaviour such as a\ndefault that is the same as another property but can be overridden (e.g. a\nshipping address that starts the same as a billing address but can later be \nchanged)\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  user = Ember.Object.create({\n  fullName: 'Kara Gates'\n});\n\nUserComponent = Ember.Component.extend({\n  userName: Ember.computed.oneWay('user.fullName')\n});\n\nuserComponent = UserComponent.create({\n  user: user\n});\n\n// Changing the name of the user object changes\n// the value on the view.\nuser.set('fullName', 'Krang Gates');\n// userComponent.userName will become \"Krang Gates\"\n\n// ...but changes to the view don't make it back to\n// the object.\nuserComponent.set('userName', 'Truckasaurus Gates');\nuser.get('fullName'); // \"Krang Gates\"\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4eb2fcd4e32d72e009d1c1d9fdceee41","fields":[{"name":"title","value":"Classes and Instances","type":"string"},{"name":"url","value":"/object-model/classes-and-instances/","type":"enum"},{"name":"body","value":"As you learn about Ember, you'll see code like Ember.Component.extend() and\nModel.extend(). Here, you'll learn about this extend() method, as well\nas other major features of the Ember object model.\nDefining Classes\nTo define a new Ember class, call the extend() method on\nEmber.Object:\n\n  1\n2\n3\n4\n5\n\n  Person = Ember.Object.extend({\n  say(thing) {\n    alert(thing);\n  }\n});\n\n\n\nThis defines a new Person class with a say() method.\n\nYou can also create a subclass from any existing class by calling\nits extend() method. For example, you might want to create a subclass\nof Ember's built-in Ember.Component class:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isUrgent'],\n  isUrgent: true\n});\n\n\nOverriding Parent Class Methods\nWhen defining a subclass, you can override methods but still access the\nimplementation of your parent class by calling the special _super()\nmethod:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  Person = Ember.Object.extend({\n  say(thing) {\n    var name = this.get('name');\n    alert(`${name} says: ${thing}`);\n  }\n});\n\nSoldier = Person.extend({\n  say(thing) {\n    // this will call the method in the parent class (Person#say), appending\n    // the string ', sir!' to the variable `thing` passed in\n    this._super(`${thing}, sir!`);\n  }\n});\n\nvar yehuda = Soldier.create({\n  name: 'Yehuda Katz'\n});\n\nyehuda.say('Yes'); // alerts \"Yehuda Katz says: Yes, sir!\"\n\n\n\nIn certain cases, you will want to pass arguments to _super() before or after overriding.\n\nThis allows the original method to continue operating as it normally would.\n\nOne common example is when overriding the normalizeResponse() hook in one of Ember-Data's serializers.\n\nA handy shortcut for this is to use a \"spread operator\", like ...arguments:\n\n  1\n2\n3\n4\n\n  normalizeResponse(store, primaryModelClass, payload, id, requestType)  {\n  // Customize my JSON payload for Ember-Data\n  return this._super(...arguments);\n}\n\n\n\nThe above example returns the original arguments (after your customizations) back to the parent class, so it can continue with its normal operations.\nCreating Instances\nOnce you have defined a class, you can create new instances of that\nclass by calling its create() method. Any methods, properties and\ncomputed properties you defined on the class will be available to\ninstances:\n\n  1\n2\n\n  var person = Person.create();\nperson.say('Hello'); // alerts \" says: Hello\"\n\n\n\nWhen creating an instance, you can initialize the values of its properties\nby passing an optional hash to the create() method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  Person = Ember.Object.extend({\n  helloWorld() {\n    alert(`Hi, my name is ${this.get('name')}`);\n  }\n});\n\nvar tom = Person.create({\n  name: 'Tom Dale'\n});\n\ntom.helloWorld(); // alerts \"Hi, my name is Tom Dale\"\n\n\n\nNote that for performance reasons, while calling create() you cannot redefine an instance's\ncomputed properties and should not redefine existing or define new methods. You should only set simple properties when calling\ncreate(). If you need to define or redefine methods or computed\nproperties, create a new subclass and instantiate that.\n\nBy convention, properties or variables that hold classes are\nPascalCased, while instances are not. So, for example, the variable\nPerson would point to a class, while person would point to an instance\n(usually of the Person class). You should stick to these naming\nconventions in your Ember applications.\nInitializing Instances\nWhen a new instance is created, its init() method is invoked\nautomatically. This is the ideal place to implement setup required on new\ninstances:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  Person = Ember.Object.extend({\n  init() {\n    var name = this.get('name');\n    alert(`${name}, reporting for duty!`);\n  }\n});\n\nPerson.create({\n  name: 'Stefan Penner'\n});\n\n// alerts \"Stefan Penner, reporting for duty!\"\n\n\n\nIf you are subclassing a framework class, like Ember.Component, and you\noverride the init() method, make sure you call this._super(...arguments)!\nIf you don't, a parent class may not have an opportunity to do important\nsetup work, and you'll see strange behavior in your application.\n\nArrays and objects defined directly on any Ember.Object are shared across all instances of that object.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  Person = Ember.Object.extend({\n  shoppingList: ['eggs', 'cheese']\n});\n\nPerson.create({\n  name: 'Stefan Penner',\n  addItem() {\n    this.get('shoppingList').pushObject('bacon');\n  }\n});\n\nPerson.create({\n  name: 'Robert Jackson',\n  addItem() {\n    this.get('shoppingList').pushObject('sausage');\n  }\n});\n\n// Stefan and Robert both trigger their addItem.\n// They both end up with: ['eggs', 'cheese', 'bacon', 'sausage']\n\n\n\nTo avoid this behavior, it is encouraged to initialize those arrays and object properties during init(). Doing so ensures each instance will be unique.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n  Person = Ember.Object.extend({\n  init() {\n    this.set('shoppingList', ['eggs', 'cheese']);\n  }\n});\n\nPerson.create({\n  name: 'Stefan Penner',\n  addItem() {\n    this.get('shoppingList').pushObject('bacon');\n  }\n});\n\nPerson.create({\n  name: 'Robert Jackson',\n  addItem() {\n    this.get('shoppingList').pushObject('sausage');\n  }\n});\n\n// Stefan ['eggs', 'cheese', 'bacon']\n// Robert ['eggs', 'cheese', 'sausage']\n\n\nAccessing Object Properties\nWhen accessing the properties of an object, use the get()\nand set() accessor methods:\n\n  1\n2\n3\n4\n\n  var person = Person.create();\n\nvar name = person.get('name');\nperson.set('name', 'Tobias Fünke');\n\n\n\nMake sure to use these accessor methods; otherwise, computed properties won't\nrecalculate, observers won't fire, and templates won't update.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e959824557e508bda4cb824e0466f1ac","fields":[{"name":"title","value":"Computed Properties and Aggregate Data","type":"string"},{"name":"url","value":"/object-model/computed-properties-and-aggregate-data/","type":"enum"},{"name":"body","value":"Sometimes you have a computed property whose value depends on the properties of \nitems in an array. For example, you may have an array of todo items, and want\nto calculate how many remain incomplete based on their isDone property.\n\nTo facilitate this, Ember provides the @each key illustrated below:\n\n  \n    \n      app/components/todos.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Component.extend({\n  todos: [\n    Ember.Object.create({ isDone: true }),\n    Ember.Object.create({ isDone: false }),\n    Ember.Object.create({ isDone: true })\n  ],\n\n  remaining: Ember.computed('todos.@each.isDone', function() {\n    var todos = this.get('todos');\n    return todos.filterBy('isDone', false).get('length');\n  })\n});\n\n\n\nHere, the dependent key todos.@each.isDone instructs Ember.js to update bindings \nand fire observers when any of the following events occurs: \n\n\nThe isDone property of any of the objects in the todos array changes.\nAn item is added to the todos array.\nAn item is removed from the todos array.\nThe todos property of the component is changed to a different array.\n\n\nEmber also provides a computed property macro\ncomputed.filterBy,\nwhich is a shorter way of expressing the above computed property:\n\n  \n    \n      app/components/todos.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Component.extend({\n  todos: [\n    Ember.Object.create({ isDone: true }),\n    Ember.Object.create({ isDone: false }),\n    Ember.Object.create({ isDone: true })\n  ],\n\n  remaining: Ember.computed.filterBy('todos', 'isDone', false)\n});\n\n\n\nIn both of the examples above, the remaining count is 1:\n\n  1\n2\n3\n4\n5\n\n  import TodosComponent from 'app/components/todos';\n\nlet todosComponent = TodosComponent.create();\ntodosComponent.get('remaining');\n// 1\n\n\n\nIf we change the todo's isDone property, the remaining property is updated\nautomatically:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  let todos = todosComponent.get('todos');\nlet todo = todos.objectAt(1);\ntodo.set('isDone', true);\n\ntodosComponent.get('remaining');\n// 0\n\ntodo = Ember.Object.create({ isDone: false });\ntodos.pushObject(todo);\n\ntodosComponent.get('remaining');\n// 1\n\n\n\nNote that @each only works one level deep. You cannot use nested forms like\ntodos.@each.owner.name or todos.@each.owner.@each.name.\n\nSometimes you don't care if properties of individual array items change. In this\ncase use the [] key instead of @each. Computed properties dependent on an array\nusing the [] key will only update if items are added to or removed from the array,\nor if the array property is set to a different array. For example:\n\n  \n    \n      app/components/todos.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Component.extend({\n  todos: [\n    Ember.Object.create({ isDone: true }),\n    Ember.Object.create({ isDone: false }),\n    Ember.Object.create({ isDone: true })\n  ],\n\n  selectedTodo: null,\n  indexOfSelectedTodo: Ember.computed('selectedTodo', 'todos.[]', function() {\n    return this.get('todos').indexOf(this.get('selectedTodo'));\n  })\n});\n\n\n\nHere, indexOfSelectedTodo depends on todos.[], so it will update if we add an item\nto todos, but won't update if the value of isDone on a todo changes.\n\nSeveral of the Ember.computed macros \nutilize the [] key to implement common use-cases. For instance, to\ncreate a computed property that mapped properties from an array, you could use \nEmber.computed.map\nor build the computed property yourself:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  const Hamster = Ember.Object.extend({\n  excitingChores: Ember.computed('chores.[]', function() {\n    return this.get('chores').map(function(chore, index) {\n      return `CHORE ${index}: ${chore.toUpperCase()}!`;\n    });\n  })\n});\n\nconst hamster = Hamster.create({\n  chores: ['clean', 'write more unit tests']\n});\n\nhamster.get('excitingChores'); // ['CHORE 1: CLEAN!', 'CHORE 2: WRITE MORE UNIT TESTS!']\nhamster.get('chores').pushObject('review code');\nhamster.get('excitingChores'); // ['CHORE 1: CLEAN!', 'CHORE 2: WRITE MORE UNIT TESTS!', 'CHORE 3: REVIEW CODE!']\n\n\n\nBy comparison, using the computed macro abstracts some of this away:\n\n  1\n2\n3\n4\n5\n\n  const Hamster = Ember.Object.extend({\n  excitingChores: Ember.computed.map('chores', function(chore, index) {\n    return `CHORE ${index}: ${chore.toUpperCase()}!`;\n  })\n});\n\n\n\nThe computed macros expect you to use an array, so there is no need to use the\n[] key in these cases. However, building your own custom computed property\nrequires you to tell Ember.js that it is watching for array changes, which is\nwhere the [] key comes in handy.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a26ec310640ced8b722a53a9ac4a703a","fields":[{"name":"title","value":"Computed Properties","type":"string"},{"name":"url","value":"/object-model/computed-properties/","type":"enum"},{"name":"body","value":"What are Computed Properties?\nIn a nutshell, computed properties let you declare functions as properties. You create one by defining a computed property as a function, which Ember will automatically call when you ask for the property. You can then use it the same way you would any normal, static property.\n\nIt's super handy for taking one or more normal properties and transforming or manipulating their data to create a new value.\nComputed properties in action\nWe'll start with a simple example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  })\n});\n\nvar ironMan = Person.create({\n  firstName: 'Tony',\n  lastName:  'Stark'\n});\n\nironMan.get('fullName'); // \"Tony Stark\"\n\n\n\nThis declares the function to be a computed property, and the arguments tell Ember that it depends on the firstName and lastName attributes.\n\nWhenever you access the fullName property, this function gets called, and it returns the value of the function, which simply calls firstName + lastName.\n\nWhen you want to depend on a property which belongs to an object, you can setup multiple dependent keys by using brace expansion:\n\n  1\n2\n3\n4\n5\n6\n\n  var obj = Ember.Object.extend({\n  baz: {foo: 'BLAMMO', bar: 'BLAZORZ'},\n\n  something: Ember.computed('baz.{foo, bar}', function() {\n    return this.get('baz.foo') + ' ' + this.get('baz.bar');\n  })\n\n\n\nThis allows you to observe both foo and bar on baz with much less duplication/redundancy\nwhen your dependent keys are mostly similar.\nChaining computed properties\nYou can use computed properties as values to create new computed properties. Let's add a description computed property to the previous example, and use the existing fullName property and add in some other properties:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  Person = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n  age: null,\n  country: null,\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  }),\n\n  description: Ember.computed('fullName', 'age', 'country', function() {\n    return `${this.get('fullName')}; Age: ${this.get('age')}; Country: ${this.get('country')}`;\n  })\n});\n\nvar captainAmerica = Person.create({\n  firstName: 'Steve',\n  lastName: 'Rogers',\n  age: 80,\n  country: 'USA'\n});\n\ncaptainAmerica.get('description'); // \"Steve Rogers; Age: 80; Country: USA\"\n\n\nDynamic updating\nComputed properties, by default, observe any changes made to the properties they depend on and are dynamically updated when they're called. Let's use computed properties to dynamically update.\n\n  1\n2\n3\n\n  captainAmerica.set('firstName', 'William');\n\ncaptainAmerica.get('description'); // \"William Rogers; Age: 80; Country: USA\"\n\n\n\nSo this change to firstName was observed by fullName computed property, which was itself observed by the description property.\n\nSetting any dependent property will propagate changes through any computed properties that depend on them, all the way down the chain of computed properties you've created.\nSetting Computed Properties\nYou can also define what Ember should do when setting a computed property. If you try to set a computed property, it will be invoked with the key (property name), and the value you want to set it to.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n  Person = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n\n  fullName: Ember.computed('firstName', 'lastName', {\n    get(key) {\n      return `${this.get('firstName')} ${this.get('lastName')}`;\n    },\n    set(key, value) {\n      var [firstName, lastName] = value.split(/\\s+/);\n      this.set('firstName', firstName);\n      this.set('lastName',  lastName);\n      return value;\n    }\n  })\n});\n\n\nvar captainAmerica = Person.create();\ncaptainAmerica.set('fullName', 'William Burnside');\ncaptainAmerica.get('firstName'); // William\ncaptainAmerica.get('lastName'); // Burnside\n\n\nComputed property macros\nSome types of computed properties are very common. Ember provides a number of\ncomputed property macros, which are shorter ways of expressing certain types\nof computed property.\n\nIn this example, the two computed properties are equivalent:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Person = Ember.Object.extend({\n  fullName: 'Tony Stark',\n\n  isIronManLongWay: Ember.computed('fullName', function() {\n    return this.get('fullName') === 'Tony Stark';\n  }),\n\n  isIronManShortWay: Ember.computed.equal('fullName', 'Tony Stark')\n});\n\n\n\nTo see the full list of computed property macros, have a look at\nthe API documentation\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"27baf1b906842ce32a37f5fd551f1e91","fields":[{"name":"title","value":"Enumerables","type":"string"},{"name":"url","value":"/object-model/enumerables/","type":"enum"},{"name":"body","value":"In Ember.js, an enumerable is any object that contains a number of child\nobjects, and which allows you to work with those children using the\nEmber.Enumerable API. The most common\nenumerable in the majority of apps is the native JavaScript array, which\nEmber.js extends to conform to the enumerable interface.\n\nBy providing a standardized interface for dealing with enumerables,\nEmber.js allows you to completely change the way your underlying data is\nstored without having to modify the other parts of your application that\naccess it.\n\nThe enumerable API follows ECMAScript specifications as much as\npossible. This minimizes incompatibility with other libraries, and\nallows Ember.js to use the native browser implementations in arrays\nwhere available.\nUse of Observable Methods and Properties\nIn order for Ember to observe when you make a change to an enumerable, you need\nto use special methods that Ember.Enumerable provides. For example, if you add\nan element to an array using the standard JavaScript method push(), Ember will\nnot be able to observe the change, but if you use the enumerable method\npushObject(), the change will propagate throughout your application.\n\nHere is a list of standard JavaScript array methods and their observable\nenumerable equivalents:\n\n\n  \n    Standard MethodObservable Equivalent\n  \n  \n    poppopObject\n    pushpushObject\n    reversereverseObjects\n    shiftshiftObject\n    unshiftunshiftObject\n  \n\n\nAdditionally, to retrieve the first and last objects in an array\nin an observable fashion, you should use myArray.get('firstObject') and\nmyArray.get('lastObject'), respectively.\nAPI Overview\nIn the rest of this guide, we'll explore some of the most common enumerable\nconveniences. For the full list, please see the Ember.Enumerable API\nreference documentation.\nIterating Over an Enumerable\nTo enumerate all the values of an enumerable object, use the forEach()\nmethod:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var food = ['Poi', 'Ono', 'Adobo Chicken'];\n\nfood.forEach(function(item, index) {\n  console.log(`Menu Item ${index+1}: ${item}`);\n});\n\n// Menu Item 1: Poi\n// Menu Item 2: Ono\n// Menu Item 3: Adobo Chicken\n\n\nFirst and Last Objects\nAll enumerables expose firstObject and lastObject properties\nthat you can bind to.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var animals = ['rooster', 'pig'];\n\nanimals.get('lastObject');\n//=\u003e \"pig\"\n\nanimals.pushObject('peacock');\n\nanimals.get('lastObject');\n//=\u003e \"peacock\"\n\n\nMap\nYou can easily transform each item in an enumerable using the\nmap() method, which creates a new array with results of calling a\nfunction on each item in the enumerable.\n\n  1\n2\n3\n4\n5\n6\n\n  var words = ['goodbye', 'cruel', 'world'];\n\nvar emphaticWords = words.map(function(item) {\n  return item + '!';\n});\n// [\"goodbye!\", \"cruel!\", \"world!\"]\n\n\n\nIf your enumerable is composed of objects, there is a mapBy()\nmethod that will extract the named property from each of those objects\nin turn and return a new array:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  var hawaii = Ember.Object.create({\n  capital: 'Honolulu'\n});\n\nvar california = Ember.Object.create({\n  capital: 'Sacramento'\n});\n\nvar states = [hawaii, california];\n\nstates.mapBy('capital');\n//=\u003e [\"Honolulu\", \"Sacramento\"]\n\n\nFiltering\nAnother common task to perform on an enumerable is to take the\nenumerable as input, and return an Array after filtering it based on\nsome criteria.\n\nFor arbitrary filtering, use the filter() method.  The filter method\nexpects the callback to return true if Ember should include it in the\nfinal Array, and false or undefined if Ember should not.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var arr = [1,2,3,4,5];\n\narr.filter(function(item, index, self) {\n  return item \u003c 4;\n});\n\n// returns [1,2,3]\n\n\n\nWhen working with a collection of Ember objects, you will often want to filter a set of objects based upon the value of some property. The filterBy() method provides a shortcut.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  Todo = Ember.Object.extend({\n  title: null,\n  isDone: false\n});\n\ntodos = [\n  Todo.create({ title: 'Write code', isDone: true }),\n  Todo.create({ title: 'Go to sleep' })\n];\n\ntodos.filterBy('isDone', true);\n\n// returns an Array containing only items with `isDone == true`\n\n\n\nIf you only want to return the first matched value, rather than an Array\ncontaining all of the matched values, you can use find() and findBy(),\nwhich work like filter() and filterBy(), but return only one item.\nAggregate Information (Every or Any)\nTo find out whether every item in an enumerable matches some condition, you can\nuse the every() method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  Person = Ember.Object.extend({\n  name: null,\n  isHappy: false\n});\n\nvar people = [\n  Person.create({ name: 'Yehuda', isHappy: true }),\n  Person.create({ name: 'Majd', isHappy: false })\n];\n\npeople.every(function(person, index, self) {\n  return person.get('isHappy');\n});\n\n// returns false\n\n\n\nTo find out whether at least one item in an enumerable matches some condition,\nyou can use the any() method:\n\n  1\n2\n3\n4\n5\n\n  people.any(function(person, index, self) {\n  return person.get('isHappy');\n});\n\n// returns true\n\n\n\nLike the filtering methods, the every() and any() methods have \nanalogous isEvery() and isAny() methods.\n\n  1\n2\n\n  people.isEvery('isHappy', true); // false\npeople.isAny('isHappy', true);  // true\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"37d5aab7c9ab79a19b719afbe3ad536b","fields":[{"name":"title","value":"Objects in Ember","type":"string"},{"name":"url","value":"/object-model/","type":"enum"},{"name":"body","value":"You'll notice standard JavaScript class patterns and the new ES2015\nclasses aren't widely used in Ember. Plain objects can still be found,\nand sometimes they're referred to as \"hashes\".\n\nJavaScript objects don't support the observation of property value changes.\nConsequently, if an object is going to participate in Ember's binding\nsystem you may see an Ember.Object instead of a plain object.\n\nEmber.Object also provides a class system, supporting features like mixins\nand constructor methods. Some features in Ember's object model are not present in\nJavaScript classes or common patterns, but all are aligned as much as possible\nwith the language and proposed additions.\n\nEmber also extends the JavaScript Array prototype with its\nEmber.Enumerable interface to provide change observation for arrays.\n\nFinally, Ember extends the String prototype with a few formatting and\nlocalization methods.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2899adf50b491f36747129255557b93d","fields":[{"name":"title","value":"Observers","type":"string"},{"name":"url","value":"/object-model/observers/","type":"enum"},{"name":"body","value":"Ember supports observing any property, including computed properties.\n\nObservers should contain behavior that reacts to changes in another property.\nObservers are especially useful when you need to perform some behavior after a\nbinding has finished synchronizing.\n\nObservers are often over-used by new Ember developers. Observers are used\nheavily within the Ember framework itself, but for most problems Ember app\ndevelopers face, computed properties are the appropriate solution.\n\nYou can set up an observer on an object by using Ember.observer:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  }),\n\n  fullNameChanged: Ember.observer('fullName', function() {\n    // deal with the change\n    console.log(`fullName changed to: ${this.get('fullName')}`);\n  })\n});\n\nvar person = Person.create({\n  firstName: 'Yehuda',\n  lastName: 'Katz'\n});\n\n// observer won't fire until `fullName` is consumed first\nperson.get('fullName'); // \"Yehuda Katz\"\nperson.set('firstName', 'Brohuda'); // fullName changed to: Brohuda Katz\n\n\n\nBecause the fullName computed property depends on firstName,\nupdating firstName will fire observers on fullName as well.\nObservers and asynchrony\nObservers in Ember are currently synchronous. This means that they will fire\nas soon as one of the properties they observe changes. Because of this, it\nis easy to introduce bugs where properties are not yet synchronized:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Person.reopen({\n  lastNameChanged: Ember.observer('lastName', function() {\n    // The observer depends on lastName and so does fullName. Because observers\n    // are synchronous, when this function is called the value of fullName is\n    // not updated yet so this will log the old value of fullName\n    console.log(this.get('fullName'));\n  })\n});\n\n\n\nThis synchronous behavior can also lead to observers being fired multiple\ntimes when observing multiple properties:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Person.reopen({\n  partOfNameChanged: Ember.observer('firstName', 'lastName', function() {\n    // Because both firstName and lastName were set, this observer will fire twice.\n  })\n});\n\nperson.set('firstName', 'John');\nperson.set('lastName', 'Smith');\n\n\n\nTo get around these problems, you should make use of Ember.run.once().\nThis will ensure that any processing you need to do only happens once, and\nhappens in the next run loop once all bindings are synchronized:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  Person.reopen({\n  partOfNameChanged: Ember.observer('firstName', 'lastName', function() {\n    Ember.run.once(this, 'processFullName');\n  }),\n\n  processFullName() {\n    // This will only fire once if you set two properties at the same time, and\n    // will also happen in the next run loop once all properties are synchronized\n    console.log(this.get('fullName'));\n  }\n});\n\nperson.set('firstName', 'John');\nperson.set('lastName', 'Smith');\n\n\nObservers and object initialization\nObservers never fire until after the initialization of an object is complete.\n\nIf you need an observer to fire as part of the initialization process, you\ncannot rely on the side effect of set. Instead, specify that the observer\nshould also run after init by using Ember.on():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Person = Ember.Object.extend({\n  init() {\n    this.set('salutation', 'Mr/Ms');\n  },\n\n  salutationDidChange: Ember.on('init', Ember.observer('salutation', function() {\n    // some side effect of salutation changing\n  }))\n});\n\n\nUnconsumed Computed Properties Do Not Trigger Observers\nIf you never get() a computed property, its observers will not fire even if\nits dependent keys change. You can think of the value changing from one unknown\nvalue to another.\n\nThis doesn't usually affect application code because computed properties are\nalmost always observed at the same time as they are fetched. For example, you get\nthe value of a computed property, put it in DOM (or draw it with D3), and then\nobserve it so you can update the DOM once the property changes.\n\nIf you need to observe a computed property but aren't currently retrieving it,\nget it in your init() method.\nOutside of class definitions\nYou can also add observers to an object outside of a class definition\nusing addObserver():\n\n  1\n2\n3\n\n  person.addObserver('fullName', function() {\n  // deal with the change\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f8ecff8837ebc62045275db96d37ff19","fields":[{"name":"title","value":"Reopening Classes and Instances","type":"string"},{"name":"url","value":"/object-model/reopening-classes-and-instances/","type":"enum"},{"name":"body","value":"You don't need to define a class all at once. You can reopen a class and\ndefine new properties using the reopen() method.\n\n  1\n2\n3\n4\n5\n\n  Person.reopen({\n  isPerson: true\n});\n\nPerson.create().get('isPerson'); // true\n\n\n\nWhen using reopen(), you can also override existing methods and\ncall this._super.\n\n  1\n2\n3\n4\n5\n6\n\n  Person.reopen({\n  // override `say` to add an ! at the end\n  say(thing) {\n    this._super(thing + '!');\n  }\n});\n\n\n\nreopen() is used to add instance methods and properties that are shared \nacross all instances of a class. It does not add\nmethods and properties to a particular instance of a class as in vanilla JavaScript (without using prototype).\n\nBut when you need to add static methods or static properties to the class itself\nyou can use reopenClass().\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  // add static property to class\nPerson.reopenClass({\n  isPerson: false\n});\n// override property of Person instance\nPerson.reopen({\n  isPerson: true\n});\n\nPerson.isPerson; // false - because it is static property created by `reopenClass`\nPerson.create().get('isPerson'); // true\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2e1967ab300f10bb0db8e074948cdccf","fields":[{"name":"title","value":"Asynchronous Routing","type":"string"},{"name":"url","value":"/routing/asynchronous-routing/","type":"enum"},{"name":"body","value":"This section covers some more advanced features of the router and its\ncapability for handling complex async logic within your app.\nA Word on Promises...\nEmber's approach to handling asynchronous logic in the router makes\nheavy use of the concept of Promises. In short, promises are objects that\nrepresent an eventual value. A promise can either fulfill\n(successfully resolve the value) or reject (fail to resolve the\nvalue). The way to retrieve this eventual value, or handle the cases\nwhen the promise rejects, is via the promise's then() method, which\naccepts two optional callbacks, one for fulfillment and one for\nrejection. If the promise fulfills, the fulfillment handler gets called\nwith the fulfilled value as its sole argument, and if the promise rejects,\nthe rejection handler gets called with a reason for the rejection as its\nsole argument. For example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  var promise = fetchTheAnswer();\n\npromise.then(fulfill, reject);\n\nfunction fulfill(answer) {\n  console.log(`The answer is ${answer}`);\n}\n\nfunction reject(reason) {\n  console.log(`Couldn't get the answer! Reason: ${reason}`);\n}\n\n\n\nMuch of the power of promises comes from the fact that they can be\nchained together to perform sequential asynchronous operations:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  // Note: jQuery AJAX methods return promises\nvar usernamesPromise = Ember.$.getJSON('/usernames.json');\n\nusernamesPromise.then(fetchPhotosOfUsers)\n                .then(applyInstagramFilters)\n                .then(uploadTrendyPhotoAlbum)\n                .then(displaySuccessMessage, handleErrors);\n\n\n\nIn the above example, if any of the methods\nfetchPhotosOfUsers, applyInstagramFilters, or\nuploadTrendyPhotoAlbum returns a promise that rejects,\nhandleErrors will be called with\nthe reason for the failure. In this manner, promises approximate an\nasynchronous form of try-catch statements that prevent the rightward\nflow of nested callback after nested callback and facilitate a saner\napproach to managing complex asynchronous logic in your applications.\n\nThis guide doesn't intend to fully delve into all the different ways\npromises can be used, but if you'd like a more thorough introduction,\ntake a look at the readme for RSVP,\nthe promise library that Ember uses.\nThe Router Pauses for Promises\nWhen transitioning between routes, the Ember router collects all of the\nmodels (via the model hook) that will be passed to the route's\ncontrollers at the end of the transition. If the model hook (or the related\nbeforeModel or afterModel hooks) return normal (non-promise) objects or\narrays, the transition will complete immediately. But if the model hook\n(or the related beforeModel or afterModel hooks) returns a promise (or\nif a promise was provided as an argument to transitionTo), the transition\nwill pause until that promise fulfills or rejects.\n\nThe router considers any object with a then() method\ndefined on it to be a promise.\n\nIf the promise fulfills, the transition will pick up where it left off and\nbegin resolving the next (child) route's model, pausing if it too is a\npromise, and so on, until all destination route models have been\nresolved. The values passed to the setupController() hook for each route\nwill be the fulfilled values from the promises.\n\nA basic example:\n\n  \n    \n      app/routes/tardy.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Route.extend({\n  model() {\n    return new Ember.RSVP.Promise(function(resolve) {\n      Ember.run.later(function() {\n        resolve({ msg: 'Hold Your Horses' });\n      }, 3000);\n    });\n  },\n\n  setupController(controller, model) {\n    console.log(model.msg); // \"Hold Your Horses\"\n  }\n});\n\n\n\nWhen transitioning into route:tardy, the model() hook will be called and\nreturn a promise that won't resolve until 3 seconds later, during which time\nthe router will be paused in mid-transition. When the promise eventually\nfulfills, the router will continue transitioning and eventually call\nroute:tardy's setupController() hook with the resolved object.\n\nThis pause-on-promise behavior is extremely valuable for when you need\nto guarantee that a route's data has fully loaded before displaying a\nnew template.\nWhen Promises Reject...\nWe've covered the case when a model promise fulfills, but what if it rejects?\n\nBy default, if a model promise rejects during a transition, the transition is\naborted, no new destination route templates are rendered, and an error\nis logged to the console.\n\nYou can configure this error-handling logic via the error handler on\nthe route's actions hash. When a promise rejects, an error event\nwill be fired on that route and bubble up to route:application's\ndefault error handler unless it is handled by a custom error handler\nalong the way, e.g.:\n\n  \n    \n      app/routes/good-for-nothing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  export default Ember.Route.extend({\n  model() {\n    return Ember.RSVP.reject(\"FAIL\");\n  },\n\n  actions: {\n    error(reason) {\n      alert(reason); // \"FAIL\"\n\n      // Can transition to another route here, e.g.\n      // this.transitionTo('index');\n\n      // Uncomment the line below to bubble this error event:\n      // return true;\n    }\n  }\n});\n\n\n\nIn the above example, the error event would stop right at\nroute:good-for-nothing's error handler and not continue to bubble. To\nmake the event continue bubbling up to route:application, you can\nreturn true from the error handler.\nRecovering from Rejection\nRejected model promises halt transitions, but because promises are chainable,\nyou can catch promise rejects within the model hook itself and convert\nthem into fulfills that won't halt the transition.\n\n  \n    \n      app/routes/funky.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Route.extend({\n  model() {\n    return iHopeThisWorks().catch(function() {\n      // Promise rejected, fulfill with some default value to\n      // use as the route's model and continue on with the transition\n      return { msg: 'Recovered from rejected promise' };\n    });\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"bc0bfb567fedd41ba7b17f66df025608","fields":[{"name":"title","value":"Defining Your Routes","type":"string"},{"name":"url","value":"/routing/defining-your-routes/","type":"enum"},{"name":"body","value":"When your application starts, the router matches the current URL to the routes\nthat you've defined. The routes, in turn, are responsible for displaying\ntemplates, loading data, and otherwise setting up application state.\nBasic Routes\nThe map() method\nof your Ember application's router can be invoked to define URL mappings. When\ncalling map(), you should pass a function that will be invoked with the value\nthis set to an object which you can use to create routes.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('about', { path: '/about' });\n  this.route('favorites', { path: '/favs' });\n});\n\n\n\nNow, when the user visits /about, Ember will render the about\ntemplate. Visiting /favs will render the favorites template.\n\nYou can leave off the path if it is the same as the route\nname. In this case, the following is equivalent to the above example:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('about');\n  this.route('favorites', { path: '/favs' });\n});\n\n\n\nInside your templates, you can use {{link-to}} to navigate between\nroutes, using the name that you provided to the route method.\n\n  1\n2\n3\n4\n5\n6\n\n  {{#link-to \"index\"}}\u003cimg class=\"logo\"\u003e{{/link-to}}\n\n\u003cnav\u003e\n  {{#link-to \"about\"}}About{{/link-to}}\n  {{#link-to \"favorites\"}}Favorites{{/link-to}}\n\u003c/nav\u003e\n\n\n\nThe {{link-to}} helper will also add an active class to the link that\npoints to the currently active route.\nNested Routes\nOften you'll want to have a template that displays inside another template.\nFor example, in a blogging application, instead of going from a list of blog\nposts to creating a new post, you might want to have the post creation page\ndisplay next to the list.\n\nIn these cases, you can use nested routes to display one template inside\nof another.\n\nYou can define nested routes by passing a callback to this.route:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('new');\n  });\n});\n\n\n\nAnd then add the {{outlet}} helper to your template where you want the nested\ntemplate to display:\n\n  \n    \n      templates/posts.hbs\n    \n  \n\n  1\n2\n3\n\n  \u003ch1\u003ePosts\u003c/h1\u003e\n\u003c!-- Display posts and other content --\u003e\n{{outlet}}\n\n\n\nThis router creates a route for /posts and for /posts/new. When a user\nvisits /posts, they'll simply see the posts.hbs template. (Below, index\nroutes explains an important addition to this.) When the\nuser visits posts/new, they'll see the posts/new.hbs template rendered into\nthe {{outlet}} of the posts template.\n\nA nested route's names includes the names of its ancestors.\nIf you want to transition to a route (either\nvia transitionTo or {{#link-to}}), make sure to use the full route\nname (posts.new, not new).\nThe application route\nThe application route is entered when your app first boots up. Like other\nroutes, it will load a template with the same name (application in\nthis case) by default.\nYou should put your header, footer, and any other decorative content\nhere. All other routes will render\ntheir templates into the application.hbs template's {{outlet}}.\n\nThis route is part of every application, so you don't need to\nspecify it in your app/router.js.\nIndex Routes\nAt every level of nesting (including the top level), Ember\nautomatically provides a route for the / path named index.\n\nFor example, if you write a simple router like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function(){\n  this.route('favorites');\n});\n\n\n\nIt is the equivalent of:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function(){\n  this.route('index', { path: '/' });\n  this.route('favorites');\n});\n\n\n\nThe index template will be rendered into the {{outlet}} in the\napplication template. If the user navigates to /favorites,\nEmber will replace the index template with the favorites\ntemplate.\n\nA nested router like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('favorites');\n  });\n});\n\n\n\nIs the equivalent of:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  Router.map(function(){\n  this.route('index', { path: '/' });\n  this.route('posts', function() {\n    this.route('index', { path: '/' });\n    this.route('favorites');\n  });\n});\n\n\n\nIf the user navigates to /posts, the current route will be\nposts.index, and the posts/index template\nwill be rendered into the {{outlet}} in the posts template.\n\nIf the user then navigates to /posts/favorites, Ember will\nreplace the {{outlet}} in the posts template with the\nposts/favorites template.\nDynamic Segments\nOne of the responsibilities of a route is to load a model.\n\nFor example, if we have the route this.route('posts');, our\nroute might load all of the blog posts for the app.\n\nBecause /posts represents a fixed model, we don't need any\nadditional information to know what to retrieve.  However, if we want a route\nto represent a single post, we would not want to have to hardcode every\npossible post into the router.\n\nEnter dynamic segments.\n\nA dynamic segment is a portion of a URL that starts with a : and is\nfollowed by an identifier.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('posts');\n  this.route('post', { path: '/post/:post_id' });\n});\n\n\n\nIf the user navigates to /post/5, the route will then have the post_id of\n5 to use to load the correct post. In the next section, Specifying a Route's\nModel, you will learn more about how to load a model.\nWildcard / globbing routes\nYou can define wildcard routes that will match multiple URL segments. This could be used, for example,\nif you'd like a catch-all route which is useful when the user enters an incorrect URL not managed\nby your app.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('page-not-found', { path: '/*wildcard' });\n});\n\n\nRoute Handlers\nTo have your route do something beyond render a template with the same name, you'll\nneed to create a route handler. The following guides will explore the different\nfeatures of route handlers. For more information on routes, see the API documentation\nfor the router and for route\nhandlers.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e220634be1096dfda0635ee4cccf6449","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/routing/","type":"enum"},{"name":"body","value":"Imagine we are writing a web app for managing a blog. At any given time, we\nshould be able to answer questions like What post are they looking at? and\nAre they editing it? In Ember.js, the answer to these questions is determined\nby the URL.\n\nThe URL can be set in a few ways:\n\n\nThe user loads the app for the first time.\nThe user changes the URL manually, such as by clicking the back button or by\nediting the address bar.\nThe user clicks a link within the app.\nSome other event in the app causes the URL to change.\n\n\nRegardless of how the URL becomes set, the Ember router then maps the current\nURL to one or more route handlers. A route handler can do several things:\n\n\nIt can render a template.\nIt can load a model that is then available to the template.\nIt can redirect to a new route, such as if the user isn't allowed to visit\nthat part of the app.\nIt can handle actions that involve changing a model or transitioning to a new route.\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b73d2dfe086aa008696fa624bef07e0e","fields":[{"name":"title","value":"Loading / Error Substates","type":"string"},{"name":"url","value":"/routing/loading-and-error-substates/","type":"enum"},{"name":"body","value":"The Ember Router allows you to provide feedback that a route is loading, as well\nas when an error occurs in loading a route.\nloading substates\nDuring the beforeModel, model, and afterModel hooks, data may take some\ntime to load. Technically, the router pauses the transition until the promises\nreturned from each hook fulfill.\n\nConsider the following:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('slow-model');\n});\n\n\n\n  \n    \n      app/routes/slow-model.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findAll('slowModel');\n  }\n});\n\n\n\nIf you navigate to slow-model, in the model hook,\nthe query may take a long time to complete.\nDuring this time, your UI isn't really giving you any feedback as to\nwhat's happening. If you're entering this route after a full page\nrefresh, your UI will be entirely blank, as you have not actually\nfinished fully entering any route and haven't yet displayed any\ntemplates. If you're navigating to slow-model from another\nroute, you'll continue to see the templates from the previous route\nuntil the model finish loading, and then, boom, suddenly all the\ntemplates for slow-model load.\n\nSo, how can we provide some visual feedback during the transition?\n\nSimply define a template called loading (and optionally a corresponding route)\nthat Ember will transition to. The\nintermediate transition into the loading substate happens immediately\n(synchronously), the URL won't be updated, and, unlike other transitions, the\ncurrently active transition won't be aborted.\n\nOnce the main transition into slow-model completes, the loading\nroute will be exited and the transition to slow-model will continue.\n\nFor nested routes, like:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  Router.map(function() {\n  this.route('foo', function() {\n    this.route('bar', function() {\n      this.route('slow-model');\n    });\n  });\n});\n\n\n\nWhen accessing foo.bar.slow-model route then Ember will alternate trying to\nfind a routeName-loading or loading template in the hierarchy starting with\nfoo.bar.slow-model-loading:\n\n\nfoo.bar.slow-model-loading\nfoo.bar.loading or foo.bar-loading\nfoo.loading or foo-loading\nloading or application-loading\n\n\nIt's important to note that for slow-model itself, Ember will not try to\nfind a slow-model.loading template but for the rest of the hierarchy either\nsyntax is acceptable. This can be useful for creating a custom loading screen\nfor a leaf route like slow-model.\n\nWhen accessing foo.bar route then Ember will search for:\n\n\nfoo.bar-loading\nfoo.loading or foo-loading\nloading or application-loading\n\n\nIt's important to note that foo.bar.loading is not considered now.\nThe loading event\nIf the various beforeModel/model/afterModel hooks\ndon't immediately resolve, a loading event will be fired on that route.\n\n  \n    \n      app/routes/foo-slow-model.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findAll('slowModel');\n  },\n  actions: {\n    loading(transition, originRoute) {\n      let controller = this.controllerFor('foo');\n      controller.set('currentlyLoading', true);\n    }\n  }\n});\n\n\n\nIf the loading handler is not defined at the specific route,\nthe event will continue to bubble above a transition's parent\nroute, providing the application route the opportunity to manage it.\n\nWhen using the loading handler, we can make use of the transition promise to know when the loading event is over:\n\n  \n    \n      app/routes/foo-slow-model.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Route.extend({\n  ...\n  actions: {\n    loading(transition, originRoute) {\n      let controller = this.controllerFor('foo');\n      controller.set('currentlyLoading', true);\n      transition.promise.finally(function() {\n          controller.set('currentlyLoading', false);\n      });\n    }\n  }\n});\n\n\nerror substates\nEmber provides an analogous approach to loading substates in\nthe case of errors encountered during a transition.\n\nSimilar to how the default loading event handlers are implemented,\nthe default error handlers will look for an appropriate error substate to\nenter, if one can be found.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('articles', function() {\n    this.route('overview');\n  });\n});\n\n\n\nAs with the loading substate, on a thrown error or rejected promise returned\nfrom the articles.overview route's model hook (or beforeModel or\nafterModel) Ember will look for an error template or route in the following\norder:\n\n\narticles.overview-error\narticles.error or articles-error\nerror or application-error\n\n\nIf one of the above is found, the router will immediately transition into\nthat substate (without updating the URL). The \"reason\" for the error\n(i.e. the exception thrown or the promise reject value) will be passed\nto that error state as its model.\n\nIf no viable error substates can be found, an error message will be\nlogged.\nThe error event\nIf the articles.overview route's model hook returns a promise that rejects\n(for instance the server returned an error, the user isn't logged in,\netc.), an error event will fire from that route and bubble upward.\nThis error event can be handled and used to display an error message,\nredirect to a login page, etc.\n\n  \n    \n      app/routes/articles-overview.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Route.extend({\n  model(params) {\n    return this.store.findAll('problematicModel');\n  },\n  actions: {\n    error(error, transition) {\n      if (error) {\n        return this.transitionTo('errorPage');\n      }\n    }\n  }\n});\n\n\n\nAnalogous to the loading event, you could manage the error event\nat the application level to avoid writing the same code for multiple routes.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"73217f11fed62d7b09ccc1c4378f49e7","fields":[{"name":"title","value":"Preventing and Retrying Transitions","type":"string"},{"name":"url","value":"/routing/preventing-and-retrying-transitions/","type":"enum"},{"name":"body","value":"During a route transition, the Ember Router passes a transition\nobject to the various hooks on the routes involved in the transition.\nAny hook that has access to this transition object has the ability\nto immediately abort the transition by calling transition.abort(),\nand if the transition object is stored, it can be re-attempted at a\nlater time by calling transition.retry().\nPreventing Transitions via willTransition\nWhen a transition is attempted, whether via {{link-to}}, transitionTo,\nor a URL change, a willTransition action is fired on the currently\nactive routes. This gives each active route, starting with the leaf-most\nroute, the opportunity to decide whether or not the transition should occur.\n\nImagine your app is in a route that's displaying a complex form for the user\nto fill out and the user accidentally navigates backwards. Unless the\ntransition is prevented, the user might lose all of the progress they\nmade on the form, which can make for a pretty frustrating user experience.\n\nHere's one way this situation could be handled:\n\n  \n    \n      app/routes/form.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Route.extend({\n  actions: {\n    willTransition(transition) {\n      if (this.controller.get('userHasEnteredData') \u0026\u0026\n          !confirm('Are you sure you want to abandon progress?')) {\n        transition.abort();\n      } else {\n        // Bubble the `willTransition` action so that\n        // parent routes can decide whether or not to abort.\n        return true;\n      }\n    }\n  }\n});\n\n\n\nWhen the user clicks on a {{link-to}} helper, or when the app initiates a\ntransition by using transitionTo, the transition will be aborted and the URL\nwill remain unchanged. However, if the browser back button is used to\nnavigate away from route:form, or if the user manually changes the URL, the\nnew URL will be navigated to before the willTransition action is\ncalled. This will result in the browser displaying the new URL, even if\nwillTransition calls transition.abort().\nAborting Transitions Within model, beforeModel, afterModel\nThe model, beforeModel, and afterModel hooks described in\nAsynchronous Routing\neach get called with a transition object. This makes it possible for\ndestination routes to abort attempted transitions.\n\n  \n    \n      app/routes/disco.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  beforeModel(transition) {\n    if (new Date() \u003e new Date('January 1, 1980')) {\n      alert('Sorry, you need a time machine to enter this route.');\n      transition.abort();\n    }\n  }\n});\n\n\nStoring and Retrying a Transition\nAborted transitions can be retried at a later time. A common use case\nfor this is having an authenticated route redirect the user to a login\npage, and then redirecting them back to the authenticated route once\nthey've logged in.\n\n  \n    \n      app/routes/some-authenticated.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Route.extend({\n  beforeModel(transition) {\n    if (!this.controllerFor('auth').get('userIsLoggedIn')) {\n      var loginController = this.controllerFor('login');\n      loginController.set('previousTransition', transition);\n      this.transitionTo('login');\n    }\n  }\n});\n\n\n\n  \n    \n      app/controllers/login.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Controller.extend({\n  actions: {\n    login() {\n      // Log the user in, then reattempt previous transition if it exists.\n      var previousTransition = this.get('previousTransition');\n      if (previousTransition) {\n        this.set('previousTransition', null);\n        previousTransition.retry();\n      } else {\n        // Default back to homepage\n        this.transitionToRoute('index');\n      }\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a10da78f7f24528b1e5d721dbc5e424b","fields":[{"name":"title","value":"Query Parameters","type":"string"},{"name":"url","value":"/routing/query-params/","type":"enum"},{"name":"body","value":"Query parameters are optional key-value pairs that appear to the right of\nthe ? in a URL. For example, the following URL has two query params,\nsort and page, with respective values ASC and 2:\n\n  1\n\n  http://example.com/articles?sort=ASC\u0026page=2\n\n\n\nQuery params allow for additional application state to be serialized\ninto the URL that can't otherwise fit into the path of the URL (i.e.\neverything to the left of the ?). Common use cases for query params include\nrepresenting the current page number in a paginated collection, filter criteria, or sorting criteria.\nSpecifying Query Parameters\nQuery params are declared on route-driven controllers. For example, to\nconfigure query params that are active within the articles route,\nthey must be declared on controller:articles.\n\nTo add a category\nquery parameter that will filter out all the articles that haven't\nbeen categorized as popular we'd specify 'category'\nas one of controller:article's queryParams:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  queryParams: ['category'],\n  category: null\n});\n\n\n\nThis sets up a binding between the category query param in the URL,\nand the category property on controller:articles. In other words,\nonce the articles route has been entered, any changes to the\ncategory query param in the URL will update the category property\non controller:articles, and vice versa.\n\nNow we need to define a computed property of our category-filtered\narray that the articles template will render:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Controller.extend({\n  queryParams: ['category'],\n  category: null,\n\n  filteredArticles: Ember.computed('category', 'model', function() {\n    var category = this.get('category');\n    var articles = this.get('model');\n\n    if (category) {\n      return articles.filterBy('category', category);\n    } else {\n      return articles;\n    }\n  })\n});\n\n\n\nWith this code, we have established the following behaviors:\n\n\nIf the user navigates to /articles, category will be null, so\nthe articles won't be filtered.\nIf the user navigates to /articles?category=recent,\ncategory will be set to \"recent\", so articles will be filtered.\nOnce inside the articles route, any changes to the category\nproperty on controller:articles will cause the URL to update the\nquery param. By default, a query param property change won't cause a\nfull router transition (i.e. it won't call model hooks and\nsetupController, etc.); it will only update the URL.\n\nlink-to Helper\nThe link-to helper supports specifying query params using the\nquery-params subexpression helper.\n\n  1\n2\n3\n4\n5\n\n  // Explicitly set target query params\n{{#link-to \"posts\" (query-params direction=\"asc\")}}Sort{{/link-to}}\n\n// Binding is also supported\n{{#link-to \"posts\" (query-params direction=otherDirection)}}Sort{{/link-to}}\n\n\n\nIn the above examples, direction is presumably a query param property\non the posts controller, but it could also refer to a direction property\non any of the controllers associated with the posts route hierarchy,\nmatching the leaf-most controller with the supplied property name.\n\nThe link-to helper takes into account query parameters when determining\nits \"active\" state, and will set the class appropriately. The active state\nis determined by calculating whether the query params end up the same after\nclicking a link. You don't have to supply all of the current,\nactive query params for this to be true.\ntransitionTo\nRoute#transitionTo and Controller#transitionToRoute\naccept a final argument, which is an object with the key queryParams.\n\n  \n    \n      app/routes/some-route.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  this.transitionTo('post', object, { queryParams: { showDetails: true }});\nthis.transitionTo('posts', { queryParams: { sort: 'title' }});\n\n// if you want to transition the query parameters without changing the route\nthis.transitionTo({ queryParams: { direction: 'asc' }});\n\n\n\nYou can also add query params to URL transitions:\n\n  \n    \n      app/routes/some-route.js\n    \n  \n\n  1\n\n  this.transitionTo('/posts/1?sort=date\u0026showDetails=true');\n\n\nOpting into a full transition\nArguments provided to transitionTo\nor link-to only correspond to a change in query param values,\nand not a change in the route hierarchy, it is not considered a\nfull transition, which means that hooks like model and\nsetupController won't fire by default, but rather only\ncontroller properties will be updated with new query param values, as\nwill the URL.\n\nBut some query param changes necessitate loading data from the server,\nin which case it is desirable to opt into a full-on transition. To opt\ninto a full transition when a controller query param property changes,\nyou can use the optional queryParams configuration hash on the Route\nassociated with that controller, and set that query param's\nrefreshModel config property to true:\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  export default Ember.Route.extend({\n  queryParams: {\n    category: {\n      refreshModel: true\n    }\n  },\n  model(params) {\n    // This gets called upon entering 'articles' route\n    // for the first time, and we opt into refiring it upon\n    // query param changes by setting `refreshModel:true` above.\n\n    // params has format of { category: \"someValueOrJustNull\" },\n    // which we can forward to the server.\n    return this.store.query('articles', params);\n  }\n});\n\n\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  queryParams: ['category'],\n  category: null\n});\n\n\nUpdate URL with replaceState instead\nBy default, Ember will use pushState to update the URL in the\naddress bar in response to a controller query param property change, but\nif you would like to use replaceState instead (which prevents an\nadditional item from being added to your browser's history), you can\nspecify this on the Route's queryParams config hash, e.g. (continued\nfrom the example above):\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  queryParams: {\n    category: {\n      replace: true\n    }\n  }\n});\n\n\n\nNote that the name of this config property and its default value of\nfalse is similar to the link-to helper's, which also lets\nyou opt into a replaceState transition via replace=true.\nMap a controller's property to a different query param key\nBy default, specifying foo as a controller query param property will\nbind to a query param whose key is foo, e.g. ?foo=123. You can also map\na controller property to a different query param key using the\nfollowing configuration syntax:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Controller.extend({\n  queryParams: {\n    category: 'articles_category'\n  },\n  category: null\n});\n\n\n\nThis will cause changes to the controller:articles's category\nproperty to update the articles_category query param, and vice versa.\n\nNote that query params that require additional customization can\nbe provided along with strings in the queryParams array.\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Controller.extend({\n  queryParams: ['page', 'filter', {\n    category: 'articles_category'\n  }],\n  category: null,\n  page: 1,\n  filter: 'recent'\n});\n\n\nDefault values and deserialization\nIn the following example, the controller query param property page is\nconsidered to have a default value of 1.\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  queryParams: 'page',\n  page: 1\n});\n\n\n\nThis affects query param behavior in two ways:\n\n\nQuery param values are cast to the same datatype as the default\nvalue, e.g. a URL change from /?page=3 to /?page=2 will set\ncontroller:articles's page property to the number 2, rather than\nthe string \"2\". The same also applies to boolean default values.\nWhen a controller's query param property is currently set to its\ndefault value, this value won't be serialized into the URL. So in the\nabove example, if page is 1, the URL might look like /articles,\nbut once someone sets the controller's page value to 2, the URL\nwill become /articles?page=2.\n\nSticky Query Param Values\nBy default, query param values in Ember are \"sticky\", in that if you\nmake changes to a query param and then leave and re-enter the route, the\nnew value of that query param will be preserved (rather than reset to\nits default). This is a particularly handy default for preserving sort/filter\nparameters as you navigate back and forth between routes.\n\nFurthermore, these sticky query param values are remembered/restored\naccording to the model loaded into the route. So, given a team route\nwith dynamic segment /:team_name and controller query param \"filter\",\nif you navigate to /badgers and filter by \"rookies\", then navigate\nto /bears and filter by \"best\", and then navigate to /potatoes and\nfilter by \"lamest\", then given the following nav bar links,\n\n  1\n2\n3\n\n  {{#link-to \"team\" \"badgers\"}}Badgers{{/link-to}}\n{{#link-to \"team\" \"bears\"}}Bears{{/link-to}}\n{{#link-to \"team\" \"potatoes\"}}Potatoes{{/link-to}}\n\n\n\nthe generated links would be\n\n  1\n2\n3\n\n  \u003ca href=\"/badgers?filter=rookies\"\u003eBadgers\u003c/a\u003e\n\u003ca href=\"/bears?filter=best\"\u003eBears\u003c/a\u003e\n\u003ca href=\"/potatoes?filter=lamest\"\u003ePotatoes\u003c/a\u003e\n\n\n\nThis illustrates that once you change a query param, it is stored and\ntied to the model loaded into the route.\n\nIf you wish to reset a query param, you have two options:\n\n\nexplicitly pass in the default value for that query param into\nlink-to or transitionTo.\nuse the Route.resetController hook to set query param values back to\ntheir defaults before exiting the route or changing the route's model.\n\n\nIn the following example, the controller's page query param is reset\nto 1, while still scoped to the pre-transition ArticlesRoute model.\nThe result of this is that all links pointing back into the exited route\nwill use the newly reset value 1 as the value for the page query\nparam.\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  resetController(controller, isExiting, transition) {\n    if (isExiting) {\n      // isExiting would be false if only the route's model was changing\n      controller.set('page', 1);\n    }\n  }\n});\n\n\n\nIn some cases, you might not want the sticky query param value to be\nscoped to the route's model but would rather reuse a query param's value\neven as a route's model changes. This can be accomplished by setting the\nscope option to \"controller\" within the controller's queryParams\nconfig hash:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Controller.extend({\n  queryParams: [{\n    showMagnifyingGlass: {\n      scope: 'controller'\n    }\n  }]\n});\n\n\n\nThe following demonstrates how you can override both the scope and the\nquery param URL key of a single controller query param property:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Controller.extend({\n  queryParams: ['page', 'filter',\n    {\n      showMagnifyingGlass: {\n        scope: 'controller',\n        as: 'glass'\n      }\n    }\n  ]\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"088e52d28fa44f8c93ca2f490bad93c3","fields":[{"name":"title","value":"Redirecting","type":"string"},{"name":"url","value":"/routing/redirection/","type":"enum"},{"name":"body","value":"Calling transitionTo() from a route or transitionToRoute() from a \ncontroller will stop any transition currently in progress and start a new \none, functioning as a redirect. transitionTo() behaves exactly like the \nlink-to helper.\n\nIf the new route has dynamic segments, you need to pass either a model or an identifier for each segment.\nPassing a model will skip that segment's model() hook (since the model is\nalready loaded).\nTransitioning Before the Model is Known\nIf you want to redirect from one route to another, you can do the transition in\nthe beforeModel() hook of your route handler.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('posts');\n});\n\n\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  beforeModel() {\n    this.transitionTo('posts');\n  }\n});\n\n\n\nIf you need to examine some application state to figure out where to redirect,\nyou might use a service.\nTransitioning After the Model is Known\nIf you need information about the current model in order to decide about\nredirection, you can use the afterModel() hook.\nIt receives the resolved model as the first parameter and the transition as\nthe second one. For example:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('posts');\n  this.route('post', { path: '/post/:post_id' });\n});\n\n\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  afterModel(model, transition) {\n    if (model.get('length') === 1) {\n      this.transitionTo('post', model.get('firstObject'));\n    }\n  }\n});\n\n\n\nWhen transitioning to the posts route if it turns out that there is only one post,\nthe current transition will be aborted in favor of redirecting to the PostRoute\nwith the single post object being its model.\nChild Routes\nLet's change the router above to use a nested route, like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('post', { path: ':post_id' });\n  });\n});\n\n\n\nIf we redirect to posts.post in the afterModel hook, afterModel\nessentially invalidates the current attempt to enter this route. So the posts\nroute's beforeModel, model, and afterModel hooks will fire again within\nthe new, redirected transition. This is inefficient, since they just fired\nbefore the redirect.\n\nInstead, we can use the redirect() method, which will leave the original\ntransition validated, and not cause the parent route's hooks to fire again:\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  redirect(model, transition) {\n    if (model.get('length') === 1) {\n      this.transitionTo('posts.post', model.get('firstObject'));\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b1db196c912b89d4bb0d82325bb9137c","fields":[{"name":"title","value":"Rendering a Template","type":"string"},{"name":"url","value":"/routing/rendering-a-template/","type":"enum"},{"name":"body","value":"One job of a route handler is rendering the\nappropriate template to the screen.\n\nBy default, a route handler will render the template with the same name as the\nroute. Take this router:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('new');\n  });\n});\n\n\n\nHere, the posts route will render the posts.hbs template, and\nthe posts.new route will render posts/new.hbs.\n\nEach template will be rendered into the {{outlet}} of its parent route's\ntemplate. For example, the posts.new route will render its template into the\nposts.hbs's {{outlet}}, and the posts route will render its template into\nthe application.hbs's {{outlet}}.\n\nIf you want to render a template other than the default one, implement the\nrenderTemplate() hook:\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  renderTemplate() {\n    this.render('favoritePosts');\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d94b756c7278f11f9a951d1a47d8640f","fields":[{"name":"title","value":"Specifying a Route's Model","type":"string"},{"name":"url","value":"/routing/specifying-a-routes-model/","type":"enum"},{"name":"body","value":"Often, you'll want a template to display data from a model. Loading the\nappropriate model is one job of a route.\n\nFor example, take this router:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('favorite-posts');\n});\n\n\n\nTo load a model for the favoritePosts route, you would use the model() \nhook in the favoritePosts route handler:\n\n  \n    \n      app/routes/favorite-posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.query('post', { favorite: true });\n  }\n});\n\n\n\nTypically, the model hook should return an Ember Data record,\nbut it can also return any promise object (Ember\nData records are promises), or a plain JavaScript object or array. Ember will\nwait until the data finishes loading (until the promise is resolved) before\nrendering the template.\n\nThe route will then set the return value from the model hook as the model property of the controller.\nYou will then be able to access the controller's model property in your template:\n\n  \n    \n      app/templates/favorite-posts.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003ch1\u003eFavorite Posts\u003c/h1\u003e\n{{#each model as |post|}}\n  \u003cp\u003e{{post.body}}\u003c/p\u003e\n{{/each}}\n\n\nDynamic Models\nSome routes always display the same model. For example, the /photos\nroute will always display the same list of photos available in the\napplication. If your user leaves this route and comes back later, the\nmodel does not change.\n\nHowever, you will often have a route whose model will change depending\non user interaction. For example, imagine a photo viewer app. The\n/photos route will render the photos template with the list of\nphotos as the model, which never changes. But when the user clicks on a\nparticular photo, we want to display that model with the photo\ntemplate. If the user goes back and clicks on a different photo, we want\nto display the photo template again, this time with a different model.\n\nIn cases like this, it's important that we include some information in\nthe URL about not only which template to display, but also which model.\n\nIn Ember, this is accomplished by defining routes with dynamic\nsegments.\n\nOnce you have defined a route with a dynamic segment,\nEmber will extract the value of the dynamic segment from the URL for\nyou and pass them as a hash to the model hook as the first argument:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('photo', { path: '/photos/:photo_id' });\n});\n\n\n\n  \n    \n      app/routes/photo.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model(params) {\n    return this.store.findRecord('photo', params.photo_id);\n  }\n});\n\n\n\nIn the model hook for routes with dynamic segments, it's your job to\nturn the ID (something like 47 or post-slug) into a model that can\nbe rendered by the route's template. In the above example, we use the\nphoto's ID (params.photo_id) as an argument to Ember Data's findRecord\nmethod.\n\nNote: A route with a dynamic segment will only have its model hook called\nwhen it is entered via the URL. If the route is entered through a transition\n(e.g. when using the link-to Handlebars helper), then a model context is\nalready provided and the hook is not executed. Routes without dynamic segments\nwill always execute the model hook.\nMultiple Models\nMultiple models can be returned through an\nEmber.RSVP.hash.\nThe Ember.RSVP.hash takes\nparameters that return promises, and when all parameter promises resolve, then\nthe Ember.RSVP.hash promise resolves. For example:\n\n  \n    \n      app/routes/songs.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  model() {\n    return Ember.RSVP.hash({\n      songs: this.store.findAll('song'),\n      albums: this.store.findAll('album')\n    });\n  }\n});\n\n\n\nIn the songs template, we can specify both models and use the {{#each}} helper to display\neach record in the song model and album model:\n\n  \n    \n      app/templates/songs.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  \u003ch1\u003ePlaylist\u003c/h1\u003e\n\n\u003cul\u003e\n  {{#each model.songs as |song|}}\n    \u003cli\u003e{{song.name}} by {{song.artist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\u003ch1\u003eAlbums\u003c/h1\u003e\n\n\u003cul\u003e\n  {{#each model.albums as |album|}}\n    \u003cli\u003e{{album.title}} by {{album.artist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"1b11151882558c3e878b1c432610d998","fields":[{"name":"title","value":"Actions","type":"string"},{"name":"url","value":"/templates/actions/","type":"enum"},{"name":"body","value":"Your app will often need a way to let users interact with controls that\nchange application state. For example, imagine that you have a template\nthat shows a blog title, and supports expanding the post to show the body.\n\nIf you add the\n{{action}}\nhelper to any HTML DOM element, when a user clicks the element, the named event\nwill be sent to the template's corresponding component or controller.\n\n  \n    \n      app/templates/components/single-post.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003ch3\u003e\u003cbutton {{action \"toggleBody\"}}\u003e{{title}}\u003c/button\u003e\u003c/h3\u003e\n{{#if isShowingBody}}\n  \u003cp\u003e{{{body}}}\u003c/p\u003e\n{{/if}}\n\n\n\nIn the component or controller, you can then define what the action does within\nthe actions hook:\n\n  \n    \n      app/components/single-post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  actions: {\n    toggleBody() {\n      this.toggleProperty('isShowingBody');\n    }\n  }\n});\n\n\nAction Parameters\nYou can optionally pass arguments to the action handler. Any values\npassed to the {{action}} helper after the action name will be passed to\nthe handler as arguments.\n\nFor example, if the post argument was passed:\n\n  1\n\n  \u003cp\u003e\u003cbutton {{action \"select\" post}}\u003e✓\u003c/button\u003e {{post.title}}\u003c/p\u003e\n\n\n\nThe select action handler would be called with a single argument\ncontaining the post model:\n\n  \n    \n      app/components/single-post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  actions: {\n    select(post) {\n      console.log(post.get('title'));\n    }\n  }\n});\n\n\nSpecifying the Type of Event\nBy default, the\n{{action}}\nhelper listens for click events and triggers the action when the user clicks\non the element.\n\nYou can specify an alternative event by using the on option.\n\n  1\n2\n3\n4\n\n  \u003cp\u003e\n  \u003cbutton {{action \"select\" post on=\"mouseUp\"}}\u003e✓\u003c/button\u003e\n  {{post.title}}\n\u003c/p\u003e\n\n\n\nYou should use the camelCased event names, so two-word names like keypress\nbecome keyPress.\nAllowing Modifier Keys\nBy default the {{action}} helper will ignore click events with\npressed modifier keys. You can supply an allowedKeys option\nto specify which keys should not be ignored.\n\n  1\n2\n3\n\n  \u003cbutton {{action \"anActionName\" allowedKeys=\"alt\"}}\u003e\n  click me\n\u003c/button\u003e\n\n\n\nThis way the {{action}} will fire when clicking with the alt key\npressed down.\nAllowing Default Browser Action\nBy default, the {{action}} helper prevents the default browser action of the\nDOM event. If you want to allow the browser action, you can stop Ember from\npreventing it.\n\nFor example, if you have a normal link tag and want the link to bring the user\nto another page in addition to triggering an ember action when clicked, you can\nuse preventDefault=false:\n\n  1\n\n  \u003ca href=\"newPage.htm\" {{action \"logClick\" preventDefault=false}}\u003eGo\u003c/a\u003e\n\n\n\nWithout preventDefault=false, if the user clicked on the link, Ember.js\nwill trigger the action, but the user will remain on the current page.\n\nWith preventDefault=false, if the user clicked on the link, Ember.js\nwill trigger the action and the user will be directed to the new page.\nModifying the action's first parameter\nIf a value option for the\n{{action}}\nhelper is specified, its value will be considered a property path that will\nbe read off of the first parameter of the action. This comes very handy with\nevent listeners and enables to work with one-way bindings.\n\n  1\n2\n\n  \u003clabel\u003eWhat's your favorite band?\u003c/label\u003e\n\u003cinput type=\"text\" value={{favoriteBand}} onblur={{action \"bandDidChange\"}} /\u003e\n\n\n\nLet's assume we have an action handler that prints its first parameter:\n\n  1\n2\n3\n4\n5\n\n  actions: {\n  bandDidChange(newValue) {\n    console.log(newValue);\n  }\n}\n\n\n\nBy default, the action handler receives the first parameter of the event\nlistener, the event object the browser passes to the handler, so\nbandDidChange prints Event {}.\n\nUsing the value option modifies that behavior by extracting that property from\nthe event object:\n\n  1\n2\n\n  \u003clabel\u003eWhat's your favorite band?\u003c/label\u003e\n\u003cinput type=\"text\" value={{favoriteBand}} onblur={{action \"bandDidChange\" value=\"target.value\"}} /\u003e\n\n\n\nThe newValue parameter thus becomes the target.value property of the event\nobject, which is the value of the input field the user typed. (e.g 'Foo Fighters')\nAttaching Actions to Non-Clickable Elements\nNote that actions may be attached to any element of the DOM, but not all\nrespond to the click event. For example, if an action is attached to an a\nlink without an href attribute, or to a div, some browsers won't execute\nthe associated function. If it's really needed to define actions over such\nelements, a CSS workaround exists to make them clickable, cursor: pointer.\nFor example:\n\n  1\n2\n3\n\n  [data-ember-action]:not(:disabled) {\n  cursor: pointer;\n}\n\n\n\nKeep in mind that even with this workaround in place, the click event will\nnot automatically trigger via keyboard driven click equivalents (such as\nthe enter key when focused). Browsers will trigger this on clickable\nelements only by default. This also doesn't make an element accessible to\nusers of assistive technology. You will need to add additional things like\nrole and/or tabindex to make this accessible for your users.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"59c50884dd61207af6fc0a831825eb47","fields":[{"name":"title","value":"Binding Element Attributes","type":"string"},{"name":"url","value":"/templates/binding-element-attributes/","type":"enum"},{"name":"body","value":"In addition to normal text, you may also want to have your templates\ncontain HTML elements whose attributes are bound to the controller.\n\nFor example, imagine your controller has a property that contains a URL\nto an image:\n\n  1\n2\n3\n\n  \u003cdiv id=\"logo\"\u003e\n  \u003cimg src={{logoUrl}} alt=\"Logo\"\u003e\n\u003c/div\u003e\n\n\n\nThis generates the following HTML:\n\n  1\n2\n3\n\n  \u003cdiv id=\"logo\"\u003e\n  \u003cimg src=\"http://www.example.com/images/logo.png\" alt=\"Logo\"\u003e\n\u003c/div\u003e\n\n\n\nIf you use data binding with a Boolean value, it will add or remove\nthe specified attribute. For example, given this template:\n\n  1\n\n  \u003cinput type=\"checkbox\" disabled={{isAdministrator}}\u003e\n\n\n\nIf isAdministrator is true, Handlebars will produce the following\nHTML element:\n\n  1\n\n  \u003cinput type=\"checkbox\" disabled\u003e\n\n\n\nIf isAdministrator is false, Handlebars will produce the following:\n\n  1\n\n  \u003cinput type=\"checkbox\"\u003e\n\n\nAdding Data Attributes\nBy default, view helpers do not accept data attributes. For example\n\n  1\n2\n3\n\n  {{#link-to \"photos\" data-toggle=\"dropdown\"}}Photos{{/link-to}}\n\n{{input type=\"text\" data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"Name\"}}\n\n\n\nrenders the following HTML:\n\n  1\n2\n3\n4\n\n  \u003ca id=\"ember239\" class=\"ember-view\" href=\"#/photos\"\u003ePhotos\u003c/a\u003e\n\n\u003cinput id=\"ember257\" class=\"ember-view ember-text-field\" type=\"text\"\n       title=\"Name\"\u003e\n\n\n\nTo enable support for data attributes an attribute binding must be\nadded to the component, e.g.\nEmber.LinkComponent\nor Ember.TextField\nfor the specific attribute:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Ember.LinkComponent.reopen({\n  attributeBindings: ['data-toggle']\n});\n\nEmber.TextField.reopen({\n  attributeBindings: ['data-toggle', 'data-placement']\n});\n\n\n\nNow the same handlebars code above renders the following HTML:\n\n  1\n2\n3\n4\n\n  \u003ca id=\"ember240\" class=\"ember-view\" href=\"#/photos\" data-toggle=\"dropdown\"\u003ePhotos\u003c/a\u003e\n\n\u003cinput id=\"ember259\" class=\"ember-view ember-text-field\"\n       type=\"text\" data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"Name\"\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"95d724148efe2cc1481ae51952ecf2b7","fields":[{"name":"title","value":"Conditionals","type":"string"},{"name":"url","value":"/templates/conditionals/","type":"enum"},{"name":"body","value":"Statements like if\nand unless\nare implemented as built-in helpers. Helpers can be invoked three ways, each \nof which is illustrated below with conditionals.\n\nThe first style of invocation is inline invocation. This looks similar to\ndisplaying a property, but helpers accept arguments. For example:\n\n  1\n2\n3\n\n  \u003cdiv\u003e\n  {{if isFast \"zoooom\" \"putt-putt-putt\"}}\n\u003c/div\u003e\n\n\n\n{{if}}\nin this case returns \"zoooom\" when isFast is true and\n\"putt-putt-putt\" when isFast is false. Helpers invoked as inline expressions\nrender a single value, the same way that properties are a single value.\n\nInline helpers don't need to be used inside HTML tags. They can also be used\ninside attribute values:\n\n  1\n2\n\n  \u003cdiv class=\"is-car {{if isFast \"zoooom\" \"putt-putt-putt\"}}\"\u003e\n\u003c/div\u003e\n\n\n\nNested invocation is another way to use a helper. Like inline helpers,\nnested helpers generate and return a single value. For example, this template\nonly renders \"zoooom\" if both isFast and isFueled are true:\n\n  1\n2\n3\n\n  \u003cdiv\u003e\n  {{if isFast (if isFueled \"zoooom\")}}\n\u003c/div\u003e\n\n\n\nThe nested helper is called first returning \"zoooom\" only if isFueled is\ntrue. Then the inline expression is called, rendering the nested helper's\nvalue (\"zoooom\") only if isFast is true.\n\nThe third form of helper usage is block invocation. Use block helpers\nto render only part of a template. Block invocation of a helper can be\nrecognized by the # before the helper name, and the closing {{/ double\ncurly brace at the end of the invocation.\n\nFor example, this template conditionally shows\nproperties on person only if that it is present:\n\n  1\n2\n3\n\n  {{#if person}}\n  Welcome back, \u003cb\u003e{{person.firstName}} {{person.lastName}}\u003c/b\u003e!\n{{/if}}\n\n\n\n{{if}}\nchecks for truthiness, which means all values except false,\nundefined, null, '', 0  or [] (i.e., any JavaScript falsy value or an\nempty array).\n\nIf a value passed to {{#if}} evaluates to falsy, the {{else}} block\nof that invocation is rendered:\n\n  1\n2\n3\n4\n5\n\n  {{#if person}}\n  Welcome back, \u003cb\u003e{{person.firstName}} {{person.lastName}}\u003c/b\u003e!\n{{else}}\n  Please log in.\n{{/if}}\n\n\n\n{{else}} can chain helper invocation, the most common usecase for this being\n{{else if}}:\n\n  1\n2\n3\n4\n5\n\n  {{#if isAtWork}}\n  Ship that code!\n{{else if isReading}}\n  You can finish War and Peace eventually...\n{{/if}}\n\n\n\nThe inverse of {{if}} is\n{{unless}},\nwhich can be used in the same three styles of invocation. For example, this \ntemplate only shows an amount due when the user has not paid:\n\n  1\n2\n3\n\n  {{#unless hasPaid}}\n  You owe: ${{total}}\n{{/unless}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a114533ff2793c31df860c375985bcb","fields":[{"name":"title","value":"Development Helpers","type":"string"},{"name":"url","value":"/templates/development-helpers/","type":"enum"},{"name":"body","value":"Development Helpers\nHandlebars and Ember come with a few helpers that can make developing your\ntemplates a bit easier. These helpers make it simple to output variables into\nyour browser's console, or activate the debugger from your templates.\nLogging\nThe {{log}} helper makes it easy to output variables or expressions in\n the\ncurrent rendering context into your browser's console:\n\n  1\n\n  {{log 'Name is:' name}}\n\n\n\nThe {{log}} helper also accepts primitive types such as strings or numbers.\nAdding a breakpoint\nThe {{debugger}} helper provides a handlebars equivalent to JavaScript's\ndebugger keyword.  It will halt execution inside the debugger helper and give\nyou the ability to inspect the current rendering context:\n\n  1\n\n  {{debugger}}\n\n\n\nWhen using the debugger helper you will have access to a get function. This\nfunction retrieves values available in the context of the template.\nFor example, if you're wondering why a value {{foo}} isn't rendering as\nexpected within a template, you could place a {{debugger}} statement and,\nwhen the debugger; breakpoint is hit, you can attempt to retrieve this value:\n\n  1\n\n  \u003e get('foo')\n\n\n\nget is also aware of keywords. So in this situation:\n\n  1\n2\n3\n\n  {{#each items as |item|}}\n  {{debugger}}\n{{/each}}\n\n\n\nYou'll be able to get values from the current item:\n\n  1\n\n  \u003e get('item.name')\n\n\n\nYou can also access the context of the view to make sure it is the object that\nyou expect:\n\n  1\n\n  \u003e context\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"94f518795fa706013cfd0ed73c5a9d3c","fields":[{"name":"title","value":"Displaying a List of Items","type":"string"},{"name":"url","value":"/templates/displaying-a-list-of-items/","type":"enum"},{"name":"body","value":"To iterate over a list of items, use the\n{{#each}}\nhelper. The first argument to this helper is the array to be iterated, and\nthe value being iterated is yielded as a block param. Block params are only\navailable inside the block of their helper.\n\nFor example, this template iterates an array named people that contains\nobjects. Each item in the array is provided as the block param person.\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each people as |person|}}\n    \u003cli\u003eHello, {{person.name}}!\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nBlock params, like function arguments in JavaScript, are positional. person\nis what each item is named in the above template, but human would work just\nas well.\n\nThe template inside of the {{#each}} block will be repeated once for\neach item in the array, with the each item set to the person block param.\n\nGiven an input array like:\n\n  1\n2\n3\n\n  [ { name: 'Yehuda' },\n  { name: 'Tom' },\n  { name: 'Trek' } ]\n\n\n\nThe above template will render HTML like this:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003eHello, Yehuda!\u003c/li\u003e\n  \u003cli\u003eHello, Tom!\u003c/li\u003e\n  \u003cli\u003eHello, Trek!\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\nLike other helpers, the {{#each}} helper is bound.  If a new item is added to\nor removed from the iterated array, the DOM will be updated without having to\nwrite any additional code. That said, Ember requires that you use special\nmethods\nto update bound arrays. Also be aware that using the key option with an each\nhelper\ncan improve re-render performance when an array is replaced with another\ncontaining similar items.\nAccessing an item's index\nDuring iteration, the index of each item in the array is provided as a second\nblock param. Block params are space-separated, without commas. For example:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each people as |person index|}}\n    \u003cli\u003eHello, {{person.name}}! You're number {{index}} in line\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\nEmpty Lists\nThe {{#each}}\nhelper can have a corresponding {{else}}. The contents of this block will\nrender if the array passed to {{#each}} is empty:\n\n  1\n2\n3\n4\n5\n\n  {{#each people as |person|}}\n  Hello, {{person.name}}!\n{{else}}\n  Sorry, nobody is here.\n{{/each}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e4a18275d9d8f6f71670bfc8e9f84a14","fields":[{"name":"title","value":"Displaying the Keys in an Object","type":"string"},{"name":"url","value":"/templates/displaying-the-keys-in-an-object/","type":"enum"},{"name":"body","value":"If you need to display all of the keys or values of a\nJavaScript object in your template, you can use the\n{{#each-in}}\nhelper:\n\n  \n    \n      /app/components/store-categories.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Component.extend({\n  willRender() {\n    // Set the \"categories\" property to a JavaScript object\n    // with the category name as the key and the value a list\n    // of products.\n    this.set('categories', {\n      'Bourbons': ['Bulleit', 'Four Roses', 'Woodford Reserve'],\n      'Ryes': ['WhistlePig', 'High West']\n    });\n  }\n});\n\n\n\n  \n    \n      /app/templates/components/store-categories.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  \u003cul\u003e\n  {{#each-in categories as |category products|}}\n    \u003cli\u003e{{category}}\n      \u003col\u003e\n        {{#each products as |product|}}\n          \u003cli\u003e{{product}}\u003c/li\u003e\n        {{/each}}\n      \u003c/ol\u003e\n    \u003c/li\u003e\n  {{/each-in}}\n\u003c/ul\u003e\n\n\n\nThe template inside of the {{#each-in}} block is repeated once for\neach key in the passed object. The first block parameter (category in\nthe above example) is the key for this iteration, while the second block\nparameter (products) is the actual value of that key.\n\nThe above example will print a list like this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  \u003cul\u003e\n  \u003cli\u003eBourbons\n    \u003col\u003e\n      \u003cli\u003eBulleit\u003c/li\u003e\n      \u003cli\u003eFour Roses\u003c/li\u003e\n      \u003cli\u003eWoodford Reserve\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003eRyes\n    \u003col\u003e\n      \u003cli\u003eWhistlePig\u003c/li\u003e\n      \u003cli\u003eHigh West\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\nRe-rendering\nThe {{#each-in}}\nhelper does not observe property changes to the object passed into it. In\n the above example, if you were to add a key to the component's categories\n property after the component had rendered, the template would not\n automatically update.\n\n  \n    \n      /app/components/store-categories.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  export default Ember.Component.extend({\n  willRender() {\n    this.set('categories', {\n      'Bourbons': ['Bulleit', 'Four Roses', 'Woodford Reserve'],\n      'Ryes': ['WhistlePig', 'High West']\n    });\n  },\n\n  actions: {\n    addCategory(category) {\n      // This won't work!\n      let categories = this.get('categories');\n      categories[category] = [];\n    }\n  }\n});\n\n\n\nIn order to cause a component to re-render after you have added,\nremoved or changed a property from an object, you need to either\nset() the\nproperty on the component again, or manually trigger a re-render of the\ncomponent via rerender():\n\n  \n    \n      /app/components/store-categories.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  export default Ember.Component.extend({\n  willRender() {\n    this.set('categories', {\n      'Bourbons': ['Bulleit', 'Four Roses', 'Woodford Reserve'],\n      'Ryes': ['WhistlePig', 'High West']\n    });\n  },\n\n  actions: {\n    addCategory(category) {\n      let categories = this.get('categories');\n      categories[category] = [];\n\n      // A manual re-render causes the DOM to be updated\n      this.rerender();\n    }\n  }\n});\n\n\nOrdering\nAn object's keys will be listed in the same order as the array returned\nfrom calling Object.keys on that object. If you want a different sort\norder, you should use Object.keys to get an array, sort that array\nwith the built-in JavaScript tools, and use the\n{{#each}}\nhelper instead.\nEmpty Lists\nThe {{#each-in}}\nhelper can have a matching {{else}}. The contents of this block will render\n if the object is empty, null, or undefined:\n\n  1\n2\n3\n4\n5\n\n  {{#each-in people as |name person|}}\n  Hello, {{name}}! You are {{person.age}} years old.\n{{else}}\n  Sorry, nobody is here.\n{{/each-in}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"619a7f1e4091d5852889772b71be63d0","fields":[{"name":"title","value":"Handlebars Basics","type":"string"},{"name":"url","value":"/templates/handlebars-basics/","type":"enum"},{"name":"body","value":"Ember uses the Handlebars templating library\nto power your app's user interface. Handlebars templates contain static HTML and dynamic content inside Handlebars expressions, which are invoked with double curly braces: {{}}.\n\nDynamic content inside a Handlebars expression is rendered with data-binding. This means if you update a property, your usage of that property in a template will be automatically updated to the latest value.\nDisplaying Properties\nTemplates are backed with a context. A context is an object from which\nHandlebars expressions read their properties. In Ember this is often a component. For templates rendered by a route (like application.hbs), the context is a controller.\n\nFor example, this application.hbs template will render a first and last name:\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n\n  Hello, \u003cstrong\u003e{{firstName}} {{lastName}}\u003c/strong\u003e!\n\n\n\nThe firstName and lastName properties are read from the\ncontext (the application controller in this case), and rendered inside the\n\u003cstrong\u003e HTML tag.\n\nTo provide a firstName and lastName to the above template, properties\nmust be added to the application controller. If you are following along with\nan Ember CLI application, you may need to create this file:\n\n  \n    \n      app/controllers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Ember from 'ember';\n\nexport default Ember.Controller.extend({\n  firstName: 'Trek',\n  lastName: 'Glowacki'\n});\n\n\n\nThe above template and controller render as the following HTML:\n\n  1\n\n  Hello, \u003cstrong\u003eTrek Glowacki\u003c/strong\u003e!\n\n\n\nRemember that {{firstName}} and {{lastName}} are bound data. That means\nif the value of one of those properties changes, the DOM will be updated\nautomatically.\n\nAs an application grows in size, it will have many templates backed by\ncontrollers and components.\nHelpers\nEmber gives you the ability to write your own helpers, to bring a minimum of logic into Ember templating.\n\nFor example, let's say you would like the ability to add a few numbers together, without needing to define a computed property everywhere you would like to do so.\n\n  \n    \n      app/helpers/sum.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export function sum(params) {\n  return params.reduce((a, b) =\u003e {\n    return a + b;\n  });\n};\n\nexport default Ember.Helper.helper(sum);\n\n\n\nThe above code will allow you invoke the sum() function as a {{sum}} handlebars \"helper\" in your templates:\n\n  1\n\n  \u003cp\u003eTotal: {{sum 1 2 3}}\u003c/p\u003e\n\n\n\nThis helper will output a value of 6.\n\nEmber ships with several built-in helpers, which you will learn more about in the following guides.\nNested Helpers\nHelpers have the ability to be nested within other helper invocations and also component invocations.\n\nThis gives you the flexibility to compute a value before it is passed in as an argument or an attribute of another.\n\nIt is not possible to nest curly braces {{}}, so the correct way to nest a helper is by using parentheses ():\n\n  1\n\n  {{sum (multiply 2 4) 2}}\n\n\n\nIn this example, we are using a helper to multiply 2 and 4 before passing the value into {{sum}}.\n\nThus, the output of these combined helpers is 10.\n\nAs you move forward with these template guides, keep in mind that a helper can be used anywhere a normal value can be used.\n\nThus, many of Ember's built-in helpers (as well as your custom helpers) can be used in nested form.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"cbc42197752a02e932444274327e4808","fields":[{"name":"title","value":"Input Helpers","type":"string"},{"name":"url","value":"/templates/input-helpers/","type":"enum"},{"name":"body","value":"The {{input}}\nand {{textarea}}\nhelpers in Ember.js are the easiest way to create common form controls. The\n{{input}} helper wraps the built-in Ember.TextField and Ember.Checkbox\nviews, while {{textarea}} wraps Ember.TextArea. Using these helpers,\nyou can create these views with declarations almost identical\nto how you'd create a traditional \u003cinput\u003e or \u003ctextarea\u003e element.\nText fields\n  1\n\n  {{input value=\"http://www.facebook.com\"}}\n\n\n\nWill become:\n\n  1\n\n  \u003cinput type=\"text\" value=\"http://www.facebook.com\"/\u003e\n\n\n\nYou can pass the following standard \u003cinput\u003e attributes within the input\nhelper:\n\n\n  `readonly``required``autofocus`\n  `value``placeholder``disabled`\n  `size``tabindex``maxlength`\n  `name``min``max`\n  `pattern``accept``autocomplete`\n  `autosave``formaction``formenctype`\n  `formmethod``formnovalidate``formtarget`\n  `height``inputmode``multiple`\n  `step``width``form`\n  `selectionDirection``spellcheck``type`\n\n\nIf these attributes are set to a quoted string, their values will be set\ndirectly on the element, as in the previous example. However, when left\nunquoted, these values will be bound to a property on the template's current\nrendering context. For example:\n\n  1\n\n  {{input type=\"text\" value=firstName disabled=entryNotAllowed size=\"50\"}}\n\n\n\nWill bind the disabled attribute to the value of entryNotAllowed in the\ncurrent context.\nActions\nTo dispatch an action on specific events, such as enter or key-press, use the following\n\n  1\n\n  {{input value=firstName key-press=\"updateFirstName\"}}\n\n\n\nEvent Names must be dasherized.\nCheckboxes\nYou can also use the\n{{input}}\nhelper to create a checkbox by setting its type:\n\n  1\n\n  {{input type=\"checkbox\" name=\"isAdmin\" checked=isAdmin}}\n\n\n\nCheckboxes support the following properties:\n\n\nchecked\ndisabled\ntabindex\nindeterminate\nname\nautofocus\nform\n\n\nWhich can be bound or set as described in the previous section.\nText Areas\n  1\n\n  {{textarea value=name cols=\"80\" rows=\"6\"}}\n\n\n\nWill bind the value of the text area to name on the current context.\n\n{{textarea}} supports binding and/or setting the following properties:\n\n\nvalue\nname\nrows\ncols\nplaceholder\ndisabled\nmaxlength\ntabindex\nselectionEnd\nselectionStart\nselectionDirection\nwrap\nreadonly\nautofocus\nform\nspellcheck\nrequired\n\nBinding dynamic attribute\nYou might need to bind a property dynamically to an input if you're building a flexible form, for example. To achieve this you need to use the {{get}} and {{mut}} in conjunction like shown in the following example:\n\n  1\n\n  {{input value=(mut (get person field))}}\n\n\n\nThe {{get}} helper allows you to dynamically specify which property to bind, while the {{mut}} helper allows the binding to be updated from the input. See the respective helper documentation for more detail.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a3506f82f88ccbc90b445c4c8d73f39a","fields":[{"name":"title","value":"Links","type":"string"},{"name":"url","value":"/templates/links/","type":"enum"},{"name":"body","value":"The {{link-to}} Helper\nYou create a link to a route using the\n{{link-to}}\nhelper.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('photos', function(){\n    this.route('edit', { path: '/:photo_id' });\n  });\n});\n\n\n\n  \n    \n      app/templates/photos.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each photos as |photo|}}\n    \u003cli\u003e{{#link-to \"photos.edit\" photo}}{{photo.title}}{{/link-to}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nIf the model for the photos template is a list of three photos, the\nrendered HTML would look something like this:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/photos/1\"\u003eHappy Kittens\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/2\"\u003ePuppy Running\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/3\"\u003eMountain Landscape\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\nThe {{link-to}} helper takes one or two arguments:\n\n\nThe name of a route. In this example, it would be index, photos, or\nphotos.edit.\nAt most one model for each dynamic segment.\nBy default, Ember.js will replace each segment with the value of the corresponding object's id property.\nIn the example above, the second argument is each photo object, and the id property is used to fill in\nthe dynamic segment with either 1, 2, or 3. If there is no model to pass to the helper, you can provide\nan explicit value instead:\n\n\n  \n    \n      app/templates/photos.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#link-to \"photos.edit\" 1}}\n  First Photo Ever\n{{/link-to}}\n\n\n\nWhen the rendered link matches the current route, and the same\nobject instance is passed into the helper, then the link is given\nclass=\"active\". For example, if you were at the URL /photos/2,\nthe first example above would render as:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/photos/1\"\u003eHappy Kittens\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/2\" class=\"active\"\u003ePuppy Running\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/3\"\u003eMountain Landscape\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\nExample for Multiple Segments\nIf the route is nested, you can supply a model or an identifier for each dynamic\nsegment.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Router.map(function() {\n  this.route('photos', function(){\n    this.route('photo', { path: '/:photo_id' }, function(){\n      this.route('comments');\n      this.route('comment', { path: '/comments/:comment_id' });\n    });\n  });\n});\n\n\n\n  \n    \n      app/templates/photo/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cdiv class=\"photo\"\u003e\n  {{body}}\n\u003c/div\u003e\n\n\u003cp\u003e{{#link-to \"photos.photo.comment\" primaryComment}}Main Comment{{/link-to}}\u003c/p\u003e\n\n\n\nIf you specify only one model, it will represent the innermost dynamic segment :comment_id.\nThe :photo_id segment will use the current photo.\n\nAlternatively, you could pass both a photo's ID and a comment to the helper:\n\n  \n    \n      app/templates/photo/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cp\u003e\n  {{#link-to 'photo.comment' 5 primaryComment}}\n    Main Comment for the Next Photo\n  {{/link-to}}\n\u003c/p\u003e\n\n\n\nIn the above example, the model hook for PhotoRoute will run with params.photo_id = 5.  The model hook for\nCommentRoute won't run since you supplied a model object for the comment segment. The comment's id will\npopulate the url according to CommentRoute's serialize hook.\nSetting query-params\nThe query-params helper can be used to set query params on a link:\n\n  1\n2\n3\n4\n5\n\n  // Explicitly set target query params\n{{#link-to \"posts\" (query-params direction=\"asc\")}}Sort{{/link-to}}\n\n// Binding is also supported\n{{#link-to \"posts\" (query-params direction=otherDirection)}}Sort{{/link-to}}\n\n\nUsing link-to as an inline helper\nIn addition to being used as a block expression, the\nlink-to\nhelper can also be used in inline form by specifying the link text as the first\nargument to the helper:\n\n  1\n2\n\n  A link in {{#link-to \"index\"}}Block Expression Form{{/link-to}},\nand a link in {{link-to \"Inline Form\" \"index\"}}.\n\n\n\nThe output of the above would be:\n\n  1\n2\n\n  A link in \u003ca href=\"/\"\u003eBlock Expression Form\u003c/a\u003e,\nand a link in \u003ca href=\"/\"\u003eInline Form\u003c/a\u003e.\n\n\nAdding additional attributes on a link\nWhen generating a link you might want to set additional attributes for it. You can do this with additional\narguments to the link-to helper:\n\n  1\n2\n3\n\n  \u003cp\u003e\n  {{link-to \"Edit this photo\" \"photo.edit\" photo class=\"btn btn-primary\"}}\n\u003c/p\u003e\n\n\n\nMany of the common HTML properties you would want to use like class, and rel will work. When\nadding class names, Ember will also apply the standard ember-view and possibly active class names.\nReplacing history entries\nThe default behavior for\nlink-to\nis to add entries to the browser's history when transitioning between the\nroutes. However, to replace the current entry in the browser's history you\ncan use the replace=true option:\n\n  1\n2\n3\n4\n5\n\n  \u003cp\u003e\n  {{#link-to \"photo.comment\" 5 primaryComment replace=true}}\n    Main Comment for the Next Photo\n  {{/link-to}}\n\u003c/p\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4d51ca61c042a6e0f4dfd8e0cdb116ed","fields":[{"name":"title","value":"Writing Helpers","type":"string"},{"name":"url","value":"/templates/writing-helpers/","type":"enum"},{"name":"body","value":"Helpers allow you to add additional functionality to your\ntemplates beyond what is included out-of-the-box in Ember. Helpers are\nmost useful for transforming raw values from models and components into\na format more appropriate for your users.\n\nFor example, imagine we have an Invoice model that contains a\ntotalDue attribute, which represents the total amount due for that\ninvoice.  Because we do not want our company to go out of business due\nto strange JavaScript rounding errors, we store this value in cents\ninstead of a floating point dollar value.\n\nHowever, if we display dollar values to our users as \"100¢\" instead of\n\"$1.00\", they may be very confused. We can write a helper to\nformat these values into the appropriate human-readable form.\n\nLet's create a format-currency helper that takes an integer count of\ncents and turns it into formatted dollars.\n\nTo use the format-currency helper, you call it using curly braces in\nyour template:\n\n  1\n\n  Your total is {{format-currency model.totalDue}}.\n\n\n\nLet's now implement the helper. Helpers are functions that take\none or more inputs and return a single output that should be put into\nthe HTML.\n\nTo add a new helper, create a file with the name of the helper you want\n(e.g. format-currency.js) in your application's helpers directory.\nYou can also have Ember generate the file for you from the command line:\n\n  1\n\n  ember generate helper format-currency\n\n\n\nThat file should export a function wrapped with Ember.Helper.helper():\n\n  \n    \n      app/helpers/format-currency.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export function formatCurrency(params) {\n  let value = params[0],\n      dollars = Math.floor(value / 100),\n      cents = value % 100,\n      sign = '$';\n\n  if (cents.toString().length === 1) { cents = '0' + cents; }\n  return `${sign}${dollars}.${cents}`;\n}\n\nexport default Ember.Helper.helper(formatCurrency);\n\n\n\nIn this example, the function receives a dollar amount in cents as the first\nparameter (params[0]). We then use regular JavaScript to turn the\ncount of cents into a formatted string, like \"$5.00\".\n\nWhenever you use your helper in a template, Ember will call this\nfunction and insert whatever you return from the helper into the DOM.\n\nSo, if we want to display a purchase total we can pass the value into the template in cents:\n\n  1\n\n  Your total is {{format-currency 250}}.\n\n\n\nAnd Ember makes use of our new helper function to replace the content inside the {{ }} with the formatted amount.\n\n  1\n\n  Your total is $2.50.\n\n\n\nWhenever the arguments you've passed to a helper change, whether they\ncome from a model or a component, Ember will automatically call your\nhelper again with the new values and keep the page up-to-date.\nHelper Names\nUnlike components, helpers do not require a dash (-) character in\ntheir name.\nHelper Arguments\nYou can pass one or more arguments to be used\ninside the function. In the above example, we passed the amount in cents\nas the first and only argument.\n\nTo pass multiple arguments to a helper, add them as a space-separated\nlist after the helper name:\n\n  1\n\n  {{my-helper \"hello\" \"world\"}}\n\n\n\nAn array of these arguments is passed to the helper function:\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Helper.helper(function(params) {\n  let arg1 = params[0];\n  let arg2 = params[1];\n\n  console.log(arg1); // =\u003e \"hello\"\n  console.log(arg2); // =\u003e \"world\"\n});\n\n\n\nYou can use JavaScript's destructuring assignment shorthand to clean up\nthe code. This example is equivalent to the above example (note the function signature):\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Helper.helper(function([arg1, arg2]) {\n  console.log(arg1); // =\u003e \"hello\"\n  console.log(arg2); // =\u003e \"world\"\n});\n\n\nNamed Arguments\nNormal arguments are useful for passing data to be transformed into\nhelper functions. However, because the order in which you pass arguments\nmatters, it is usually best not to have helpers take more than one or\ntwo of them.\n\nThat said, sometimes you may want to make behavior of helpers\nconfigurable by the developers that call them from their templates. For\nexample, let's abandon our Americentric ways and update our\nformat-currency helper to take an optional configuration for which\ncurrency symbol to display.\n\nHelpers allow you to pass named arguments as a JavaScript\nobject that contains the name of the argument along with an associated\nvalue.  The order in which named arguments are supplied does not affect\nfunctionality.\n\nIn this example, we can pass a sign argument to our format-currency\nhelper:\n\n  1\n\n  {{format-currency 350 sign=\"£\"}}\n\n\n\nWe'd like our helper to print pounds sterling rather than US dollars:\n\n  1\n\n  £3.50\n\n\n\nThe object containing named arguments is passed as the second argument\nto the helper function.  Here is our example from above, updated to\nsupport the optional sign option:\n\n  \n    \n      app/helpers/format-currency.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Helper.helper(function(params, namedArgs) {\n  let value = params[0],\n      dollars = Math.floor(value / 100),\n      cents = value % 100,\n      sign = namedArgs.sign === undefined ? '$' : namedArgs.sign;\n\n  if (cents.toString().length === 1) { cents = '0' + cents; }\n  return `${sign}${dollars}.${cents}`;\n});\n\n\n\nYou can pass as many named arguments as you'd like. They get added to the\nnamedArgs argument passed to the function:\n\n  1\n\n  {{my-helper option1=\"hello\" option2=\"world\" option3=\"goodbye cruel world\"}}\n\n\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Helper.helper(function(params, namedArgs) {\n  console.log(namedArgs.option1); // =\u003e \"hello\"\n  console.log(namedArgs.option2); // =\u003e \"world\"\n  console.log(namedArgs.option3); // =\u003e \"goodbye cruel world\"\n});\n\n\n\nYou can use JavaScript's destructuring assignment shorthand in this case\nas well to clean up the above code:\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Helper.helper(function(params, { option1, option2, option3 }) {\n  console.log(option1); // =\u003e \"hello\"\n  console.log(option2); // =\u003e \"world\"\n  console.log(option3); // =\u003e \"goodbye cruel world\"\n});\n\n\n\nIn sum, arguments are good for passing values:\n\n  1\n\n  {{format-date currentDate}}\n\n\n\nHashes are useful for configuring the behavior of a helper:\n\n  1\n\n  {{print-current-date format=\"YYYY MM DD\"}}\n\n\n\nYou can have as many of both as you want, so long as the parameters come\nfirst:\n\n  1\n\n  {{format-date-and-time date time format=\"YYYY MM DD h:mm\" locale=\"en\"}}\n\n\n\nThe above example contains two arguments:\n\n\ndate\ntime\n\n\nAnd two named arguments:\n\n\nformat=\"YYY MM DD h:mm\"\nlocale=\"en\"\n\nClass-based Helpers\nBy default, helpers are stateless. They are passed inputs (parameters\nand a hash), they perform an operation on those inputs, and return a\nsingle output. They have no side-effects and don't save any information\nthat is used on subsequent runs of the function.\n\nIn some situations, however, you may need to write a helper that interacts with\nthe rest of your application. You can create class-based helpers that have\naccess to services in your application, and can optionally save state as well,\nalthough this is usually unnecessary and error-prone.\n\nTo create a class-based helper, rather than exporting a simple function, you\nshould export a subclass of Ember.Helper. Helper classes must contain a\ncompute method that behaves the same as the function passed to\nEmber.Helper.helper.  In order to access a service, you must first inject it\ninto the class-based helper.  Once added, you can call the service's methods or\naccess its properties from within the compute() method.\n\nAs an exercise, here is the above format-currency helper re-factored\ninto a class-based helper:\n\n  \n    \n      app/helpers/format-currency.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Helper.extend({\n  compute(params, hash) {\n    let value = params[0],\n        dollars = Math.floor(value / 100),\n        cents = value % 100,\n        sign = hash.sign === undefined ? '$' : hash.sign;\n\n    if (cents.toString().length === 1) { cents = '0' + cents; }\n    return `${sign}${dollars}.${cents}`;\n  }\n});\n\n\n\nThis is exactly equivalent to the format-currency example above. You\ncan think of the function version as a shorthand for the longer class\nform if it does not require dependency injection.\n\nAs another example, let's make a helper utilizing an authentication\nservice that welcomes users by their name if they're logged in:\n\n  \n    \n      app/helpers/is-authenticated.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Helper.extend({\n  authentication: Ember.inject.service(),\n  compute() {\n    let authentication = this.get('authentication');\n\n    if (authentication.get('isAuthenticated')) {\n      return 'Welcome back, ' + authentication.get('username');\n    } else {\n      return 'Not logged in';\n    }\n  }\n});\n\n\nEscaping HTML Content\nTo protect your application from cross-site scripting attacks (XSS),\nEmber automatically escapes any value you return from a helper so that\nthe browser will not interpret it as HTML.\n\nFor example, here's a make-bold helper that returns a string containing HTML:\n\n  \n    \n      app/helpers/make-bold.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Helper.helper(function(params) {\n  return `\u003cb\u003e${params[0]}\u003c/b\u003e`;\n});\n\n\n\nYou can invoke it like this:\n\n  1\n\n  {{make-bold \"Hello world\"}}\n\n\n\nEmber will escape the HTML tags, like this:\n\n  1\n\n  \u0026lt;b\u0026gt;Hello world\u0026lt;/b\u0026gt;\n\n\n\nThis shows the literal string \u003cb\u003eHello world\u003c/b\u003e to the user, rather\nthan the text in bold as you probably intended. We can tell Ember not to\nescape the return value (that is, that it is safe) by using the\nhtmlSafe string utility:\n\n  \n    \n      app/helpers/make-bold.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Helper.helper(function(params) {\n  return Ember.String.htmlSafe(`\u003cb\u003e${params[0]}\u003c/b\u003e`);\n});\n\n\n\nIf you return a SafeString (a string that has been wrapped in a call\nto htmlSafe), Ember knows that you have vouched on its behalf that it\ncontains no malicious HTML.\n\nHowever, note that in the above code we may have inadvertently\nintroduced an XSS vulnerability into our application! By blindly marking\nthe string as safe, a malicious user could get their own HTML into our\napp, allowing them to do things like access sensitive customer data.\n\nFor example, imagine that we have a chat app  and use our make-bold\nhelper to welcome the new users into the channel:\n\n  1\n\n  Welcome back! {{make-bold model.firstName}} has joined the channel.\n\n\n\nNow a malicious user simply needs to set their firstName to a string\ncontaining HTML (like a \u003cscript\u003e tag that sends private customer data\nto their server, for example) and every user in that chat room has been\ncompromised.\n\nIn general, you should prefer using components if you are wrapping\ncontent in HTML. However, if you really want to include a mix of HTML\nand values from models in what you return from the helper, make sure you\nescape anything that may have come from an untrusted user with the\nescapeExpression utility:\n\n  \n    \n      app/helpers/make-bold.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Helper.helper(function(params) {\n  let value = Ember.Handlebars.Utils.escapeExpression(params[0]);\n  return Ember.String.htmlSafe(`\u003cb\u003e${value}\u003c/b\u003e`);\n});\n\n\n\nNow the value passed into the helper has its HTML escaped, but the trusted\n\u003cb\u003e tags that we want to wrap the value in are not escaped. A\nmalicious user setting their firstName to something containing HTML\nwould see this:\n\n  1\n2\n\n  Welcome back! \u003cb\u003e\u0026lt;script\ntype=\"javascript\"\u0026gt;alert('pwned!');\u0026lt;/script\u0026gt;\u003c/b\u003e has joined the channel.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6b92476d3f19a3ac5f6ea85e474595d8","fields":[{"name":"title","value":"Acceptance Tests","type":"string"},{"name":"url","value":"/testing/acceptance/","type":"enum"},{"name":"body","value":"To create an acceptance test, run ember generate acceptance-test \u003cname\u003e.\nFor example:\n\n  1\n\n  ember g acceptance-test login\n\n\n\nThis generates this file:\n\n  \n    \n      tests/acceptance/login-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  import { test } from 'qunit';\nimport moduleForAcceptance from 'people/tests/helpers/module-for-acceptance';\n\nmoduleForAcceptance('Acceptance | login');\n\ntest('visiting /login', function(assert) {\n  visit('/login');\n\n  andThen(function() {\n    assert.equal(currentURL(), '/login');\n  });\n});\n\n\n\nmoduleForAcceptance deals with application setup and teardown. The last few lines, within\nthe function test, contain an example test.\n\nAlmost every test has a pattern of visiting a route, interacting with the page\n(using the helpers), and checking for expected changes in the DOM.\n\nFor example:\n\n  \n    \n      tests/acceptance/new-post-appears-first-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  test('should add new post', function(assert) {\n  visit('/posts/new');\n  fillIn('input.title', 'My new post');\n  click('button.submit');\n  andThen(() =\u003e assert.equal(find('ul.posts li:first').text(), 'My new post'));\n});\n\n\nTest Helpers\nOne of the major issues in testing web applications is that all code is\nevent-driven, therefore has the potential to be asynchronous (i.e. output can\nhappen out of sequence from input). This has the ramification that code can be\nexecuted in any order.\n\nAn example may help here: Let's say a user clicks two buttons, one after another\nand both load data from different servers. They take different times to respond.\n\nWhen writing your tests, you need to be keenly aware of the fact that you cannot\nbe sure that the response will return immediately after you make your requests,\ntherefore your assertion code (the \"tester\") needs to wait for the thing being\ntested (the \"testee\") to be in a synchronized state. In the example above, that\nwould be when both servers have responded and the test code can go about its\nbusiness checking the data (whether it is mock data, or real data).\n\nThis is why all Ember's test helpers are wrapped in code that ensures Ember is\nback in a synchronized state when it makes its assertions. It saves you from\nhaving to wrap everything in code that does that, and it makes it easier to read\nyour tests because there's less boilerplate in them.\n\nEmber includes several helpers to facilitate acceptance testing. There are two\ntypes of helpers: asynchronous and synchronous.\nAsynchronous Helpers\nAsynchronous helpers are \"aware\" of (and wait for) asynchronous behavior within\nyour application, making it much easier to write deterministic tests.\n\nAlso, these helpers register themselves in the order that you call them and will\nbe run in a chain; each one is only called after the previous one finishes. You can rest assured, therefore, that the order you call them in will also\nbe their execution order, and that the previous helper has finished before the\nnext one starts.\n\n\nclick(selector)\n\n\nClicks an element and triggers any actions triggered by the element's click\nevent and returns a promise that fulfills when all resulting async behavior\nis complete.\n\nfillIn(selector, value)\n\n\nFills in the selected input with the given value and returns a promise that\nfulfills when all resulting async behavior is complete. Works with \u003cselect\u003e elements as well as \u003cinput\u003e elements. Keep in mind that with \u003cselect\u003e elements, value must be set to the value of the \u003coption\u003e tag, rather than its content (for example, true rather than \"Yes\").\n\nkeyEvent(selector, type, keyCode)\n\n\nSimulates a key event type, e.g. keypress, keydown, keyup with the\ndesired keyCode on element found by the selector.\n\ntriggerEvent(selector, type, options)\n\n\nTriggers the given event, e.g. blur, dblclick on the element identified\nby the provided selector.\n\nvisit(url)\n\n\nVisits the given route and returns a promise that fulfills when all resulting\nasync behavior is complete.\n\n\nSynchronous Helpers\nSynchronous helpers are performed immediately when triggered.\n\n\ncurrentPath()\n\n\nReturns the current path.\n\ncurrentRouteName()\n\n\nReturns the currently active route name.\n\ncurrentURL()\n\n\nReturns the current URL.\n\nfind(selector, context)\n\n\nFinds an element within the app's root element and within the context\n(optional). Scoping to the root element is especially useful to avoid\nconflicts with the test framework's reporter, and this is done by default\nif the context is not specified.\n\n\nWait Helpers\nThe andThen helper will wait for all preceding asynchronous helpers to\ncomplete prior to progressing forward. Let's take a look at the following\nexample.\n\n  \n    \n      tests/acceptance/new-post-appears-first-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  test('should add new post', function(assert) {\n  visit('/posts/new');\n  fillIn('input.title', 'My new post');\n  click('button.submit');\n  andThen(() =\u003e assert.equal(find('ul.posts li:first').text(), 'My new post'));\n});\n\n\n\nFirst we visit the new posts URL \"/posts/new\", enter the text \"My new post\"\ninto an input control with the CSS class \"title\", and click on a button whose\nclass is \"submit\".\n\nWe then make a call to the andThen helper which will wait for the preceding\nasynchronous test helpers to complete (specifically, andThen will only be\ncalled after the new posts URL was visited, the text filled in and the\nsubmit button was clicked, and the browser has returned from doing whatever\nthose actions required). Note andThen has a single argument of the function\nthat contains the code to execute after the other test helpers have finished.\n\nIn the andThen helper, we finally make our call to assert.equal which makes an\nassertion that the text found in the first li of the ul whose class is \"posts\"\nis equal to \"My new post\".\nCustom Test Helpers\nFor creating your own test helper, run ember generate test-helper\n\u003chelper-name\u003e. Here is the result of running ember g test-helper\nshouldHaveElementWithCount:\n\n  \n    \n      tests/helpers/should-have-element-with-count.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Test.registerAsyncHelper(\n    'shouldHaveElementWithCount', function(app) {\n});\n\n\n\nEmber.Test.registerAsyncHelper and Ember.Test.registerHelper\nare used to register test helpers that will be injected when startApp is\ncalled. The difference between Ember.Test.registerHelper and\nEmber.Test.registerAsyncHelper is that the latter will not run until any\nprevious async helper has completed and any subsequent async helper will wait\nfor it to finish before running.\n\nThe helper method will always be called with the current Application as the\nfirst parameter. Other parameters, such as assert, need to be provided when calling the helper. Helpers need to be registered prior to calling\nstartApp, but ember-cli will take care of it for you.\n\nHere is an example of a non-async helper:\n\n  \n    \n      tests/helpers/should-have-element-with-count.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Test.registerHelper('shouldHaveElementWithCount',\n  function(app, assert, selector, n, context) {\n    const el = findWithAssert(selector, context);\n    const count = el.length;\n    assert.equal(n, count, `found ${count} times`);\n  }\n);\n\n// shouldHaveElementWithCount(assert, 'ul li', 3);\n\n\n\nHere is an example of an async helper:\n\n  \n    \n      tests/helpers/dblclick.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Test.registerAsyncHelper('dblclick',\n  function(app, assert, selector, context) {\n    let $el = findWithAssert(selector, context);\n    Ember.run(() =\u003e $el.dblclick());\n  }\n);\n\n// dblclick(assert, '#person-1')\n\n\n\nAsync helpers also come in handy when you want to group interaction\ninto one helper. For example:\n\n  \n    \n      tests/helpers/add-contact.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Test.registerAsyncHelper('addContact',\n  function(app, name) {\n    fillIn('#name', name);\n    click('button.create');\n  }\n);\n\n// addContact('Bob');\n// addContact('Dan');\n\n\n\nFinally, don't forget to add your helpers in tests/.jshintrc and in\ntests/helpers/start-app.js. In tests/.jshintrc you need to add it in the\npredef section, otherwise you will get failing jshint tests:\n\n  \n    \n      tests/.jshintc\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  {\n  \"predef\": [\n    \"document\",\n    \"window\",\n    \"location\",\n    ...\n    \"shouldHaveElementWithCount\",\n    \"dblclick\",\n    \"addContact\"\n  ],\n  ...\n}\n\n\n\nIn tests/helpers/start-app.js you need to import the helper file: it\nwill be registered then.\n\n  \n    \n      tests/helpers/start-app.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import Ember from 'ember';\nimport Application from '../../app';\nimport Router from '../../router';\nimport config from '../../config/environment';\nimport './should-have-element-with-count';\nimport './dblclick';\nimport './add-contact';\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d111ada688dff43a36c7d27aea287dc5","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/testing/","type":"enum"},{"name":"body","value":"Testing is a core part of the Ember framework and its development cycle.\n\nLet's assume you are writing an Ember application which will serve as a blog.\nThis application would likely include models such as user and post. It would\nalso include interactions such as login and create post. Let's finally\nassume that you would like to have automated tests in place for your application.\n\nThere are three different classifications of tests that you will need:\nAcceptance, Unit, and Integration.\nAcceptance Tests\nAcceptance tests are used to test user interaction and application flow.  The tests interact\nwith the application in the same ways that a user would, by doing things like filling out\nform fields and clicking buttons.  Acceptance tests ensure that the features within\na project are basically functional, and are valuable in ensuring the core features of a\nproject have not regressed, and that the project's goals are being met.\n\nIn the example scenario above, some acceptance tests one might write are:\n\n\nA user is able to log in via the login form.\nA user is able to create a blog post.\nAfter saving a new post successfully, a user is then shown the list of prior posts.\nA visitor does not have access to the admin panel.\n\nUnit Tests\nUnit tests are used to test isolated chunks of functionality, or \"units\".\nThey can be written against any isolated application logic.\n\nSome specific examples of units tests are:\n\n\nA fullname attribute is computed which is the aggregate of its first and last.\nThe serializer properly converts the blog request payload into a blog post model object.\nBlog dates are properly formatted.\n\nIntegration Tests\nIntegration tests serve as a middle ground between acceptance tests, which only interact\nwith the full system through user endpoints, and unit tests, which interact with specific\ncode algorithms on a micro level. Integration tests verify interactions between various\nparts of the application, such as behavior between UI controls.  They are valuable\nin ensuring data and actions are properly passed between different parts of the system, and\nprovide confidence that parts of the system will work within the application under multiple\nscenarios.\n\nIt is recommended that components be tested with integration tests because the component\ninteracts with the system in the same way that it will within the context of the application,\nincluding being rendered from a template and receiving Ember's lifecycle hooks.\n\nExamples of integration tests are:\n\n\nAn author's full name and date are properly displayed in a blog post.\nA user is prevented from typing more than 50 characters into post's title field.\nSubmitting a post without a title displays a red validation state on the field and gives the user text indicating that the title is required.\nThe blog post list scrolls to position a new post at the top of the viewport.\n\nTesting Frameworks\nQUnit is the default testing framework for this guide, but others are supported through third-party addons.\nHow to Run Your Tests\nRun your tests with ember test on the command-line. You can re-run your tests on every file-change with ember test --server.\n\nTests can also be executed when you are running a local development server (started by running ember server), at the /tests URI which renders the tests/index.html template.\nA word of caution using this approach:\nTests run using ember server have the environment configuration development, whereas tests executed under ember test --server are run with the configuration test.  This could cause differences in execution, such as which libraries are loaded and available.  Therefore its recommended that you use ember test --server for test execution.\n\nThese commands run your tests using Testem to make testing multiple browsers very easy. You can configure Testem using the testem.js file in your application root.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a0e26dbd7878af23525081f7441c1b0","fields":[{"name":"title","value":"Testing Components","type":"string"},{"name":"url","value":"/testing/testing-components/","type":"enum"},{"name":"body","value":"Components can be tested with integration tests using the moduleForComponent helper.\n\nLet's assume we have a component with a style property that is updated\nwhenever the value of the name property changes. The style attribute of the\ncomponent is bound to its style property.\n\n\nYou can follow along by generating your own component with ember generate\ncomponent pretty-color.\n\n\n  \n    \n      app/components/pretty-color.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Component.extend({\n  attributeBindings: ['style'],\n\n  style: Ember.computed('name', function() {\n    const name = this.get('name');\n    return `color: ${name}`;\n  })\n});\n\n\n\n  \n    \n      app/templates/components/pretty-color.hbs\n    \n  \n\n  1\n\n  Pretty Color: {{name}}\n\n\n\nThe moduleForComponent helper will find the component by name (pretty-color)\nand its template (if available).  Make sure to set integration: true to enable\nintegration test capability.\n\n  \n    \n      tests/integration/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n\n  moduleForComponent('pretty-color', 'Integration | Component | pretty color', {\n  integration: true\n});\n\n\n\nEach test following the moduleForComponent call has access to the render()\nfunction, which lets us create a new instance of the component by declaring\nthe component in template syntax, as we would in our application.\n\nWe can test that changing the component's name property updates the\ncomponent's style attribute and is reflected in the  rendered HTML:\n\n  \n    \n      tests/integration/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  test('should change colors', function(assert) {\n  assert.expect(2);\n\n  // set the outer context to red\n  this.set('colorValue', 'red');\n\n  this.render(hbs`{{pretty-color name=colorValue}}`);\n\n  assert.equal(this.$('div').attr('style'), 'color: red', 'starts as red');\n\n  this.set('colorValue', 'blue');\n\n  assert.equal(this.$('div').attr('style'), 'color: blue', 'updates to blue');\n});\n\n\n\nWe might also test this component to ensure that the content of its template is\nbeing rendered properly:\n\n  \n    \n      tests/integration/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  test('should be rendered with its color name', function(assert) {\n  assert.expect(2);\n\n  this.set('colorValue', 'orange');\n\n  this.render(hbs`{{pretty-color name=colorValue}}`);\n\n  assert.equal(this.$().text().trim(), 'Pretty Color: orange', 'text starts as orange');\n\n  this.set('colorValue', 'green');\n\n  assert.equal(this.$().text().trim(), 'Pretty Color: green', 'text switches to green');\n\n});\n\n\nTesting User Interaction\nComponents are a great way to create powerful, interactive, and self-contained\ncustom HTML elements. It is important to test the component's methods and the\nuser's interaction with the component.\n\nImagine you have the following component that changes its title when a button is\nclicked on:\n\n\nYou can follow along by generating your own component with ember generate\ncomponent magic-title.\n\n\n  \n    \n      app/components/magic-title.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Component.extend({\n  title: 'Hello World',\n\n  actions: {\n    updateTitle() {\n      this.set('title', 'This is Magic');\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/components/magic-title.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003ch2\u003e{{title}}\u003c/h2\u003e\n\n\u003cbutton {{action \"updateTitle\"}}\u003e\n  Update Title\n\u003c/button\u003e\n\n\n\njQuery triggers can be used to simulate user interaction and test that the title\nis updated when the button is clicked on:\n\n  \n    \n      tests/integration/components/magic-title-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  test('should update title on button click', function(assert) {\n  assert.expect(2);\n\n  this.render(hbs`{{magic-title}}`);\n\n  assert.equal(this.$('h2').text(), 'Hello World', 'initial text is hello world');\n\n  //Click on the button\n  this.$('button').click();\n\n  assert.equal(this.$('h2').text(), 'This is Magic', 'title changes after click');\n});\n\n\nTesting Actions\nComponents starting in Ember 2 utilize closure actions. Closure actions allow components\nto directly invoke functions provided by outer components.\n\nFor example, imagine you have a comment form component that invokes a\nsubmitComment action when the form is submitted, passing along the form's data:\n\n\nYou can follow along by generating your own component with ember generate\ncomponent comment-form.\n\n\n  \n    \n      app/components/comment-form.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Component.extend({\n  comment: '',\n\n  actions: {\n    submitComment() {\n      this.get('submitComment')({ comment: this.get('comment') });\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/components/comment-form.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  \u003cform {{action \"submitComment\" on=\"submit\"}}\u003e\n  \u003clabel\u003eComment:\u003c/label\u003e\n  {{textarea value=comment}}\n\n  \u003cinput type=\"submit\" value=\"Submit\"/\u003e\n\u003c/form\u003e\n\n\n\nHere's an example test that asserts that the specified externalAction function\nis invoked when the component's internal submitComment action is triggered by making use\nof a test double (dummy function):\n\n  \n    \n      tests/integration/components/comment-form-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  test('should trigger external action on form submit', function(assert) {\n\n  // test double for the external action\n  this.set('externalAction', (actual) =\u003e {\n    let expected = { comment: 'You are not a wizard!' };\n    assert.deepEqual(actual, expected, 'submitted value is passed to external action');\n  });\n\n  this.render(hbs`{{comment-form submitComment=(action externalAction)}}`);\n\n  // fill out the form and force an onchange\n  this.$('textarea').val('You are not a wizard!');\n  this.$('textarea').change();\n\n  // click the button to submit the form\n  this.$('input').click();\n});\n\n\nStubbing Services\nIn cases where components have dependencies on Ember services, it is possible to stub these\ndependencies for integration tests. You stub Ember services by using the built-in register()\nfunction to register your stub service in place of the default.\n\nImagine you have the following component that uses a location service to display the city\nand country of your current location:\n\n\nYou can follow along by generating your own component with ember generate\ncomponent location-indicator.\n\n\n  \n    \n      app/components/location-indicator.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Component.extend({\n  locationService: Ember.inject.service('location-service'),\n\n  // when the coordinates change, call the location service to get the current city and country\n  city: Ember.computed('locationService.currentLocation', function () {\n    return this.get('locationService').getCurrentCity();\n  }),\n\n  country: Ember.computed('locationService.currentLocation', function () {\n    return this.get('locationService').getCurrentCountry();\n  })\n});\n\n\n\n  \n    \n      app/templates/components/location-indicator.hbs\n    \n  \n\n  1\n\n  You currently are located in {{city}}, {{country}}\n\n\n\nTo stub the location service in your test, create a local stub object that extends\nEmber.Service, and register the stub as the service your tests need in the\nbeforeEach function.  In this case we initially force location to New York.\n\n  \n    \n      tests/integration/components/location-indicator-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n  import { moduleForComponent, test } from 'ember-qunit';\nimport hbs from 'htmlbars-inline-precompile';\nimport Ember from 'ember';\n\n//Stub location service\nconst locationStub = Ember.Service.extend({\n  city: 'New York',\n  country: 'USA',\n  currentLocation: {\n    x: 1234,\n    y: 5678\n  },\n\n  getCurrentCity() {\n    return this.get('city');\n  },\n  getCurrentCountry() {\n    return this.get('country');\n  }\n});\n\nmoduleForComponent('location-indicator', 'Integration | Component | location indicator', {\n  integration: true,\n\n  beforeEach: function () {\n    this.register('service:location-service', locationStub);\n    // Calling inject puts the service instance in the test's context,\n    // making it accessible as \"locationService\" within each test\n    this.inject.service('location-service', { as: 'locationService' });\n  }\n});\n\n\n\nOnce the stub service is registered the test simply needs to check that the stub data that\nis being returned from the service is reflected in the component output.\n\n  \n    \n      tests/integration/components/location-indicator-test.js\n    \n  \n\n  1\n2\n3\n4\n\n  test('should reveal current location', function(assert) {\n  this.render(hbs`{{location-indicator}}`);\n  assert.equal(this.$().text().trim(), 'You currently are located in New York, USA');\n});\n\n\n\nIn the next example, we'll add another test that validates that the display changes\nwhen we modify the values on the service.\n\n  \n    \n      tests/integration/components/location-indicator-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  test('should change displayed location when current location changes', function (assert) {\n  this.render(hbs`{{location-indicator}}`);\n  assert.equal(this.$().text().trim(), 'You currently are located in New York, USA', 'origin location should display');\n  this.set('locationService.city', 'Beijing');\n  this.set('locationService.country', 'China');\n  this.set('locationService.currentLocation', { x: 11111, y: 222222 });\n  assert.equal(this.$().text().trim(), 'You currently are located in Beijing, China', 'location display should change');\n});\n\n\nWaiting on Asynchronous Behavior\nOften, interacting with a component will cause asynchronous behavior to occur, such as HTTP requests, or timers.  The\nwait helper is designed to handle these scenarios, by providing a hook to ensure assertions are made after\nall Ajax requests and timers are complete.\n\nImagine you have a typeahead component that uses Ember.run.debounce\nto limit requests to the server, and you want to verify that results are displayed after typing a character.\n\n\nYou can follow along by generating your own component with ember generate\ncomponent delayed-typeahead.\n\n\n  \n    \n      app/components/delayed-typeahead.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Component.extend({\n  actions: {\n    handleTyping() {\n      //the fetchResults function is passed into the component from its parent\n      Ember.run.debounce(this, this.get('fetchResults'), this.get('searchValue'), 250);\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/components/delayed-typeahead.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  {{input value=searchValue key-up=(action 'handleTyping')}}\n\u003cul\u003e\n{{#each results as |result|}}\n  \u003cli class=\"result\"\u003e{{result.name}}\u003c/li\u003e\n{{/each}}\n\u003c/ul\u003e\n\n\n\nIn your integration test, use the wait function to wait until your debounce timer is up and then assert\nthat the page is rendered appropriately.\n\n  \n    \n      tests/integration/components/delayed-typeahead-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n  import { moduleForComponent, test } from 'ember-qunit';\nimport wait from 'ember-test-helpers/wait';\nimport hbs from 'htmlbars-inline-precompile';\n\nmoduleForComponent('delayed-typeahead', 'Integration | Component | delayed typeahead', {\n  integration: true\n});\n\nconst stubResults = [\n  { name: 'result 1' },\n  { name: 'result 2' }\n];\n\ntest('should render results after typing a term', function(assert) {\n  assert.expect(2);\n\n  this.set('results', []);\n  this.set('fetchResults', (value) =\u003e {\n    assert.equal(value, 'test', 'fetch closure action called with search value');\n    this.set('results', stubResults);\n  });\n\n  this.render(hbs`{{delayed-typeahead fetchResults=fetchResults results=results}}`);\n  this.$('input').val('test');\n  this.$('input').trigger('keyup');\n\n  return wait().then(() =\u003e {\n    assert.equal(this.$('.result').length, 2, 'two results rendered');\n  });\n\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b52674636f495b78ec905a98c63e1233","fields":[{"name":"title","value":"Testing Controllers","type":"string"},{"name":"url","value":"/testing/testing-controllers/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown\nin Unit Testing Basics because Ember.Controller extends Ember.Object.\n\nUnit testing controllers is very simple using the unit test helper which is part\nof the ember-qunit framework.\nTesting Controller Actions\nHere we have a controller PostsController with two properties, a method that\nsets one of those properties, and an action named setProps.\n\n\nYou can follow along by generating your own controller with ember generate\ncontroller posts.\n\n\n  \n    \n      app/controllers/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Controller.extend({\n  propA: 'You need to write tests',\n  propB: 'And write one for me too',\n\n  setPropB(str) {\n    this.set('propB', str);\n  },\n\n  actions: {\n    setProps(str) {\n      this.set('propA', 'Testing is cool');\n      this.setPropB(str);\n    }\n  }\n});\n\n\n\nThe setProps action directly sets one property, and calls the method to set the other.\nIn our generated test, ember-cli already uses the moduleFor helper to set up a test\ncontainer:\n\n  \n    \n      tests/unit/controllers/posts-test.js\n    \n  \n\n  1\n2\n\n  moduleFor('controller:posts', {\n});\n\n\n\nNext we use this.subject() to get an instance of the PostsController and\nwrite a test to check the action. this.subject() is a helper method from the\nember-qunit library that returns a singleton instance of the module set up\nusing moduleFor.\n\n  \n    \n      tests/unit/controllers/posts-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  test('should update A and B on setProps action', function(assert) {\n  assert.expect(4);\n\n  // get the controller instance\n  const ctrl = this.subject();\n\n  // check the properties before the action is triggered\n  assert.equal(ctrl.get('propA'), 'You need to write tests', 'propA initialized');\n  assert.equal(ctrl.get('propB'), 'And write one for me too', 'propB initialized');\n\n  // trigger the action on the controller by using the `send` method,\n  // passing in any params that our action may be expecting\n  ctrl.send('setProps', 'Testing Rocks!');\n\n  // finally we assert that our values have been updated\n  // by triggering our action.\n  assert.equal(ctrl.get('propA'), 'Testing is cool', 'propA updated');\n  assert.equal(ctrl.get('propB'), 'Testing Rocks!', 'propB updated');\n});\n\n\nTesting Controller Needs\nSometimes controllers have dependencies on other controllers. This is\naccomplished by injecting one controller into another. For example, here are two simple controllers. The\nCommentsController uses the PostController via inject:\n\n\nYou can follow along by generating your own controller with ember generate\ncontroller post, and ember generate controller comments.\n\n\n  \n    \n      app/controllers/post.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Controller.extend({\n  title: Ember.computed.alias('model.title')\n});\n\n\n\n  \n    \n      app/controllers/comments.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  post: Ember.inject.controller(),\n  title: Ember.computed.alias('post.title')\n});\n\n\n\nThis time when we setup our moduleFor we need to pass an options object as\nour third argument that has the controller's needs.\n\n  \n    \n      tests/unit/controllers/comments-test.js\n    \n  \n\n  1\n2\n3\n\n  moduleFor('controller:comments', 'Comments Controller', {\n  needs: ['controller:post']\n});\n\n\n\nNow let's write a test that sets a property on our post model in the\nPostController that would be available on the CommentsController.\n\n  \n    \n      tests/unit/controllers/comments-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  test('should modify the post model', function(assert) {\n  assert.expect(2);\n\n  // grab an instance of `CommentsController` and `PostController`\n  const ctrl = this.subject();\n  const postCtrl = ctrl.get('post');\n\n  // wrap the test in the run loop because we are dealing with async functions\n  Ember.run(function() {\n\n    // set a generic model on the post controller\n    postCtrl.set('model', Ember.Object.create({ title: 'foo' }));\n\n    // check the values before we modify the post\n    assert.equal(ctrl.get('title'), 'foo', 'title is set');\n\n    // modify the title of the post\n    postCtrl.get('model').set('title', 'bar');\n\n    // assert that the controllers title has changed\n    assert.equal(ctrl.get('title'), 'bar', 'title is updated');\n  });\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9e4b1c3650cd96bd8485e0b98d722871","fields":[{"name":"title","value":"Testing Models","type":"string"},{"name":"url","value":"/testing/testing-models/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown\nin Unit Testing Basics because Model extends Ember.Object.\n\nEmber Data Models can be tested using the moduleForModel helper.\n\nLet's assume we have a Player model that has level and levelName\nattributes. We want to call levelUp() to increment the level and assign a\nnew levelName when the player reaches level 5.\n\n\nYou can follow along by generating your own model with ember generate\nmodel player.\n\n\n  \n    \n      app/models/player.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  level:     attr('number', { defaultValue: 0 }),\n  levelName: attr('string', { defaultValue: 'Noob' }),\n\n  levelUp() {\n    var newLevel = this.incrementProperty('level');\n    if (newLevel === 5) {\n      this.set('levelName', 'Professional');\n    }\n  }\n});\n\n\n\nNow let's create a test which will call levelUp on the player when they are\nlevel 4 to assert that the levelName changes. We will use moduleForModel:\n\n  \n    \n      tests/unit/models/player-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  import { moduleForModel, test } from 'ember-qunit';\nimport Ember from 'ember';\n\nmoduleForModel('player', 'Unit | Model | player', {\n  // Specify the other units that are required for this test.\n  needs: []\n});\n\ntest('should increment level when told to', function(assert) {\n  // this.subject aliases the createRecord method on the model\n  const player = this.subject({ level: 4 });\n\n  // wrap asynchronous call in run loop\n  Ember.run(() =\u003e player.levelUp());\n\n  assert.equal(player.get('level'), 5, 'level gets incremented');\n  assert.equal(player.get('levelName'), 'Professional', 'new level is called professional');\n});\n\n\nTesting Relationships\nFor relationships you probably only want to test that the relationship\ndeclarations are setup properly.\n\nAssume that a User can own a Profile.\n\n\nYou can follow along by generating your own user and profile models with ember\ngenerate model user and ember generate model profile.\n\n\n  \n    \n      app/models/profile.js\n    \n  \n\n  1\n2\n3\n4\n\n  import Model from 'ember-data/model';\n\nexport default Model.extend({\n});\n\n\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model from 'ember-data/model';\nimport { belongsTo } from 'ember-data/relationships';\n\nexport default Model.extend({\n  profile: belongsTo('profile')\n});\n\n\n\nThen you could test that the relationship is wired up correctly\nwith this test.\n\n  \n    \n      tests/unit/models/user-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  import { moduleForModel, test } from 'ember-qunit';\nimport Ember from 'ember';\n\nmoduleForModel('user', 'Unit | Model | user', {\n  // Specify the other units that are required for this test.\n  needs: ['model:profile']\n});\n\ntest('should own a profile', function(assert) {\n  const User = this.store().modelFor('user');\n  const relationship = Ember.get(User, 'relationshipsByName').get('profile');\n\n  assert.equal(relationship.key, 'profile', 'has relationship with profile');\n  assert.equal(relationship.kind, 'belongsTo', 'kind of relationship is belongsTo');\n});\n\n\n\nEmber Data contains extensive tests around the functionality of\nrelationships, so you probably don't need to duplicate those tests.  You could\nlook at the Ember Data tests for examples of deeper relationship testing if you\nfeel the need to do it.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"50d7d9948190dd788cabc6f1e832ec60","fields":[{"name":"title","value":"Testing Routes","type":"string"},{"name":"url","value":"/testing/testing-routes/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown \nin Unit Testing Basics because Ember.Route extends Ember.Object.\n\nTesting routes can be done both via acceptance or unit tests. Acceptance tests \nwill likely provide better coverage for routes because routes are typically used \nto perform transitions and load data, both of which are tested more easily in \nfull context rather than isolation.\n\nThat being said, sometimes it is important to unit test your routes. For example, \nlet's say we'd like to have an alert that can be triggered from anywhere within \nour application. The alert function displayAlert should be put into the \nApplicationRoute because all actions and events bubble up to it from \nsub-routes and controllers.\n\n\nBy default, Ember CLI does not generate a file for its application route.  To\nextend the behavior of the ember application route we will run the command\nember generate route application.  Ember CLI does however generate an application\ntemplate, so when asked whether we want to overwrite app/templates/application.hbs\nwe will answer 'n'.\n\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Route.extend({\n  actions: {\n    displayAlert(text) {\n      this._displayAlert(text);\n    }\n  },\n\n  _displayAlert(text) {\n    alert(text);\n  }\n});\n\n\n\nIn this route we've separated our concerns:\nThe action displayAlert contains the code that is called when the action is \nreceived, and the private function _displayAlert performs the work. While not \nnecessarily obvious here because of the small size of the functions, separating \ncode into smaller chunks (or \"concerns\"), allows it to be more readily isolated \nfor testing, which in turn allows you to catch bugs more easily.\n\nHere is an example of how to unit test this route:\n\n  \n    \n      tests/unit/routes/application-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n  import { moduleFor, test } from 'ember-qunit';\n\nlet originalAlert;\n\nmoduleFor('route:application', 'Unit | Route | application', {\n  beforeEach() {\n    originalAlert = window.alert; // store a reference to window.alert\n  },\n\n  afterEach() {\n    window.alert = originalAlert; // restore window.alert\n  }\n});\n\ntest('should display an alert', function(assert) {\n  assert.expect(2);\n\n  // with moduleFor, the subject returns an instance of the route\n  let route = this.subject();\n\n  // stub window.alert to perform a qunit test\n  const expectedTextFoo = 'foo';\n  window.alert = (text) =\u003e {\n    assert.equal(text, expectedTextFoo, `expect alert to display ${expectedTextFoo}`);\n  };\n\n  // call the _displayAlert function which triggers the qunit test above\n  route._displayAlert(expectedTextFoo);\n\n  // set up a second stub to perform a test with the actual action\n  const expectedTextBar = 'bar';\n  window.alert = (text) =\u003e {\n    assert.equal(text, expectedTextBar, `expected alert to display ${expectedTextBar}`);\n  };\n\n  // Now use the routes send method to test the actual action\n  route.send('displayAlert', expectedTextBar);\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8da16330e9a3a38299664dcc2f2233af","fields":[{"name":"title","value":"Unit Testing Basics","type":"string"},{"name":"url","value":"/testing/unit-testing-basics/","type":"enum"},{"name":"body","value":"Unit tests are generally used to test a small piece of code and ensure that it\nis doing what was intended. Unlike acceptance tests, they are narrow in scope\nand do not require the Ember application to be running.\n\nAs it is the basic object type in Ember, being able to test a simple\nEmber.Object sets the foundation for testing more specific parts of your\nEmber application such as controllers, components, etc. Testing an Ember.Object\nis as simple as creating an instance of the object, setting its state, and\nrunning assertions against the object. By way of example, let's look at a few\ncommon cases.\nTesting Computed Properties\nLet's start by creating an object that has a computedFoo computed property\nbased on a foo property.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n\n  computedFoo: Ember.computed('foo', function() {\n    const foo = this.get('foo');\n    return `computed ${foo}`;\n  })\n});\n\n\n\nWithin the test for this object we'll create an instance, update the foo property (which\nshould trigger the computed property), and assert that the logic in our\ncomputed property is working correctly.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import { moduleFor, test } from 'ember-qunit';\n\nmoduleFor('model:some-thing', 'Unit | some thing', {\n  unit: true\n});\n\ntest('should correctly concat foo', function(assert) {\n  const someThing = this.subject();\n  someThing.set('foo', 'baz');\n  assert.equal(someThing.get('computedFoo'), 'computed baz');\n});\n\n\n\nSee that we have used moduleFor, one of the several unit-test helpers provided by Ember-Qunit.\nTest helpers provide us with some conveniences, such as the subject function that handles lookup and instantiation for our object under test.\nNote that in a unit test you can customize the initialization of your object under test by passing to the\nsubject function an object containing the instance variables you would like to initialize.  For example, to initialize\nthe property 'foo' in our object under test, we would call this.subject({ foo: 'bar' });\nTesting Object Methods\nNext let's look at testing logic found within an object's method. In this case\nthe testMethod method alters some internal state of the object (by updating\nthe foo property).\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n  testMethod() {\n    this.set('foo', 'baz');\n  }\n});\n\n\n\nTo test it, we create an instance of our class SomeThing as defined above,\ncall the testMethod method and assert that the internal state is correct as a\nresult of the method call.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  test('should update foo on testMethod', function(assert) {\n  const someThing = this.subject();\n  someThing.testMethod();\n  assert.equal(someThing.get('foo'), 'baz');\n});\n\n\n\nIn the event the object's method returns a value you can simply assert that the\nreturn value is calculated correctly. Suppose our object has a calc method\nthat returns a value based on some internal state.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Object.extend({\n  count: 0,\n  calc() {\n    this.incrementProperty('count');\n    let count = this.get('count');\n    return `count: ${count}`;\n  }\n});\n\n\n\nThe test would call the calc method and assert it gets back the correct value.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  test('should return incremented count on calc', function(assert) {\n  const someThing = this.subject();\n  assert.equal(someThing.calc(), 'count: 1');\n  assert.equal(someThing.calc(), 'count: 2');\n});\n\n\nTesting Observers\nSuppose we have an object that has a property and a method observing that property.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n  other: 'no',\n  doSomething: Ember.observer('foo', function() {\n    this.set('other', 'yes');\n  })\n});\n\n\n\nIn order to test the doSomething method we create an instance of SomeThing,\nupdate the observed property (foo), and assert that the expected effects are present.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  test('should set other prop to yes when foo changes', function(assert) {\n  const someThing = this.subject();\n  someThing.set('foo', 'baz');\n  assert.equal(someThing.get('other'), 'yes');\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b51c2d65a54ba4663c32b00ccde28f64","fields":[{"name":"title","value":"An Autocomplete Component","type":"string"},{"name":"url","value":"/tutorial/autocomplete-component/","type":"enum"},{"name":"body","value":"As they search for a rental, users might also want to narrow their search\n to a specific city. Let's build a component that will let them search for\n  properties within a city, and also suggest cities to them as they type.\n\nTo begin, let's generate our new component. We'll call this component \nfilter-listing.\n\n  1\n\n  ember g component filter-listing\n\n\n\nAs before, this creates a Handlebars template \n(app/templates/components/filter-listing.hbs) and a JavaScript file \n(app/components/filter-listing.js).\n\nThe Handlebars template looks like this:\n\n  \n    \n      app/templates/components/filter-listing.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  {{input action=\"search\" value=filter key-up=(action 'autoComplete') class=\"light\" placeholder=\"Search Cities\"}}\n\u003cbutton {{action 'search'}} class=\"button light\"\u003eSearch\u003c/button\u003e\n\n\u003cul class=\"results\"\u003e\n  {{#each filteredList as |item|}}\n      \u003cli {{action 'choose' item.city}}\u003e{{item.city}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nIt contains an {{input}} helper\nthat renders as a text field where the user can type a pattern to \nfilter the list of cities used in a search. The value property of\nthe input will be bound to the filter property in our component.\nThe key-up property will be bound to the autoComplete action.\n\nIt also contains a button that is bound to the search action in our \ncomponent.\n\nLastly, it contains an unordered list that displays the city property\nof each item in the filteredList property in our component. Clicking \nthe list item will fire the choose action with the city property of\nthe item as a parameter, which will then populate the input field with\nthe name of that city.\n\nHere is what the component's JavaScript looks like:\n\n  \n    \n      app/components/filter-listing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  filter: null,\n  filteredList: null,\n  actions: {\n    autoComplete() {\n      this.get('autoComplete')(this.get('filter'));\n      Ember.$('.menu .results').show();\n    },\n    search() {\n      this.get('search')(this.get('filter'));\n    },\n    choose(city) {\n      this.set('filter', city);\n      Ember.$('.menu .results').hide();\n    }\n  }\n});\n\n\n\nThere's a property for each of the filter and filteredList, and \nactions as described above. What's interesting is that only the choose \naction is defined by the component. The actual logic of each of the \nautoComplete and search actions are pulled from the component's \nproperties, which  means that those actions need to be passed \n in by the calling object, a pattern known as closure actions.\n\nTo see how this works, change your application.hbs template to look like this:\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n  \u003cdiv class=\"container\" {{action 'hideAutocomplete'}}\u003e\n    \u003cdiv class=\"menu\"\u003e\n        {{#link-to 'index'}}\n            \u003ch1 class=\"left\"\u003e\n                \u003cimg src=\"http://emberjs.com/images/ember-logo.svg\" alt=\"Ember Logo\"\u003e\n                \u003cem\u003erentals\u003c/em\u003e\n            \u003c/h1\u003e\n        {{/link-to}}\n        \u003cdiv class=\"left links\"\u003e\n            {{#link-to 'about'}}\n                About\n            {{/link-to}}\n            {{#link-to 'contact'}}\n                Contact\n            {{/link-to}}\n        \u003c/div\u003e\n        \u003cdiv class=\"right relative\"\u003e\n          {{filter-listing filteredList=filteredList\n          autoComplete=(action 'autoComplete') search=(action 'search')}}\n        \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"body\"\u003e\n        {{outlet}}\n    \u003c/div\u003e\n\u003c/div\u003e\n\n\n\nWe've added the filter-listing component to our application.hbs template. We \nthen pass in the functions and properties we want the filter-listing \ncomponent to use, so that the application can define some of how it wants \nthe component to behave, and so the component can use those specific \nfunctions and properties.\n\nFor this to work, we need to introduce a controller into our app. \nGenerate a controller for the application by running the following:\n\n  1\n\n  ember g controller application\n\n\n\nNow, define your new controller like so:\n\n  \n    \n      app/controllers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n  import Ember from 'ember';\n\nexport default Ember.Controller.extend({\n  filteredList: null,\n  indexController: Ember.inject.controller('index'),\n  actions: {\n    autoComplete(param) {\n      if (param !== '') {\n        this.get('store').query('rental', { city: param }).then((result) =\u003e this.set('filteredList', result));\n      } else {\n        this.set('filteredList', null);\n      }\n    },\n    search(param) {\n      if (param !== '') {\n        this.store.query('rental', { city: param }).then((result) =\u003e this.set('indexController.model', result));\n      } else {\n        this.get('store').findAll('rental').then((result) =\u003e this.set('indexController.model', result));\n      }\n    },\n    hideAutocomplete() {\n      Ember.$('.menu .results').hide();\n    }\n  }\n});\n\n\n\n\nAs you can see, we define a property in the controller called \nfilteredList, that is referenced from within the autoComplete action.\n When the user types in the text field in our component, this is the \n action that is called. This action filters the rental data to look for \n records in data that match what the user has typed thus far. When this \n action is executed, the result of the query is placed in the \n filteredList property, which is used to populate the autocomplete list \n in the component.\n\nWe also define a search action here that is passed in to the component,\n and called when the search button is clicked. This is slightly different\n  in that the result of the query is actually used to update the model \n  of the index route, and that changes the full rental listing on the \n  page.\n\nFor these actions to work, we need to modify the Mirage config.js file \nto look like this, so that it can respond to our queries.\n\n  \n    \n      mirage/config.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n  export default function() {\n  this.get('/rentals', function(db, request) {\n    let rentals = [{\n        type: 'rentals',\n        id: 1,\n        attributes: {\n          title: 'Grand Old Mansion',\n          owner: 'Veruca Salt',\n          city: 'San Francisco',\n          type: 'Estate',\n          bedrooms: 15,\n          image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg'\n        }\n      }, {\n        type: 'rentals',\n        id: 2,\n        attributes: {\n          title: 'Urban Living',\n          owner: 'Mike Teavee',\n          city: 'Seattle',\n          type: 'Condo',\n          bedrooms: 1,\n          image: 'https://upload.wikimedia.org/wikipedia/commons/0/0e/Alfonso_13_Highrise_Tegucigalpa.jpg'\n        }\n      }, {\n        type: 'rentals',\n        id: 3,\n        attributes: {\n          title: 'Downtown Charm',\n          owner: 'Violet Beauregarde',\n          city: 'Portland',\n          type: 'Apartment',\n          bedrooms: 3,\n          image: 'https://upload.wikimedia.org/wikipedia/commons/f/f7/Wheeldon_Apartment_Building_-_Portland_Oregon.jpg'\n        }\n      }];\n\n    if(request.queryParams.city !== undefined) {\n      let filteredRentals = rentals.filter(function(i) {\n        return i.attributes.city.toLowerCase().indexOf(request.queryParams.city.toLowerCase()) !== -1;\n      });\n      return { data: filteredRentals };\n    } else {\n      return { data: rentals };\n    }\n  });\n}\n\n\n\nWith these changes, users can search for properties in a given city, with\n a search field that provides suggestions as they type.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0e868f2394fbfbdb7f4499c5d077c782","fields":[{"name":"title","value":"Deploying","type":"string"},{"name":"url","value":"/tutorial/deploying/","type":"enum"},{"name":"body","value":"To deploy an Ember application simply transfer the output from ember build to a web server.\nThis can be done with standard Unix file transfer tools such as rsync or scp.\nThere are also services that will let you deploy easily.\nDeploying with scp\nYou can deploy your application to any web server by copying the output from ember build to any web server:\n\n  1\n2\n\n  ember build\nscp -r dist/* myserver.com:/var/www/public/\n\n\nDeploying to surge.sh\nSurge.sh allows you to publish any folder to the web for free.\nTo deploy an Ember application you can simply deploy the folder produced by ember build.\n\nYou will need to have the surge cli tool installed:\n\n  1\n\n  npm install -g surge\n\n\n\nThen you can use the surge command to deploy your application.\nNote you will also need to provide a copy of index.html with the filename 200.html\nso that surge can support Ember's client-side routing.\n\n  1\n2\n3\n4\n\n  ember build --environment=production\ncd dist\ncp index.html 200.html\nsurge\n\n\n\nPress return to accept the defaults when deploying the first time.\nYou will be provided with a URL in the form funny-name.surge.sh that you can use for repeated deployments.\n\nSo to deploy to the same URL after making changes, perform the same steps, this time providing the URL for your site:\n\n  1\n2\n3\n4\n5\n\n  rm -rf dist\nember build --environment=production\ncd dist\ncp index.html 200.html\nsurge funny-name.surge.sh\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"822a91ead6d167614bc8e05f1204ed58","fields":[{"name":"title","value":"Using Ember Addons","type":"string"},{"name":"url","value":"/tutorial/ember-addons/","type":"enum"},{"name":"body","value":"As you're developing your Ember app, you'll likely run into common scenarios that aren't addressed by Ember itself,\nsuch as authentication or using SASS for your stylesheets.\nEmber CLI provides a common format called Ember Addons for distributing reusable libraries\nto solve these problems.\nAdditionally, you may want to make use of front-end dependencies like a CSS framework\nor a JavaScript datepicker that aren't specific to Ember apps.\nEmber CLI supports installing these packages through the standard Bower package manager.\nAddons\nEmber Addons are installed using NPM (e.g. npm install --save-dev ember-cli-sass).\nAddons may bring in other dependencies by modifying your project's bower.json file automatically.\n\nYou can find listings of addons on Ember Observer.\nInstalling an Ember Addon for our application\nFor our sample application, Ember Rentals, we have created an ember addon containing all of the stylesheets and images you will need for the project.\n\nTo install this addon, navigate to your ember-cli project and type:\n\n  1\n\n  ember install ember-tutorial\n\n\n\nWhich will return:\n\n  1\n2\n\n  Installed packages for tooling via npm.\nInstalled addon package.\n\n\n\nThis will add app.css to your project, which will be added to the build pipeline, and eventually appear in the vendor.css portion of your application. It will also add the NPM package ember-tutorial to your package.json, which will ensure you always have the latest version of the addon when building your project.\n\nSince this was added to vendor.css, you will not see this in your app directory, and can continue to use app/styles/app.css to add custom styles to your ember application.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8a6750270c62ad63c47f58491a60dcb5","fields":[{"name":"title","value":"Creating a new app","type":"string"},{"name":"url","value":"/tutorial/ember-cli/","type":"enum"},{"name":"body","value":"Ember CLI, Ember's command line interface, provides a standard project\nstructure, a set of development tools, and an addon system.\nThis allows Ember developers to focus on building apps rather\nthan building the support structures that make them run.\nFrom your command line, a quick ember --help shows\nthe commands Ember CLI provides. For more information on a specific command,\ntype ember help \u003ccommand-name\u003e.\nCreating a New App\nTo create a new project using Ember CLI, use the new command. In preparation\nfor the tutorial in the next section, you can make an app called ember-rentals.\n\n  1\n\n  ember new ember-rentals\n\n\nDirectory Structure\nThe new command generates a project structure with the following files and\ndirectories:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  |--app\n|--bower_components\n|--config\n|--dist\n|--node_modules\n|--public\n|--tests\n|--tmp\n|--vendor\n\nbower.json\nember-cli-build.js\npackage.json\nREADME.md\ntestem.js\n\n\n\nLet's take a look at the folders and files Ember CLI generates.\n\napp: This is where folders and files for models, components, routes,\ntemplates and styles are stored. The majority of your coding on an Ember\nproject happens in this folder.\n\nbower_components / bower.json: Bower is a dependency management tool.\nIt is used in Ember CLI to manage front-end plugins and component dependencies\n(HTML, CSS, JavaScript, etc).  All Bower components are installed in the\nbower_components directory.  If we open bower.json, we see the list of\ndependencies that are installed automatically including Ember, jQuery, Ember\nData and QUnit (for testing). If we add additional front-end dependencies,\nsuch as Bootstrap, we will see them listed here and added to the\nbower_components directory.\n\nconfig: The config directory contains the environment.js where you can\nconfigure settings for your app.\n\ndist: When we build our app for deployment, the output files will be created\nhere.\n\nnode_modules / package.json: This directory and file are from npm.\nnpm is the package manager for Node.js. Ember is built with Node and uses a\nvariety of Node.js modules for operation. The package.json file maintains the\nlist of current npm dependencies for the app.  Any Ember-CLI\nadd-ons you install will also show up here. Packages listed in package.json\nare installed in the node_modules directory.\n\npublic: This directory contains assets such as images and fonts.\n\nvendor: This directory is where front-end dependencies (such as JavaScript\nor CSS) that are not managed by Bower go.\n\ntests / testem.js: Automated tests for our app go in the tests folder,\nand Ember CLI's test runner testem is configured in testem.js.\n\ntmp: Ember CLI temporary files live here.\n\nember-cli-build.js: This file describes how Ember CLI should build our app.\nThe App Directory\nAll of the code you contribute to your application will generally exist in the app directory, so let's take a moment to familiarize ourselves with its structure.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  |--components\n|--controllers\n|--helpers\n|--models\n|--routes\n|--styles\n|--templates\n\napp.js\nindex.html\nresolver.js\nrouter.js\n\n\n\nThe folders should be easy to understand. Each item you generate using Ember-CLI will create files in the appropriate folders. Ember Components will be placed in the components directory, etc. \n\nThe index.html file is the page representing your single-page app, and app.js is the entry-point for your Ember application. In a basic application, you shouldn't need to make many edits to these files, but if you would like to learn more check out the Ember-CLI documentation. \nES6 Modules\nIf you take a look at app/router.js, you'll notice some syntax that may be\nunfamiliar to you.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import Ember from 'ember';\nimport config from './config/environment';\n\nconst Router = Ember.Router.extend({\n  location: config.locationType\n});\n\nRouter.map(function() {\n});\n\nexport default Router;\n\n\n\nEmber CLI uses ECMAScript 2015 (ES2015 for short or previously known as ES6) modules to organize application\ncode.\nFor example, the line import Ember from 'ember'; gives us access to the actual\nEmber.js library as the variable Ember. And the import config from\n'./config/environment'; line gives us access to our app's configuration data\nas the variable config. const is a way to declare a read-only variable, \nas to make sure it is not accidentally reassigned elsewhere. At the end of the file,\nexport default Router; makes the Router variable defined in this file available \nto other parts of the app.\nUpgrading Ember\nBefore continuing to the tutorial, make sure that you have the most recent\nversion of Ember installed. If the versions of ember and ember-data in\nbower.json are lower than the version number in the upper-left corner of these\nGuides, update the version numbers in bower.json and then run bower install.\nThe Development Server\nOnce we have a new project in place, we can confirm everything is working by\nstarting the Ember development server:\n\n  1\n\n  ember server\n\n\n\nor, for short:\n\n  1\n\n  ember s\n\n\n\nIf we navigate to localhost:4200, we'll see our brand new app displaying\nthe text \"Welcome to Ember\".\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e850e940d46dd6b04ba07d981ff5f425","fields":[{"name":"title","value":"Ember Data","type":"string"},{"name":"url","value":"/tutorial/ember-data/","type":"enum"},{"name":"body","value":"Currently, our app is using hard-coded data for rentals in the index route handler to set the model.\nAs our application grows, we will want to be able to create new rentals,\nmake updates to them, delete them, and save these changes to a backend server.\nEmber integrates with a data management library called Ember Data to help solve this problem.\n\nLet's generate our first Ember Data model called rental:\n\n  1\n\n  ember g model rental title:string owner:string city:string type:string image:string bedrooms:number\n\n\n\nThis results in the creation of a model file and a test file:\n\n  1\n2\n3\n4\n\n  installing model\n  create app/models/rental.js\ninstalling model-test\n  create tests/unit/models/rental-test.js\n\n\n\nWhen we open the model file, we see:\n\n  \n    \n      app/models/rental.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  title: attr('string'),\n  owner: attr('string'),\n  city: attr('string'),\n  type: attr('string'),\n  image: attr('string'),\n  bedrooms: attr('number')\n});\n\n\n\nWe just generated a new route called rental. You'll notice we also specified a number of attributes after rental, like title, owner, and city. For each model, you can specify an unlimited number of attributes. They each carry the format name:type, and are separated by a space. \n\nNow we have a model in our Ember Data store.\nUsing Mirage with Ember Data\nEmber Data can be configured to save data in a variety of ways, but often it is setup to work with a backend API server.\nFor this tutorial, we will use Mirage.\nThis will allow us to create fake data to work with while developing our app and mimic a running backend server.\n\nLet's start by installing Mirage:\n\n  1\n\n  ember install ember-cli-mirage\n\n\n\nIf you were running ember serve in another shell, restart the server to include Mirage in your build.\n\nLet's now configure Mirage to send back our rentals that we had defined above by updating app/mirage/config.js:\n\n  \n    \n      app/mirage/config.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n  export default function() {\n  this.get('/rentals', function() {\n    return {\n      data: [{\n        type: 'rentals',\n        id: 1,\n        attributes: {\n          title: 'Grand Old Mansion',\n          owner: 'Veruca Salt',\n          city: 'San Francisco',\n          type: 'Estate',\n          bedrooms: 15,\n          image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg'\n        }\n      }, {\n        type: 'rentals',\n        id: 2,\n        attributes: {\n          title: 'Urban Living',\n          owner: 'Mike Teavee',\n          city: 'Seattle',\n          type: 'Condo',\n          bedrooms: 1,\n          image: 'https://upload.wikimedia.org/wikipedia/commons/0/0e/Alfonso_13_Highrise_Tegucigalpa.jpg'\n        }\n      }, {\n        type: 'rentals',\n        id: 3,\n        attributes: {\n          title: 'Downtown Charm',\n          owner: 'Violet Beauregarde',\n          city: 'Portland',\n          type: 'Apartment',\n          bedrooms: 3,\n          image: 'https://upload.wikimedia.org/wikipedia/commons/f/f7/Wheeldon_Apartment_Building_-_Portland_Oregon.jpg'\n        }\n      }]\n    };\n  });\n}\n\n\n\nThis configures Mirage so that whenever Ember Data makes a GET request to /rentals,\nMirage will return this JavaScript object as JSON.\nUpdating the Model Hook\nTo use our new data store, we need to update the model hook in our route handler.\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import Ember from 'ember';\n\nexport default Ember.Route.extend({\n  model() {\n    return this.store.findAll('rental');\n  }\n});\n\n\n\nWhen we call this.store.findAll('rental'), Ember Data will make a GET request to /rentals.\nYou can read more about Ember Data in the Models section.\n\nSince we're using Mirage in our development environment, Mirage will return the data we've provided.\nWhen we deploy our app to a production server, we will need to provide a backend for Ember Data to communicate with.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"53885e0104fc7f46199194d9a3292362","fields":[{"name":"title","value":"Handlebars Helper","type":"string"},{"name":"url","value":"/tutorial/hbs-helper/","type":"enum"},{"name":"body","value":"So far, our app is directly showing the user data from our Ember Data models.\nAs our app grows, we will want to manipulate data further before presenting it to our users.\nFor this reason, Ember offers Handlebars template helpers to decorate the data in our templates.\nLet's use a handlebars helper to allow our users to quickly see if a property is \"standalone\" or part of a \"Community\".\n\nTo get started, let's generate a helper for rental-property-type:\n\n  1\n\n  ember g helper rental-property-type\n\n\n\nThis will create two files, our helper and its related test:\n\n  1\n2\n3\n4\n\n  installing helper\n  create app/helpers/rental-property-type.js\ninstalling helper-test\n  create tests/unit/helpers/rental-property-type-test.js\n\n\n\nOur new helper starts out with some boilerplate code from the generator:\n\n  \n    \n      app/helpers/rental-property-type.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import Ember from 'ember';\n\nexport function rentalPropertyType(params/*, hash*/) {\n  return params;\n}\n\nexport default Ember.Helper.helper(rentalPropertyType);\n\n\n\nLet's update our rental-listing component template to use our new helper and pass in rental.type:\n\n  \n    \n      app/templates/components/rental-listing.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \u003carticle class=\"listing\"\u003e\n    \u003ca {{action 'enlargeImage'}} class=\"{{if wide \"wide\"}}\"\u003e\n    \u003cimg src=\"{{rental.image}}\" alt=\"\"\u003e\n    \u003csmall\u003eView Larger\u003c/small\u003e\n    \u003c/a\u003e\n    \u003ch3\u003e{{rental.title}}\u003c/h3\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eOwner:\u003c/span\u003e {{rental.owner}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eType:\u003c/span\u003e {{rental-property-type rental.type}} - {{rental.type}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eLocation:\u003c/span\u003e {{rental.city}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eNumber of bedrooms:\u003c/span\u003e {{rental.bedrooms}}\n    \u003c/div\u003e\n\u003c/article\u003e\n\n\n\nIdeally we'll see \"Type: Standalone - Estate\" for our first rental property.\nInstead, our default template helper is returning back our rental.type values.\nLet's update our helper to look if a property exists in an array of communityPropertyTypes,\nif so, we'll return either 'Community' or 'Standalone':\n\n  \n    \n      app/helpers/rental-property-type.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  import Ember from 'ember';\n\nconst communityPropertyTypes = [\n  'Condo',\n  'Townhouse',\n  'Apartment'\n];\n\nexport function rentalPropertyType([type]/*, hash*/) {\n  if (communityPropertyTypes.contains(type)) {\n    return 'Community';\n  }\n\n  return 'Standalone';\n}\n\nexport default Ember.Helper.helper(rentalPropertyType);\n\n\n\nHandlebars passes an array of arguments from our template to our helper.\nWe are using ES2015 destructuring to get the first item in the array and name it type.\nThen we can check to see if type exists in our communityPropertyTypes array.\n\nNow in our browser we should see that the first rental property is listed as \"Standalone\",\nwhile the other two are listed as \"Community\".\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"5b4818ac5e9b9ee98b96246b74c52fbc","fields":[{"name":"title","value":"The Model Hook","type":"string"},{"name":"url","value":"/tutorial/model-hook/","type":"enum"},{"name":"body","value":"Now, let's add a list of available rentals to the index template.\nWe know that rentals will not be static, since eventually users will be able to add, update, and delete them.\nFor this reason, we'll need a rentals model to save information about the rentals.\nTo keep things simple at first, we'll use a hard-coded array of JavaScript objects.\nLater, we'll switch to using Ember Data, a library for robustly managing data in our app.\n\nHere's what our homepage will look like when we're done:\n\n\n\nIn Ember, route handlers are responsible for loading model data.\nLet's open app/routes/index.js and add our hard-coded data as the return value of the model hook:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n  import Ember from 'ember';\n\nvar rentals = [{\n  id: 1,\n  title: 'Grand Old Mansion',\n  owner: 'Veruca Salt',\n  city: 'San Francisco',\n  type: 'Estate',\n  bedrooms: 15,\n  image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg'\n}, {\n  id: 2,\n  title: 'Urban Living',\n  owner: 'Mike TV',\n  city: 'Seattle',\n  type: 'Condo',\n  bedrooms: 1,\n  image: 'https://upload.wikimedia.org/wikipedia/commons/0/0e/Alfonso_13_Highrise_Tegucigalpa.jpg'\n}, {\n  id: 3,\n  title: 'Downtown Charm',\n  owner: 'Violet Beauregarde',\n  city: 'Portland',\n  type: 'Apartment',\n  bedrooms: 3,\n  image: 'https://upload.wikimedia.org/wikipedia/commons/f/f7/Wheeldon_Apartment_Building_-_Portland_Oregon.jpg'\n}];\n\nexport default Ember.Route.extend({\n  model() {\n    return rentals;\n  }\n});\n\n\n\nHere, we are using the ES6 shorthand method definition syntax: model() is the same as writing model: function().\n\nThe model function acts as a hook, meaning that Ember will call it for us during different times in our app.\nThe model hook we've added to our index route handler will be called when a user enters the index route.\n\nThe model hook returns our rentals array and passes it to our index template as the model property.\n\nNow, let's switch over to our template.\nWe can use the model data to display our list of rentals.\nHere, we'll use another common Handlebars helper called {{each}}.\nThis helper will let us loop through each of the objects in our model:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n  \u003cdiv class=\"jumbo\"\u003e\n    \u003cimg class=\"right\" src=\"http://emberjs.com/images/blog/2016-02/lts-tomster.png\" alt=\"Tomster\"\u003e\n    \u003ch2\u003eWelcome!\u003c/h2\u003e\n    \u003cp\u003e\n        We hope you find exactly what you're looking for in a place to stay.\n        \u003cbr\u003eBrowse our listings, or use the search box above to narrow your search.\n    \u003c/p\u003e\n    {{#link-to 'about' class=\"button\"}}\n        About Us\n    {{/link-to}}\n\u003c/div\u003e\n\n{{#each model as |rental|}}\n    \u003carticle class=\"listing\"\u003e\n        \u003ch3\u003e{{rental.title}}\u003c/h3\u003e\n        \u003cdiv class=\"detail\"\u003e\n            \u003cspan\u003eOwner:\u003c/span\u003e {{rental.owner}}\n        \u003c/div\u003e\n        \u003cdiv class=\"detail\"\u003e\n            \u003cspan\u003eType:\u003c/span\u003e {{rental.type}}\n        \u003c/div\u003e\n        \u003cdiv class=\"detail\"\u003e\n            \u003cspan\u003eLocation:\u003c/span\u003e {{rental.city}}\n        \u003c/div\u003e\n        \u003cdiv class=\"detail\"\u003e\n            \u003cspan\u003eNumber of bedrooms:\u003c/span\u003e {{rental.bedrooms}}\n        \u003c/div\u003e\n    \u003c/article\u003e\n{{/each}}\n\n\n\nIn this template, we loop through each model object and call it rental.\nFor each rental, we then create a listing with information about the property.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8f7c462799c1ed23420d25cc16dd828d","fields":[{"name":"title","value":"Routes and Templates","type":"string"},{"name":"url","value":"/tutorial/routes-and-templates/","type":"enum"},{"name":"body","value":"To demonstrate the basic setup and processing of an Ember application, this section will walk through building an Ember application for a property rental site called Ember Rentals.\nIt will start with a homepage, an about page and a contact page.\nLet's take a look at the application from the user perspective before we get started.\n\n\nThis is a preview of the application we are going to create.\n\nWe arrive at the home page which shows a list of rentals.\nFrom here, we will be able to navigate to an about page and a contact page.\n\nLet's make sure we have a fresh Ember CLI app called ember-rentals by running:\n\n  1\n\n  ember new ember-rentals\n\n\n\nThis will create a new directory, ember-rentals, which contains our application. Each time we create a new Ember-CLI application, we need to move into that directory before we can continue working on our application.\n\n  1\n\n  cd ember-rentals\n\n\n\nBefore we start building the three pages for our app,\nwe are going to clear out the contents of the app/templates/application.hbs file\nand only leave the {{outlet}} code in place.\nWe'll talk more about the role of the application.hbs file after our site has a few routes.\n\nNow, let's start by building our \"about\" page.\nRemember, when the URL path /about is loaded,\nthe router will map the URL to the route handler of the same name, about.js.\nThe route handler then loads a template.\nThe Application Template\nThe application template can contain whatever you wish, but generally, these elements appear on each page of your application. So, if for example your application has a navigation bar (which almost never disappears), the application template is a good place for the markup you'll need to render it.\n\nFor our application, we're going to add the following markup to our app/templates/application.hbs file, replacing the default markup;\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \u003cdiv class=\"container\"\u003e\n    \u003cdiv class=\"menu\"\u003e\n        \u003ch1 class=\"left\"\u003e\n            \u003cimg src=\"http://emberjs.com/images/ember-logo.svg\" alt=\"Ember Logo\"\u003e\n            \u003cem\u003erentals\u003c/em\u003e\n        \u003c/h1\u003e\n        \u003cdiv class=\"left links\"\u003e\n            \u003ca href=\"#\"\u003eAbout\u003c/a\u003e\n            \u003ca href=\"#\"\u003eContact\u003c/a\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"right relative\"\u003e\n            \u003cinput class=\"light\" type=\"text\" placeholder=\"Search Cities\"\u003e\n            \u003cbutton class=\"button light\"\u003eSearch\u003c/button\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"body\"\u003e\n        {{outlet}}\n    \u003c/div\u003e\n\u003c/div\u003e\n\n\n\n\nThis is our Application View, without anything rendered into it.\nOutlets\nWhile all of the HTML markup in our application.hbs template might already be familiar to you, the {{outlet}} is probably new. This is how Ember renders child templates into their parent templates. In the parent template, an {{outlet}} specifies where the child template will be inserted, or rendered. Then, when anyone navigates to a child route in your application, they will see both the application, and the child view (rendered into the application view).\nGenerating our first route\nBy default, when you visit the / page of your application, the index route is rendered into the {{outlet}}.\n\nBut first, we will need to generate our index route, along with our index template! \n\nSince technically an ember application could exist with only one page, this is not created for us by default. So, we will need to use the generate command to add it.\n\nIf we run ember help generate, we can see a variety of tools that come with Ember for automatically generating files for various Ember resources.\nLet's use the route generator to create our index route.\n\n  1\n\n  ember generate route index\n\n\n\nor for short,\n\n  1\n\n  ember g route index\n\n\n\nWe can then see what actions were taken by the generator:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  installing route\n  create app/routes/index.js\n  create app/templates/index.hbs\nupdating router\n  add route index\ninstalling route-test\n  create tests/unit/routes/index-test.js\n\n\n\nThree new files are created: one for the route handler, one for the template the route handler will render,\nand a test file.\nThe fourth file that is touched is the router.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import Ember from 'ember';\nimport config from './config/environment';\n\nconst Router = Ember.Router.extend({\n  location: config.locationType\n});\n\nRouter.map(function() {\n});\n\nexport default Router;\n\n\n\nBy default, the index route handler loads the index.hbs template.\nThis means we don't actually have to change anything in the new app/routes/index.js file for the index.hbs template to render as we want.\n\nUnlike other child routes you will generate, the index route is special:\nit does NOT require an entry in the router's mapping.\nWe'll learn more about why the entry isn't required when we look at nested routes in Ember.\n\nWith all of the routing in place from the generator, we can get right to work on coding our template.\n\nLet's demonstrate how the index.hbs template gets rendered into the application template by placing a small message inside our index.hbs file.\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n\n  This text is rendered into the APPLICATION OUTLET!\n\n\n\n\n\nNow that you understand how outlets work, let's use the following markup to render a nice welcome message into our index.hbs route\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  \u003cdiv class=\"jumbo\"\u003e\n    \u003cimg class=\"right\" src=\"http://emberjs.com/images/blog/2016-02/lts-tomster.png\" alt=\"Tomster\"\u003e\n    \u003ch2\u003eWelcome!\u003c/h2\u003e\n    \u003cp\u003e\n        We hope you find exactly what you're looking for in a place to stay.\n        \u003cbr\u003eBrowse our listings, or use the search box above to narrow your search.\n    \u003c/p\u003e\n    \u003ca href=\"#\" class=\"button\"\u003eAbout Us\u003c/a\u003e\n\u003c/div\u003e\n\n\n\n\nThis is the index page for our application.\nAn About Route\nYou'll see in our example that we link to a couple of other pages: About and Contact.\n\nJust like in our previous example, lets go ahead and create a route called about.\n\n  1\n\n  ember g route about\n\n\n\nYou'll notice that, just like in the above example, several files were added to our project. However, one additional thing happened, which is very interesting. \n\nIf we look inside router.js, we will see:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  import Ember from 'ember';\nimport config from './config/environment';\n\nconst Router = Ember.Router.extend({\n  location: config.locationType\n});\n\nRouter.map(function() {\n  this.route('about');\n});\n\nexport default Router;\n\n\n\nWhen we open the router, we can see that the generator has mapped a new about route for us.\nThis route will load the about route handler.\n\nFor this tutorial, you won't need to make any modifications to the router.js file. But it's important to keep in mind where this file is located. In the future, when you learn about advanced routing concepts, you may need to modify this file by hand.\n\nNow, we can open app/templates/about.hbs and add the following markup:\n\n  \n    \n      app/templates/about.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  \u003cdiv class=\"jumbo\"\u003e\n    \u003cimg class=\"right\" src=\"http://emberjs.com/images/blog/2016-02/lts-tomster.png\" alt=\"Tomster\"\u003e\n    \u003ch2\u003eAbout Ember Rentals\u003c/h2\u003e\n    \u003cp\u003e\n        The Ember Rentals website is a delightful project created to explore Ember.\n        By building a property rental site, we can simultaneously imagine traveling\n        AND building Ember applications.\n    \u003c/p\u003e\n\u003c/div\u003e\n\n\n\nRun ember serve (or ember s for short) from the shell to start the Ember development server,\nand then go to localhost:4200/about to see our new app in action!\n\n\nThis is the about page for our application.\nA Contact Route\nLet's create another route with details for contacting the company.\nOnce again, we'll start by generating a route, a route handler, and a template.\n\n  1\n\n  ember g route contact\n\n\n\nWe see that our generator has created a contact route in the app/router.js file,\nand a corresponding route handler in app/routes/contact.js.\nSince we will be using the contact template, the contact route does not need any additional changes.\n\nIn contact.hbs, we can add the details for contacting our Ember Rentals HQ:\n\n  \n    \n      app/templates/contact.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  \u003cdiv class=\"jumbo\"\u003e\n    \u003cimg class=\"right\" src=\"http://emberjs.com/images/blog/2016-02/lts-tomster.png\" alt=\"Tomster\"\u003e\n    \u003ch2\u003eContact Us\u003c/h2\u003e\n    \u003cp\u003eEmber Rentals Representatives would love to help you\u003cbr\u003echoose a destination or answer\n        any questions you may have.\u003c/p\u003e\n\n    Ember Rentals HQ\n    \u003caddress\u003e\n        1212 Test Address Avenue\u003cbr\u003e\n        Testington, OR 97233\n    \u003c/address\u003e\n    \u003ca href=\"tel:503.555.1212\"\u003e+1 (503) 555-1212\u003c/a\u003e\u003cbr\u003e\n    \u003ca href=\"mailto:emberrentalsrep@emberrentals.com\"\u003esuperrentalsrep@superrentals.com\u003c/a\u003e\n\u003c/div\u003e\n\n\n\nNow we have completed our second route.\nIf we go to the URL localhost:4200/contact, we'll arrive on our contact page.\n\n\nThis is the contact page for our application.\nNavigating with Links and the {{link-to}} Helper\nWe really don't want users to have to know our URLs in order to move around our site,\nso let's add some navigational links at the bottom of each page.\nLet's make a contact link on the about page and an about link on the contact page.\n\nEmber has built-in helpers that provide functionality such as linking to other routes.\nHere we will use the {{link-to}} helper in our code to link between routes:\n\n  \n    \n      app/templates/about.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  \u003cdiv class=\"jumbo\"\u003e\n    \u003cimg class=\"right\" src=\"http://emberjs.com/images/blog/2016-02/lts-tomster.png\" alt=\"\"\u003e\n    \u003ch2\u003eAbout Ember Rentals\u003c/h2\u003e\n    \u003cp\u003e\n        The Ember Rentals website is a delightful project created to explore Ember.\n        By building a property rental site, we can simultaneously imagine traveling\n        AND building Ember applications.\n    \u003c/p\u003e\n    {{#link-to 'index' class=\"button\"}}\n        Contact Us\n    {{/link-to}}\n\u003c/div\u003e\n\n\n\nThe {{link-to}} helper takes an argument with the name of the route to link to, in this case: contact.\nWhen we look at our about page, we now have a working link to our contact page.\n\n\nThis is the about page for our application, with the addition of a link button.\n\nNow, we'll add a link to our contact page so we can navigate from back and forth between about and contact.\n\n  \n    \n      app/templates/contact.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \u003cdiv class=\"jumbo\"\u003e\n    \u003cimg class=\"right\" src=\"http://emberjs.com/images/blog/2016-02/lts-tomster.png\" alt=\"Tomster\"\u003e\n    \u003ch2\u003eContact Us\u003c/h2\u003e\n    \u003cp\u003eEmber Rentals Representatives would love to help you\u003cbr\u003echoose a destination or answer\n        any questions you may have.\u003c/p\u003e\n\n    Ember Rentals HQ\n    \u003caddress\u003e\n        1212 Test Address Avenue\u003cbr\u003e\n        Testington, OR 97233\n    \u003c/address\u003e\n    \u003ca href=\"tel:503.555.1212\"\u003e+1 (503) 555-1212\u003c/a\u003e\u003cbr\u003e\n    \u003ca href=\"mailto:emberrentalsrep@emberrentals.com\"\u003esuperrentalsrep@superrentals.com\u003c/a\u003e\n\n    {{#link-to 'about' class=\"button\"}}\n        About\n    {{/link-to}}\n\u003c/div\u003e\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d798f9ea9b38ded8f2977b863cd8332b","fields":[{"name":"title","value":"A Simple Component","type":"string"},{"name":"url","value":"/tutorial/simple-component/","type":"enum"},{"name":"body","value":"As a user looks through our list of rentals, they may want to have some interactive options to help them make a decision.\nLet's add the ability to hide and show an image for each rental.\nTo do this, we'll use a component.\n\nLet's generate a rental-listing component that will manage the behavior for each of our rentals.\nA dash is required in every component name to avoid conflicting with a possible HTML element.\nSo rental-listing is acceptable but rental would not be.\n\n  1\n\n  ember g component rental-listing\n\n\n\nEmber CLI will then generate a handful of files for our component:\n\n  1\n2\n3\n4\n5\n\n  installing component\n  create app/components/rental-listing.js\n  create app/templates/components/rental-listing.hbs\ninstalling component-test\n  create tests/integration/components/rental-listing-test.js\n\n\n\nA component consists of two parts:\na Handlebars template that defines how it will look (app/templates/components/rental-listing.hbs)\nand a JavaScript source file (app/components/rental-listing.js) that defines how it will behave.\n\nOur new rental-listing component will manage how a user sees and interacts with a rental.\nTo start, let's move the rental display details for a single rental from the index.hbs template\ninto rental-listing.hbs:\n\n  \n    \n      app/templates/components/rental-listing.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \u003carticle class=\"listing\"\u003e\n    \u003ca\u003e\n    \u003cimg src=\"{{rental.image}}\" alt=\"\"\u003e\n    \u003csmall\u003eView Larger\u003c/small\u003e\n    \u003c/a\u003e\n    \u003ch3\u003e{{rental.title}}\u003c/h3\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eOwner:\u003c/span\u003e {{rental.owner}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eType:\u003c/span\u003e {{rental.type}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eLocation:\u003c/span\u003e {{rental.city}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eNumber of bedrooms:\u003c/span\u003e {{rental.bedrooms}}\n    \u003c/div\u003e\n\u003c/article\u003e\n\n\n\nIn our index.hbs template, let's replace the old HTML markup within our {{#each}} loop\nwith our new rental-listing component:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  \u003cdiv class=\"jumbo\"\u003e\n    \u003cimg class=\"right\" src=\"http://emberjs.com/images/blog/2016-02/lts-tomster.png\" alt=\"Tomster\"\u003e\n    \u003ch2\u003eWelcome!\u003c/h2\u003e\n    \u003cp\u003e\n        We hope you find exactly what you're looking for in a place to stay.\n        \u003cbr\u003eBrowse our listings, or use the search box above to narrow your search.\n    \u003c/p\u003e\n    {{#link-to 'about' class=\"button\"}}\n        About Us\n    {{/link-to}}\n\u003c/div\u003e\n\n{{#each model as |rentalUnit|}}\n  {{rental-listing rental=rentalUnit}}\n{{/each}}\n\n\n\nHere we invoke the rental-listing component by name,\nand assign each rentalUnit as the rental attribute of the component.\nHiding and Showing an Image\nNow we can add functionality that will enlarge the image of a rental when requested by the user.\n\nLet's use the {{#if}} helper to add the class wide to our current link only when wide is set to true.\n\n  \n    \n      app/templates/components/rental-listing.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \u003carticle class=\"listing\"\u003e\n    \u003ca class=\"{{if wide \"wide\"}}\"\u003e\n    \u003cimg src=\"{{rental.image}}\" alt=\"\"\u003e\n    \u003csmall\u003eView Larger\u003c/small\u003e\n    \u003c/a\u003e\n    \u003ch3\u003e{{rental.title}}\u003c/h3\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eOwner:\u003c/span\u003e {{rental.owner}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eType:\u003c/span\u003e {{rental.type}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eLocation:\u003c/span\u003e {{rental.city}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eNumber of bedrooms:\u003c/span\u003e {{rental.bedrooms}}\n    \u003c/div\u003e\n\u003c/article\u003e\n\n\n\nThe value of wide comes from our component's Javascript file, in this case rental-listing.js.\nSince we do not want the image to be showing at first, we will set the property to start as false:\n\n  \n    \n      app/components/rental-listing.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  wide: false\n});\n\n\n\nTo make it where clicking on the image makes it larger,\nwe will need to add an action that changes the value of wide to true.\nLet's call this action enlargeImage\n\n  \n    \n      app/templates/components/rental-listing.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \u003carticle class=\"listing\"\u003e\n    \u003ca {{action 'enlargeImage'}} class=\"{{if wide \"wide\"}}\"\u003e\n    \u003cimg src=\"{{rental.image}}\" alt=\"\"\u003e\n    \u003csmall\u003eView Larger\u003c/small\u003e\n    \u003c/a\u003e\n    \u003ch3\u003e{{rental.title}}\u003c/h3\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eOwner:\u003c/span\u003e {{rental.owner}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eType:\u003c/span\u003e {{rental.type}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eLocation:\u003c/span\u003e {{rental.city}}\n    \u003c/div\u003e\n    \u003cdiv class=\"detail\"\u003e\n        \u003cspan\u003eNumber of bedrooms:\u003c/span\u003e {{rental.bedrooms}}\n    \u003c/div\u003e\n\u003c/article\u003e\n\n\n\nClicking this button will send the action to the component.\nEmber will then go into the actions hash and call the enlargeImage function.\nLet's create the enlargeImage function and toggle wide on our component:\n\n  \n    \n      app/components/rental-listing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Component.extend({\n  isImageShowing: false,\n  actions: {\n    enlargeImage() {\n      this.toggleProperty('wide');\n    }\n  }\n});\n\n\n\nNow when we click the button in our browser, our image becomes larger. When we click it again, it shrinks back to its original size.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]}]}